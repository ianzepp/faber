// =============================================================================
// REGIMEN - Resource Management (cura)
// =============================================================================
//
// The cura block provides scoped resource management. Resources are acquired
// at block entry and released at block exit, regardless of how control leaves.
//
// GRAMMAR:
// cura curatorKind? expression? ('pro' | 'fit' | 'fiet') typeAnnotation? IDENTIFIER blockStmt catchClause?
//
// CURATOR KINDS:
// (omitted)  - Generic resource (expression required)
// arena      - Arena allocator (no expression)
// page       - Page allocator (no expression)
// liber      - File handle (planned)
// transactio - Transaction (planned)
// mutex      - Lock guard (planned)
// conexio    - Connection (planned)
//
// VERBS:
// fit  - sync binding ("it becomes")
// fiet - async binding ("it will become")
// pro  - alternative sync binding
//
// TARGET OUTPUT:
// TypeScript: try/finally with solve?.() cleanup
// Python:     with statement (context manager)
// Rust:       block scope with Drop (RAII)
// C++:        block scope with RAII destructor
// Zig:        defer arena.deinit() pattern
//
// ETYMOLOGY:
// cura: "care, concern" (what you're caring for)
// curator: "one who cares for, steward" (resource manager interface)
// solve: "release, free" (cleanup method)
//
// WHY "cura":
// - Latin for "care" - you're caring for a resource
// - Short and memorable
// - Pairs naturally with curator/curatum

// =============================================================================
// ALLOCATOR SCOPES (arena)
// =============================================================================

// Arena allocators provide fast allocation with bulk deallocation.
// All memory is freed when the scope exits.
// On GC targets (TS, Python), allocator blocks are ignored.

cura arena fit mem1 {
    // All allocations in this block use the arena
    varia textus[] items = ["hello", "world"]
    scribe items
}
// Arena freed, all allocations released

// =============================================================================
// ALLOCATOR SCOPES (page)
// =============================================================================

// Page allocators provide page-aligned memory.
// Useful for buffers and memory-mapped operations.

cura page fit mem2 {
    // Page-aligned allocations
    scribe "Using page allocator"
}

// =============================================================================
// NESTED ALLOCATORS
// =============================================================================

// Allocator scopes can nest. Inner scopes free before outer scopes.

cura arena fit outer {
    varia textus[] a = ["one"]

    cura arena fit inner {
        varia textus[] b = ["two"]
        scribe "Inner:", b
    }
    // inner freed here

    a.adde("three")
    scribe "Outer:", a
}
// outer freed here

// =============================================================================
// GENERIC RESOURCE (expression required)
// =============================================================================

// When no curator kind is specified, an expression is required.
// The resource must implement the Curator pactum (have a solve() method).

// NOTE: Generic cura with custom resources requires the Curator pactum,
// which is not yet fully implemented. These examples are commented out
// until the feature is complete.

// genus TempResource {
//     functio solve() {
//         scribe "Resource cleaned up"
//     }
// }
//
// functio createResource() -> TempResource {
//     scribe "Resource created"
//     redde TempResource {}
// }
//
// cura createResource() fit res {
//     scribe "Using resource"
// }
// res.solve() called automatically

// =============================================================================
// CURA WITH ERROR HANDLING
// =============================================================================

// Error handling with cura ensures cleanup runs even on failure.
// The cape clause catches errors but cleanup still executes.

// cura createResource() fit res {
//     riskyOperation()
// } cape err {
//     scribe "Error occurred:", err
// }
// res.solve() still called

// =============================================================================
// CURA IN INITIUM
// =============================================================================

// Common pattern: acquire allocator at program start

initium {
    cura arena fit alloc {
        // Main program logic using the allocator
        varia numerus[] numbers = []
        ex [1, 2, 3, 4, 5] pro n {
            numbers.adde(n * 2)
        }
        scribe numbers
    }
}

// =============================================================================
// ASYNC RESOURCES (fiet)
// =============================================================================

// Use fiet for resources that require async acquisition.
// The async result is bound to the identifier.

// functio connect(textus url) -> async Connection {
//     // async connection logic
// }

// cura connect("postgres://localhost/db") fiet conn {
//     fixum users = cede conn.query("SELECT * FROM users")
//     scribe users
// }
// conn.solve() called on exit

// =============================================================================
// CURATUM - ALLOCATOR PARAMETERS
// =============================================================================

// Functions can accept an allocator parameter with curatum.
// On GC targets, the parameter is stripped entirely.

// functio buildList(curatum mem, textus prefix) -> textus[] {
//     varia textus[] items = []
//     items.adde(prefix)
//     redde items
// }

// cura arena fit temp {
//     fixum list = buildList("item")           // uses temp
//     fixum other = buildList("x") curatum alt // uses alt
// }

// =============================================================================
// PLANNED CURATOR KINDS
// =============================================================================

// These are designed but not yet implemented:

// File handles (liber)
// cura liber aperi("data.txt") fit fd {
//     fixum data = lege(fd)
//     process(data)
// }

// Database transactions (transactio)
// cura transactio conn.begin() fiet tx {
//     tx.execute("INSERT INTO users (name) VALUES (?)", name)
// }
// commit on success, rollback on error

// Locks (mutex)
// cura mutex lock.acquire() fit guard {
//     shared_counter += 1
// }
// lock released automatically

// Connections (conexio)
// cura conexio db.connect(url) fiet conn {
//     fixum result = cede conn.query(sql)
// }
// connection closed automatically
