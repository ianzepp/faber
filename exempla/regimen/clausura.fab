// =============================================================================
// REGIMEN - Clausura (Closures/Lambdas)
// =============================================================================
//
// Clausura: Latin for "closure" (from claudere, to close)
//
// GRAMMAR:
// pro <params>: <expr>                  // expression lambda (shorthand)
// pro <params> redde <expr>             // expression lambda (explicit)
// pro <params> { <body> }               // block lambda
// pro { <body> }                        // zero-param lambda
//
// ETYMOLOGY:
// pro: "for" - same keyword as iteration (ex items pro x { })
// redde: "return" (give back)
// :    "is defined as" - shorthand, mirrors object literal syntax { x: 42 }
//
// WHY "pro...:" for lambdas:
// Aligns with iteration: "ex items pro x { }" and "pro x { }" both use pro
// The colon acts as "defined as", matching object literals (x: value)
// redde remains available for emphasis or teaching
//
// SEE ALSO: errores.fab for fac/cape block scope and error handling

// =============================================================================
// STUBS for examples (would be defined elsewhere in real code)
// =============================================================================
functio handleClick(e) {}
functio process(data) { redde data }
functio display(result) {}
functio logError(e) {}
functio fetchData() { }
functio cleanup() {}
varia button = nihil
varia conn = nihil
varia users = []
varia items = []

// =============================================================================
// PART 1: EXPRESSION LAMBDAS (pro x: expr)
// =============================================================================

// Single parameter - expression lambda with : shorthand
fixum double = pro x: x * 2
scribe double(5)  // 10

// Multiple parameters
fixum add = pro a, b: a + b
scribe add(3, 4)  // 7

// Zero parameters - expression form
fixum getAnswer = pro: 42
scribe getAnswer()  // 42

// Explicit redde form (equivalent, more verbose)
fixum tripleExplicit = pro x redde x * 3

// =============================================================================
// PART 2: BLOCK LAMBDAS (pro x { })
// =============================================================================

// Block lambda with single parameter
fixum processUser = pro user {
    si user.aetas < 18 {
        redde falsum
    }
    redde user.activus
}

// Block lambda with multiple parameters
fixum compare = pro a, b {
    si a > b { redde 1 }
    si a < b { redde -1 }
    redde 0
}

// Zero-param block lambda
fixum greet = pro {
    scribe "Hello!"
}

// =============================================================================
// PART 3: LAMBDAS WITH COLLECTIONS
// =============================================================================

fixum numbers = [1, 2, 3, 4, 5]

// Expression lambdas - clean for simple transforms
fixum evens = numbers.filtrata(pro n: n % 2 == 0)
fixum doubled = numbers.mappata(pro n: n * 2)
fixum sum = numbers.reducta(pro acc, n: acc + n, 0)

// Block lambdas - for complex logic
fixum processed = numbers.filtrata(pro n {
    si n < 0 { redde falsum }
    si n > 100 { redde falsum }
    redde n % 2 == 0
})

// -----------------------------------------------------------------------------
// Nested Lambdas (Currying)
// -----------------------------------------------------------------------------

// Curried add function - : shorthand shines here
fixum curriedAdd = pro x: pro y: x + y
fixum addFive = curriedAdd(5)
scribe addFive(3)  // 8

// =============================================================================
// PART 4: EVENT HANDLERS AND CALLBACKS
// =============================================================================

// Zero-param callbacks - block form is cleaner
button.addEventListener("click", pro {
    scribe "Button clicked!"
})

// With event parameter
button.addEventListener("click", pro e {
    handleClick(e)
})

// Promise chains - : shorthand for one-liners
fetchData()
    .then(pro data: process(data))
    .then(pro result: display(result))
    .catch(pro error: logError(error))

// Promise with block for complex handling
fetchData()
    .then(pro data {
        si data.error {
            iace data.error
        }
        redde process(data)
    })
    .catch(pro error {
        logError(error)
        redde nihil
    })

// =============================================================================
// PART 5: COMPARISON OF LAMBDA SYNTAXES
// =============================================================================

// All three syntaxes are valid and compile to the same JavaScript:

// Colon shorthand (preferred for expression lambdas)
fixum colonDouble = pro x: x * 2

// Explicit redde (more verbose, good for teaching)
fixum reddeDouble = pro x redde x * 2

// Arrow function syntax (JS-familiar)
fixum arrowDouble = (x) => x * 2

// Block lambdas - use pro with block body
fixum proComplex = pro x {
    si x < 0 { redde -x }
    redde x
}

// When to use which:
// - pro x: expr       Preferred for expression lambdas
// - pro x redde expr  For emphasis or teaching
// - pro x { }         Block lambdas with multiple statements
// - pro { }           Zero-param callbacks
// - (x) => expr       JS-familiar alternative
// See errores.fab for fac/cape error handling

// =============================================================================
// PART 6: IDIOMATIC USAGE
// =============================================================================

// Filtering - : shorthand is clean
users.filtrata(pro u: u.active)

// Mapping - : shorthand is clean
items.mappata(pro i: i.price * 1.1)

// Complex filtering - block lambda for clarity
users.filtrata(pro user {
    si user.aetas < 18 { redde falsum }
    si non user.verified { redde falsum }
    redde user.active
})

// Event handlers - zero-param block lambda
button.onClick(pro { scribe "clicked" })
conn.onClose(pro { cleanup() })
conn.onError(pro err { logError(err) })

// Higher-order functions returning lambdas - : shines here
fixum multiplier = pro factor: pro x: x * factor
fixum timesTwo = multiplier(2)
fixum timesThree = multiplier(3)
