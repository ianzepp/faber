# Operatores - Operator codegen tests
# Covers: binary, logical, bitwise, compound assignment, ternary

# =============================================================================
# Binary Operators
# =============================================================================

# Basic arithmetic - parentheses added for precedence clarity
- name: 'addition'
  input: '1 + 2'
  ts: '(1 + 2);'
  py: '(1 + 2)'
  cpp:
      - '(1 + 2)'
  rs: '(1 + 2);'
  zig:
      - '(1 + 2)'

# Function calls pass through unchanged
- name: 'function call'
  input: 'salve(nomen)'
  ts: 'salve(nomen);'
  py: 'salve(nomen)'
  cpp:
      - 'salve(nomen);'
  rs: 'salve(nomen);'
  zig:
      - 'salve(nomen)'

# Method calls on objects
- name: 'method call'
  input: 'lista.filter(f)'
  ts: 'lista.filter(f);'
  py: 'lista.filter(f)'
  cpp:
      - 'lista.filter(f);'
  rs: 'lista.filter(f);'

# Property access via dot notation
- name: 'member access'
  input: 'usuario.nomen'
  ts: 'usuario.nomen;'
  py: 'usuario.nomen'
  cpp:
      - 'usuario.nomen;'
  rs: 'usuario.nomen;'
  zig:
      - 'usuario.nomen'

# =============================================================================
# Logical Operators
# =============================================================================

# et is logical AND (&& in TS, 'and' in Python)
- name: 'et becomes and'
  input: 'a et b'
  ts: '(a && b);'
  py: '(a and b)'
  cpp:
      - '(a && b)'
  rs: '(a && b);'
  zig:
      - '(a and b)'

# aut is logical OR (|| in TS, 'or' in Python)
- name: 'aut becomes or'
  input: 'a aut b'
  ts: '(a || b);'
  py: '(a or b)'
  cpp:
      - '(a || b)'
  rs: '(a || b);'
  zig:
      - '(a or b)'

# vel is nullish coalescing (?? in TS, conditional in Python)
- name: 'vel becomes nullish coalescing'
  input: 'a vel b'
  ts: '(a ?? b);'
  py:
      - 'a if a is not None else b'
  cpp:
      - '(a != nullptr ? a : b);'
  rs: '(a ?? b);'

# vel chains left-to-right
- name: 'vel chains correctly'
  input: 'a vel b vel c'
  ts: '((a ?? b) ?? c);'
  py:
      - 'if'
      - 'is not None'
  cpp:
      - '((a != nullptr ? a : b) != nullptr ? (a != nullptr ? a : b) : c);'
  rs: '((a ?? b) ?? c);'

# =============================================================================
# Bitwise Operators
# =============================================================================

# Bitwise AND - same in both targets
- name: 'bitwise AND'
  input: '5 & 3'
  ts: '(5 & 3);'
  py: '(5 & 3)'
  cpp:
      - '(5 & 3);'
  rs: '(5 & 3);'
  zig:
      - '(5 & 3)'

# Bitwise OR - same in both targets
- name: 'bitwise OR'
  input: '5 | 3'
  ts: '(5 | 3);'
  py: '(5 | 3)'
  cpp:
      - '(5 | 3);'
  rs: '(5 | 3);'
  zig:
      - '(5 | 3)'

# Bitwise XOR - same in both targets
- name: 'bitwise XOR'
  input: '5 ^ 3'
  ts: '(5 ^ 3);'
  py: '(5 ^ 3)'
  cpp:
      - '(5 ^ 3);'
  rs: '(5 ^ 3);'
  zig:
      - '(5 ^ 3)'

# Bitwise NOT - same in both targets
- name: 'bitwise NOT'
  input: '~5'
  ts: '~5;'
  py: '~5'
  cpp:
      - '~5;'
  rs: '~5;'
  zig:
      - '~5'

# Left shift - same in both targets
- name: 'left shift'
  input: '1 << 4'
  ts: '(1 << 4);'
  py: '(1 << 4)'
  cpp:
      - '(1 << 4);'
  rs: '(1 << 4);'
  zig:
      - '(1 << 4)'

# Right shift - same in both targets
- name: 'right shift'
  input: '16 >> 2'
  ts: '(16 >> 2);'
  py: '(16 >> 2)'
  cpp:
      - '(16 >> 2);'
  rs: '(16 >> 2);'
  zig:
      - '(16 >> 2)'

# =============================================================================
# Compound Assignment
# =============================================================================

# += operator - same in both targets
- name: 'compound add'
  input: |
      varia x = 0
      x += 1
  ts:
      - 'x += 1'
  py:
      - 'x += 1'
  cpp:
      - 'auto x = 0;'
      - 'x += 1;'
  rs:
      - 'let mut x = 0;'
      - 'x += 1;'
  zig:
      - 'var x: i64 = 0;'
      - 'x += 1;'

# -= operator - same in both targets
- name: 'compound subtract'
  input: |
      varia x = 10
      x -= 1
  ts:
      - 'x -= 1'
  py:
      - 'x -= 1'
  cpp:
      - 'auto x = 10;'
      - 'x -= 1;'
  rs:
      - 'let mut x = 10;'
      - 'x -= 1;'
  zig:
      - 'var x: i64 = 10;'
      - 'x -= 1;'

# &= bitwise AND assignment
- name: 'compound bitwise AND'
  input: |
      varia flags = 0xFF
      flags &= 0x0F
  ts:
      - 'flags &= 0x0F'
  py:
      - 'flags &= 0x0F'
  cpp:
      - 'auto flags = 255;'
      - 'flags &= 15;'
  rs:
      - 'let mut flags = 0xFF;'
      - 'flags &= 0x0F;'
  zig:
      - 'var flags: i64 = 0xFF;'
      - 'flags &= 0x0F;'

# |= bitwise OR assignment
- name: 'compound bitwise OR'
  input: |
      varia flags = 0
      flags |= 0x01
  ts:
      - 'flags |= 0x01'
  py:
      - 'flags |= 0x01'
  cpp:
      - 'auto flags = 0;'
      - 'flags |= 1;'
  rs:
      - 'let mut flags = 0;'
      - 'flags |= 0x01;'
  zig:
      - 'var flags: i64 = 0;'
      - 'flags |= 0x01;'

# =============================================================================
# Ternary Operator
# =============================================================================

# condition ? then : else syntax
- name: 'ternary with symbols'
  input: 'verum ? 1 : 0'
  ts: 'true ? 1 : 0;'
  py: '1 if True else 0'
  cpp:
      - '(true ? 1 : 0)'
  rs:
      - 'if true { 1 } else { 0 }'
  zig:
      - '_ = if (true) 1 else 0;'

# Latin sic/secus syntax for ternary
- name: 'ternary with sic secus'
  input: 'verum sic 1 secus 0'
  ts: 'true ? 1 : 0;'
  py: '1 if True else 0'
  cpp:
      - '(true ? 1 : 0);'
  rs:
      - 'if true { 1 } else { 0 }'
  zig:
      - '_ = if (true) 1 else 0;'

# Ternary in variable initialization
- name: 'ternary in variable'
  input: 'varia x = verum ? 1 : 0'
  ts: 'let x = true ? 1 : 0;'
  py: 'x = 1 if True else 0'
  cpp:
      - 'auto x = (true ? 1 : 0);'
  rs:
      - 'let mut x = if true { 1 } else { 0 };'
  zig:
      - 'var x: i64 = if (true) 1 else 0;'

# =============================================================================
# Comparison Operators
# =============================================================================

# Equality - same in both targets
- name: 'equality'
  input: 'a == b'
  ts: '(a == b);'
  py: '(a == b)'
  cpp:
      - '(a == b)'
  rs: '(a == b);'

# Inequality - same in both targets
- name: 'inequality'
  input: 'a != b'
  ts: '(a != b);'
  py: '(a != b)'
  cpp:
      - '(a != b)'
  rs: '(a != b);'

# Less than - same in both targets
- name: 'less than'
  input: 'a < b'
  ts: '(a < b);'
  py: '(a < b)'
  cpp:
      - '(a < b);'
  rs: '(a < b);'

# Greater than - same in both targets
- name: 'greater than'
  input: 'a > b'
  ts: '(a > b);'
  py: '(a > b)'
  cpp:
      - '(a > b);'
  rs: '(a > b);'

# =============================================================================
# Spread Operator (sparge)
# =============================================================================

# sparge unpacks arrays (... in TS, * in Python)
- name: 'spread in array'
  input: 'fixum combined = [sparge a, sparge b]'
  ts: 'const combined = [...a, ...b];'
  py: 'combined = [*a, *b]'
  cpp:
      - 'const auto combined = std::vector{};'
  rs:
      - 'let combined = vec!'
      - 'spread'

# sparge in function calls
- name: 'spread in function call'
  input: 'fn(sparge args)'
  ts: 'fn(...args);'
  py: 'fn(*args)'
  cpp:
      - 'fn();'
  rs:
      - 'fn('
      - 'spread'

# sparge unpacks objects (... in TS, ** in Python)
- name: 'spread in object'
  input: 'fixum merged = { sparge defaults, x: 1 }'
  ts: 'const merged = { ...defaults, x: 1 };'
  py: 'merged = {**defaults, "x": 1}'
  cpp:
      - 'const auto merged = {.x = 1};'
  rs:
      - 'let merged = {'
      - '..defaults'

# =============================================================================
# Rest Operator (ceteri)
# =============================================================================

# ceteri collects remaining elements in array destructuring
- name: 'rest in array destructuring'
  input: 'fixum [first, ceteri rest] = items'
  ts: 'const [first, ...rest] = items;'
  py: 'first, *rest = items'
  cpp:
      - 'const auto& _tmp = items;'
      - 'const auto& first = _tmp[0];'
      - 'const auto rest = std::vector<decltype(_tmp)::value_type>(_tmp.begin() + 1, _tmp.end());'
  rs:
      - 'let [first, rest@..] = items;'
  zig:
      - 'const _tmp = items'
      - 'const first = _tmp[0]'
      - 'const rest = _tmp[1..]'

# ceteri as function parameter collects variadic args
- name: 'rest in function params'
  input: 'functio sum(ceteri numerus[] nums) { redde 0 }'
  ts:
      - '...nums: Array<number>'
  py:
      - '*nums: list[int]'
  cpp:
      - 'void sum(const std::vector<int64_t>& nums) {'
      - 'return 0;'
  rs:
      - 'fn sum(nums: Vec<f64>)'
      - 'return 0;'

# =============================================================================
# Optional Chaining
# =============================================================================

# ?. safely accesses properties (conditional in Python)
- name: 'optional property access'
  input: 'user?.name'
  ts: 'user?.name;'
  py:
      - 'user.name if user is not None else None'
  cpp:
      - '(user ? user->name : std::nullopt);'
  rs:
      - 'user.as_ref().map'
      - '.name'

# ?[ safely accesses array elements
- name: 'optional computed access'
  input: 'arr?[0]'
  ts: 'arr?.[0];'
  py:
      - 'arr[0] if arr is not None else None'
  cpp:
      - '(arr ? (*arr)[0] : std::nullopt);'
  rs: 'arr.get(0);'

# ?( safely calls functions
- name: 'optional call'
  input: 'callback?()'
  ts: 'callback?.();'
  py:
      - 'callback() if callback is not None else None'
  cpp:
      - '(callback ? (*callback)() : std::nullopt);'
  rs:
      - 'callback.map'
      - 'f()'

# =============================================================================
# Non-null Assertion
# =============================================================================

# !. asserts non-null then accesses (Python ignores assertion)
- name: 'non-null property access'
  input: 'user!.name'
  ts: 'user!.name;'
  py: 'user.name'
  cpp:
      - 'user->name;'
  rs: 'user.name;'

# ![ asserts non-null then indexes
- name: 'non-null computed access'
  input: 'arr![0]'
  ts: 'arr![0];'
  py: 'arr[0]'
  cpp:
      - '(*arr)[0];'
  rs: 'arr[0];'

# =============================================================================
# Computed Member Access
# =============================================================================

# Dynamic property access via brackets
- name: 'computed access with variable'
  input: 'obj[key]'
  ts: 'obj[key];'
  py: 'obj[key]'
  cpp:
      - 'obj[key];'
  rs: 'obj[key];'

# Literal index access
- name: 'computed access with literal'
  input: 'arr[0]'
  ts: 'arr[0];'
  py: 'arr[0]'
  cpp:
      - 'arr[0];'
  rs: 'arr[0];'

# =============================================================================
# Negative Indexing
# =============================================================================

# Negative indices use .at() in TS, native in Python
- name: 'negative index uses at'
  input: 'fixum x = nums[-1]'
  ts: 'const x = nums.at(-1);'
  py: 'x = nums[-1]'
  cpp:
      - 'const auto x = nums[nums.size() - 1];'
  rs: 'let x = nums[-1];'
  zig:
      - 'nums[nums.len - 1]'

# =============================================================================
# Slicing
# =============================================================================

# Exclusive range slicing (.. operator)
- name: 'slice with exclusive range'
  input: 'fixum x = nums[1..3]'
  ts: 'const x = nums.slice(1, 3);'
  py: 'x = nums[1:3]'
  cpp:
      - 'const auto x = std::vector<typename decltype(nums)::value_type>(nums.begin() + 1, nums.begin() + 3);'
  rs:
      - 'let x = nums[(1..3)];'
  zig:
      - 'nums[1..3]'

# Inclusive range slicing (usque operator) - end+1 for both targets
- name: 'slice with inclusive range'
  input: 'fixum x = nums[0 usque 2]'
  ts: 'const x = nums.slice(0, 3);'
  py: 'x = nums[0:3]'
  cpp:
      - 'const auto x = std::vector<typename decltype(nums)::value_type>(nums.begin() + 0, nums.begin() + 3);'
  rs:
      - 'let x = nums[(0..=2)];'
  zig:
      - 'nums[0..3]'

# =============================================================================
# Type Cast (qua)
# =============================================================================

# qua casts expression to type (as in TS, ignored in Python)
- name: 'simple type cast'
  input: 'fixum name = data qua textus'
  ts: 'const name = (data as string);'
  py: 'name = data'
  rs: 'let name = data as String;'

# Cast member expression
- name: 'cast member expression'
  input: 'fixum body = response.body qua objectum'
  ts: 'const body = (response.body as object);'
  py: 'body = response.body'
  rs: 'let body = response.body as objectum;'

# =============================================================================
# Type Check (est)
# =============================================================================

# est with primitive uses typeof in TS, isinstance in Python
- name: 'est with primitive typeof'
  input: 'fixum check = x est textus'
  ts:
      - 'typeof x === "string"'
  py:
      - 'isinstance(x, str)'
  rs:
      - 'let check = matches!(x, textus);'

# non est negates the check
- name: 'non est negated'
  input: 'fixum check = x non est numerus'
  ts:
      - 'typeof x !== "number"'
  py:
      - 'not isinstance(x, int)'
  rs:
      - 'let check = !matches!(x, numerus);'

# est with user type uses instanceof
- name: 'est with user type instanceof'
  input: 'fixum check = obj est Persona'
  ts:
      - 'instanceof Persona'
  py:
      - 'isinstance(obj, Persona)'
  rs:
      - 'let check = matches!(obj, Persona);'

# =============================================================================
# Null Check Operators
# =============================================================================

# nihil unary checks if value is null
- name: 'nihil unary'
  input: 'si nihil x { scribe "null" }'
  ts:
      - '(x === null)'
  py:
      - '(x is None)'
  cpp:
      - 'if (nihilx) {'
      - 'std::print("{}\n", std::string("null"));'
  rs:
      - 'if x.is_none()'
      - 'println!'
  zig:
      - '(x == null)'

# nonnihil unary checks if value is not null
- name: 'nonnihil unary'
  input: 'si nonnihil x { scribe "not null" }'
  ts:
      - '(x !== null)'
  py:
      - '(x is not None)'
  cpp:
      - 'if (nonnihilx) {'
      - 'std::print("{}\n", std::string("not null"));'
  rs:
      - 'if x.is_some()'
      - 'println!'
  zig:
      - '(x != null)'
