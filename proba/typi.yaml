# Typi - Type system codegen tests
# Covers: type aliases, ordo (enum), union types, nullable, numeric types

# =============================================================================
# Type Aliases
# =============================================================================

# typus creates a type alias
- name: 'simple type alias'
  input: 'typus ID = textus'
  ts: 'type ID = string;'
  py: 'ID = str'
  zig:
      - 'const ID = []const u8'
  cpp:
      - 'using ID = std::string;'
  rs: 'type ID = String;'

# Generic type aliases preserve type parameters
- name: 'generic type alias'
  input: 'typus StringList = textus[]'
  ts: 'type StringList = Array<string>;'
  py: 'StringList = list[str]'
  zig:
      - 'const StringList = [][]const u8;'
  cpp:
      - 'using StringList = std::vector<std::string>;'
  rs: 'type StringList = Vec<String>;'

# typeof captures the type of a value (TS only - Python uses Any)
- name: 'typeof type alias'
  input: |
      fixum config = { debug: verum }
      typus ConfigTypus = typus config
  ts:
      - 'type ConfigTypus = typeof config;'
  py:
      - 'config = {"debug": True}'
      - 'ConfigTypus = Any'
  zig:
      - 'const config = .{ .debug = true };'
      - 'const ConfigTypus = anytype;'
  cpp:
      - 'using ConfigTypus = ignotum;'
      - 'const auto config = {.debug = true};'
  rs:
      - 'let config = { debug: true };'
      - 'type ConfigTypus = ignotum;'

# Numeric type parameters are ignored in TS (no fixed-width integers)
- name: 'type with numeric parameter ignored'
  input: 'typus SmallNum = numerus<32>'
  ts: 'type SmallNum = number;'
  py: 'SmallNum = int'
  zig:
      - 'const SmallNum = numerus;'
  cpp:
      - 'using SmallNum = int64_t<32>;'
  rs: 'type SmallNum = f64<32>;'

# Size type parameters (i32, u64) preserved but ignored in TS
- name: 'type with size type parameter'
  input: 'typus Int32 = numerus<i32>'
  ts: 'type Int32 = number<i32>;'
  py: 'Int32 = int[i32]'
  zig:
      - 'const Int32 = numerus;'
  cpp:
      - 'using Int32 = int64_t<i32>;'
  rs: 'type Int32 = f64<i32>;'

# =============================================================================
# Primitive Type Mappings
# =============================================================================

# fractus is floating point (number in TS, float in Python)
- name: 'fractus maps to number'
  input: 'typus Ratio = fractus'
  ts: 'type Ratio = number;'
  py: 'Ratio = float'
  zig:
      - 'const Ratio = f64;'
  cpp:
      - 'using Ratio = double;'
  rs: 'type Ratio = f64;'

# decimus is arbitrary precision decimal (requires import)
- name: 'decimus maps to Decimal'
  input: 'typus Price = decimus'
  ts:
      - "import type Decimal from 'decimal.js';"
      - 'type Price = Decimal;'
  py:
      - 'from decimal import Decimal'
      - 'Price = Decimal'
  zig:
      - 'const Price = f128;'
  cpp:
      - 'using Price = double;'
  rs: 'type Price = decimus;'

# octeti is byte array
- name: 'octeti maps to Uint8Array'
  input: 'typus Buffer = octeti'
  ts: 'type Buffer = Uint8Array;'
  py: 'Buffer = bytes'
  zig:
      - 'const Buffer = []u8;'
  cpp:
      - 'using Buffer = std::vector<uint8_t>;'
  rs: 'type Buffer = Vec<u8>;'

# magnus is arbitrary precision integer (bigint in TS, int in Python)
- name: 'magnus maps to bigint'
  input: 'typus BigNum = magnus'
  ts: 'type BigNum = bigint;'
  py: 'BigNum = int'
  zig:
      - 'const BigNum = i128;'
  cpp:
      - 'using BigNum = magnus;'
  rs: 'type BigNum = i128;'

# magnus variable with bigint literal
- name: 'magnus variable with literal'
  input: 'fixum magnus huge = 99999999999999999999n'
  ts: 'const huge: bigint = 99999999999999999999n;'
  py: 'huge: int = 99999999999999999999'
  zig:
      - 'const m_huge: i128 = 99999999999999999999;'
  cpp:
      - 'const magnus huge = 99999999999999999999;'
  rs:
      - 'let huge: i128 = 99999999999999999999ni128;'

# numquam is the never type (function never returns)
- name: 'numquam maps to never'
  input: 'functio moritur() -> numquam { iace novum Erratum("fatal") }'
  ts:
      - 'function moritur(): never'
  py:
      - 'def moritur() -> NoReturn:'
  zig:
      - 'fn moritur() !noreturn {'
      - 'return error.Error;'
  cpp:
      - 'numquam moritur() {'
      - 'throw Erratum(std::string("fatal"));'
  rs:
      - 'fn moritur() -> numquam {'
      - 'return Err(Erratum::new());'

# ignotum is the unknown type
- name: 'ignotum maps to unknown'
  input: 'typus Mystery = ignotum'
  ts: 'type Mystery = unknown;'
  py: 'Mystery = Any'
  zig:
      - 'const Mystery = anytype;'
  cpp:
      - 'using Mystery = ignotum;'
  rs: 'type Mystery = ignotum;'

# ignotum variable accepts any value
- name: 'ignotum variable'
  input: 'varia ignotum x = 42'
  ts: 'let x: unknown = 42;'
  py: 'x: Any = 42'
  zig:
      - 'var x: anytype = 42;'
  cpp:
      - 'ignotum x = 42;'
  rs:
      - 'let mut x: ignotum = 42;'

# =============================================================================
# Union Types
# =============================================================================

# unio<A, B> creates union type
- name: 'union type with two members'
  input: 'fixum unio<textus, numerus> value = "hello"'
  ts: 'const value: string | number = "hello";'
  py: 'value: str | int = "hello"'
  zig:
      - 'anytype'
  cpp:
      - 'const union value = std::string("hello");'
  rs:
      - 'let value: union = String::from("hello");'

# unio can have multiple members
- name: 'union type with three members'
  input: 'fixum unio<textus, numerus, nihil> value = nihil'
  ts: 'const value: string | number | null = null;'
  py: 'value: str | int | None = None'
  cpp:
      - 'const union value = nullptr;'
  rs:
      - 'let value: union = None;'

# Type alias with union type
- name: 'type alias with union'
  input: 'typus Json = unio<textus, numerus, bivalens, nihil>'
  ts: 'type Json = string | number | boolean | null;'
  py: 'Json = str | int | bool | None'
  zig:
      - 'const Json = anytype'
  cpp:
      - 'using Json = union;'
  rs: 'type Json = union;'

# =============================================================================
# Nullable Types
# =============================================================================

# ? suffix makes type nullable (| null in TS, | None in Python)
- name: 'nullable type'
  input: 'fixum textus? name = nihil'
  ts:
      - 'string | null'
  py:
      - 'str | None'
  zig:
      - 'const m_name: ?[]const u8 = null;'
  cpp:
      - 'const std::optional<std::string> name = nullptr;'
  rs:
      - 'let name: Option<String> = None;'

# =============================================================================
# Enums (ordo)
# =============================================================================

# ordo declares an enum - TS uses native enum, Python uses Enum class
- name: 'simple enum'
  input: 'ordo color { rubrum, viridis, caeruleum }'
  ts: 'enum color { rubrum, viridis, caeruleum }'
  py:
      - 'class color(Enum):'
      - 'rubrum = auto()'
      - 'viridis = auto()'
  rs:
      - 'enum color {'
      - 'rubrum,'
      - 'viridis,'
      - 'caeruleum,'

# Enum with explicit numeric values
- name: 'enum with numeric values'
  input: 'ordo status { pendens = 0, actum = 1, finitum = 2 }'
  ts: 'enum status { pendens = 0, actum = 1, finitum = 2 }'
  py:
      - 'class status(Enum):'
      - 'pendens = 0'
      - 'actum = 1'
  rs:
      - 'enum status {'
      - 'pendens = 0,'
      - 'actum = 1,'
      - 'finitum = 2,'

# Enum with string values
- name: 'enum with string values'
  input: 'ordo direction { north = "N", south = "S" }'
  ts: 'enum direction { north = "N", south = "S" }'
  py:
      - 'class direction(Enum):'
      - 'north = "N"'
      - 'south = "S"'
  rs:
      - 'enum direction {'
      - 'north = "N",'
      - 'south = "S",'

# Enum with mixed auto and explicit values
- name: 'enum with mixed values'
  input: 'ordo mixed { a, b = 5, c }'
  ts: 'enum mixed { a, b = 5, c }'
  py:
      - 'class mixed(Enum):'
      - 'a = auto()'
      - 'b = 5'
      - 'c = auto()'
  rs:
      - 'enum mixed {'
      - 'a,'
      - 'b = 5,'
      - 'c,'

# Accessing enum members via dot notation
- name: 'enum member access'
  input: |
      ordo color { rubrum, viridis }
      scribe color.rubrum
  ts:
      - 'enum color { rubrum, viridis }'
      - 'console.log(color.rubrum)'
  py:
      - 'class color(Enum):'
      - 'print(color.rubrum)'
  rs:
      - 'enum color {'
      - 'println!'

# =============================================================================
# Type Checks (est)
# =============================================================================

# est with primitive uses typeof in TS, isinstance in Python
- name: 'est with primitive'
  input: 'fixum check = x est textus'
  ts:
      - 'typeof x === "string"'
  py:
      - 'isinstance(x, str)'
  rs:
      - 'matches!(x, textus)'

# non est negates the type check
- name: 'non est with primitive'
  input: 'fixum check = x non est numerus'
  ts:
      - 'typeof x !== "number"'
  py:
      - 'not isinstance(x, int)'
  rs:
      - '!matches!(x, numerus)'

# est with user type uses instanceof in both targets
- name: 'est with user type'
  input: 'fixum check = obj est Persona'
  ts:
      - 'instanceof Persona'
  py:
      - 'isinstance(obj, Persona)'
  rs:
      - 'matches!(obj, Persona)'
