# Tempta statement - Try/catch/finally error handling
# Maps Faber tempta/cape/demum to target-specific error handling
#
# Syntax:
#   tempta { tryBlock }
#   cape error { catchBlock }
#   demum { finallyBlock }
#
# Target behaviors:
#   - TypeScript: try/catch/finally
#   - Python: try/except/finally
#   - Rust: Comment only (uses Result<T, E> instead)
#   - C++: try/catch with RAII scope guard for finally
#   - Zig: Comment only (uses catch |err| on expressions)

# =============================================================================
# Tempta with Cape (Try/Catch)
# =============================================================================

# Basic try/catch
- name: tempta with cape
  faber: |
    tempta {
      riskyOperation()
    }
    cape err {
      handleError(err)
    }
  expect:
    ts:
      - "try {"
      - "riskyOperation();"
      - "} catch (err) {"
      - "handleError(err);"
    py:
      - "try:"
      - "riskyOperation()"
      - "except Exception as err:"
      - "handleError(err)"
    rs:
      - "// tempta (try) - Rust uses Result<T, E> instead"
      - "{"
      - "riskyOperation();"
    cpp:
      - "try {"
      - "riskyOperation();"
      - "catch (const std::exception& err) {"
      - "handleError(err);"
    zig:
      - "// try block"
      - "riskyOperation();"
      - "// catch handling would use: catch |err|"

# Multiple statements in try block
- name: tempta with multiple statements
  faber: |
    tempta {
      varia x = compute()
      process(x)
      redde x
    }
    cape e {
      redde nihil
    }
  expect:
    ts:
      - "try {"
      - "let x = compute();"
      - "process(x);"
      - "return x;"
      - "} catch (e) {"
      - "return null;"
    py:
      - "try:"
      - "x = compute()"
      - "process(x)"
      - "return x"
      - "except Exception as e:"
      - "return None"
    rs:
      - "// tempta (try) - Rust uses Result<T, E> instead"
      - "let mut x = compute();"
      - "process(x);"
      - "return x;"
    cpp:
      - "try {"
      - "auto x = compute();"
      - "process(x);"
      - "return x;"
      - "catch (const std::exception& e) {"
      - "return nullptr;"
    zig:
      - "// try block"
      - "var x: anytype = compute();"
      - "process(x);"
      - "return x;"

# =============================================================================
# Tempta with Demum (Try/Finally)
# =============================================================================

# Try with finally only
- name: tempta with demum only
  faber: |
    tempta {
      openResource()
    }
    demum {
      cleanup()
    }
  expect:
    ts:
      - "try {"
      - "openResource();"
      - "} finally {"
      - "cleanup();"
    py:
      - "try:"
      - "openResource()"
      - "finally:"
      - "cleanup()"
    rs:
      - "// tempta (try) - Rust uses Result<T, E> instead"
      - "{"
      - "openResource();"
    cpp:
      - "auto _demum_0 = _ScopeGuard"
      - "cleanup()"
      - "try {"
      - "openResource();"
    zig:
      - "// try block"
      - "openResource();"

# =============================================================================
# Tempta with Cape and Demum (Try/Catch/Finally)
# =============================================================================

# Full try/catch/finally
- name: tempta with cape and demum
  faber: |
    tempta {
      riskyCall()
    }
    cape err {
      mone "Error:", err
    }
    demum {
      cleanup()
    }
  expect:
    ts:
      - "try {"
      - "riskyCall();"
      - "} catch (err) {"
      - 'console.warn("Error:", err);'
      - "} finally {"
      - "cleanup();"
    py:
      - "try:"
      - "riskyCall()"
      - "except Exception as err:"
      - 'print("[WARN]", "Error:", err)'
      - "finally:"
      - "cleanup()"
    rs:
      - "// tempta (try) - Rust uses Result<T, E> instead"
      - "{"
      - "riskyCall();"
    cpp:
      - "auto _demum_0 = _ScopeGuard"
      - "cleanup()"
      - "try {"
      - "riskyCall();"
      - "catch (const std::exception& err) {"
    zig:
      - "// try block"
      - "riskyCall();"

# Multiple statements in all blocks
- name: tempta with multiple statements in all blocks
  faber: |
    tempta {
      varia fd = open()
      write(fd, data)
    }
    cape e {
      scribe "Failed"
      iace e
    }
    demum {
      close(fd)
    }
  expect:
    ts:
      - "try {"
      - "let fd = open();"
      - "write(fd, data);"
      - "} catch (e) {"
      - 'console.log("Failed");'
      - "throw e;"
      - "} finally {"
      - "close(fd);"
    py:
      - "try:"
      - "fd = open()"
      - "write(fd, data)"
      - "except Exception as e:"
      - 'print("Failed")'
      - "raise e"
      - "finally:"
      - "close(fd)"
    rs:
      - "// tempta (try) - Rust uses Result<T, E> instead"
      - "{"
      - "let mut fd = open();"
      - "write(fd, data);"
    cpp:
      - "auto _demum_0 = _ScopeGuard"
      - "close(fd)"
      - "try {"
      - "auto fd = open();"
      - "write(fd, data);"
      - "catch (const std::exception& e) {"
    zig:
      - "// try block"
      - "var fd: anytype = open();"
      - "write(fd, data);"

# =============================================================================
# Edge Cases
# =============================================================================

# Empty try block
- name: tempta with empty try block
  faber: |
    tempta { }
    cape e { handle(e) }
  expect:
    ts:
      - "try {}"
      - "} catch (e) {"
      - "handle(e);"
    py:
      - "try:"
      - "pass"
      - "except Exception as e:"
      - "handle(e)"
    rs:
      - "// tempta (try) - Rust uses Result<T, E> instead"
      - "{}"
    cpp:
      - "try {}"
      - "catch (const std::exception& e) {"
      - "handle(e);"
    zig:
      - "// try block"

# Empty catch block
- name: tempta with empty catch block
  faber: |
    tempta {
      mayFail()
    }
    cape e { }
  expect:
    ts:
      - "try {"
      - "mayFail();"
      - "} catch (e) {}"
    py:
      - "try:"
      - "mayFail()"
      - "except Exception as e:"
      - "pass"
    rs:
      - "// tempta (try) - Rust uses Result<T, E> instead"
      - "{"
      - "mayFail();"
    cpp:
      - "try {"
      - "mayFail();"
      - "catch (const std::exception& e) {}"
    zig:
      - "// try block"
      - "mayFail();"

# Nested try blocks
- name: nested tempta blocks
  faber: |
    tempta {
      tempta {
        innerRisky()
      }
      cape inner {
        handleInner(inner)
      }
    }
    cape outer {
      handleOuter(outer)
    }
  expect:
    ts:
      - "try {"
      - "try {"
      - "innerRisky();"
      - "} catch (inner) {"
      - "handleInner(inner);"
      - "} catch (outer) {"
      - "handleOuter(outer);"
    py:
      - "try:"
      - "try:"
      - "innerRisky()"
      - "except Exception as inner:"
      - "handleInner(inner)"
      - "except Exception as outer:"
      - "handleOuter(outer)"
    rs:
      - "// tempta (try) - Rust uses Result<T, E> instead"
      - "{"
      - "// tempta (try) - Rust uses Result<T, E> instead"
      - "{"
      - "innerRisky();"
    cpp:
      - "try {"
      - "try {"
      - "innerRisky();"
      - "catch (const std::exception& inner) {"
      - "handleInner(inner);"
      - "catch (const std::exception& outer) {"
      - "handleOuter(outer);"
    zig:
      - "// try block"
      - "// try block"
      - "innerRisky();"
