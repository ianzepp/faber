/// Error Handling Statement Parsers
///
/// Try-catch-finally and related error handling constructs.
///
/// GRAMMAR:
///   tryStmt := 'tempta' blockStmt ('cape' IDENTIFIER blockStmt)? ('demum' blockStmt)?
///   catchClause := 'cape' IDENTIFIER blockStmt
///   facBlockStmt := 'fac' blockStmt ('cape' IDENTIFIER blockStmt)?
///   assertStmt := 'adfirma' expression (',' expression)?
///
/// LATIN VOCABULARY:
/// - tempta = try/attempt
/// - cape = catch/seize
/// - demum = finally (at last)
/// - fac = do/make
/// - adfirma = affirm/assert

ex "../resolvitor" importa Resolvitor, Expressia, Sententia, MassaSententia
ex "../../ast/positio" importa Locus
ex "../../ast/lexema" importa SymbolumGenus
ex "../errores" importa ParserErrorCodice

/// Nomen - identifier AST node
genus Nomen {
    Locus locus
    textus valor
}

/// CapeClausula - catch clause AST node
genus CapeClausula {
    Locus locus
    Nomen nomen
    MassaSententia corpus
}

/// TemptaSententia - try-catch-finally AST node
genus TemptaSententia {
    Locus locus
    MassaSententia massa
    CapeClausula? tractator
    MassaSententia? finaliter
}

/// FacSententia - fac block AST node
genus FacSententia {
    Locus locus
    MassaSententia massa
    CapeClausula? tractator
}

/// AdfirmaSententia - assert AST node
genus AdfirmaSententia {
    Locus locus
    Expressia condicio
    Expressia? nuntius
}

/// Parse catch clause
///
/// GRAMMAR: catchClause := 'cape' IDENTIFIER blockStmt
///
/// Binds the caught error to the identifier.
functio parseCapeClausula(Resolvitor r) -> CapeClausula {
    fixum p = r.parser()
    fixum locus = p.specta(0).locus

    // Consume 'cape' keyword
    p.expectaVerbum("cape", ParserErrorCodice.ExpectaturCape)

    // Parse error binding identifier
    fixum nomenSymbolum = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
    fixum nomen = {
        locus: nomenSymbolum.locus,
        valor: nomenSymbolum.valor
    } qua Nomen

    // Parse the handler block
    fixum corpus = r.massa()

    redde {
        locus: locus,
        nomen: nomen,
        corpus: corpus
    } qua CapeClausula
}

/// Parse try-catch-finally statement
///
/// GRAMMAR: tryStmt := 'tempta' blockStmt ('cape' IDENTIFIER blockStmt)? ('demum' blockStmt)?
///
/// Both cape and demum are optional, but at least one should be present
/// for the statement to be useful.
functio parseTemptaSententia(Resolvitor r) -> TemptaSententia {
    fixum p = r.parser()
    fixum locus = p.specta(0).locus

    // Consume 'tempta' keyword
    p.expectaVerbum("tempta", ParserErrorCodice.ExpectaturTempta)

    // Parse the try block
    fixum massa = r.massa()

    // Parse optional catch clause
    varia tractator = nihil qua CapeClausula?

    si p.probaVerbum("cape") {
        tractator = parseCapeClausula(r)
    }

    // Parse optional finally block
    varia finaliter = nihil qua MassaSententia?

    si p.congruetVerbum("demum") {
        finaliter = r.massa()
    }

    redde {
        locus: locus,
        massa: massa,
        tractator: tractator,
        finaliter: finaliter
    } qua TemptaSententia
}

/// Parse fac block statement
///
/// GRAMMAR: facBlockStmt := 'fac' blockStmt ('cape' IDENTIFIER blockStmt)?
///
/// Creates explicit scope boundary with optional error handling.
/// Useful for:
/// - Scoped variable declarations
/// - Grouping operations with shared error handling
/// - IIFE-like constructs
functio parseFacSententia(Resolvitor r) -> FacSententia {
    fixum p = r.parser()
    fixum locus = p.specta(0).locus

    // Consume 'fac' keyword
    p.expectaVerbum("fac", ParserErrorCodice.ExpectaturFac)

    // Parse the block
    fixum massa = r.massa()

    // Parse optional catch clause
    varia tractator = nihil qua CapeClausula?

    si p.probaVerbum("cape") {
        tractator = parseCapeClausula(r)
    }

    redde {
        locus: locus,
        massa: massa,
        tractator: tractator
    } qua FacSententia
}

/// Parse assert statement
///
/// GRAMMAR: assertStmt := 'adfirma' expression (',' expression)?
///
/// Runtime invariant check. Optional second expression is error message.
functio parseAdfirmaSententia(Resolvitor r) -> AdfirmaSententia {
    fixum p = r.parser()
    fixum locus = p.specta(0).locus

    // Consume 'adfirma' keyword
    p.expectaVerbum("adfirma", ParserErrorCodice.ExpectaturAdfirma)

    // Parse the condition expression
    fixum condicio = r.expressia()

    // Parse optional message expression
    varia nuntius = nihil qua Expressia?

    si p.congruet(SymbolumGenus.Virgula) {
        nuntius = r.expressia()
    }

    redde {
        locus: locus,
        condicio: condicio,
        nuntius: nuntius
    } qua AdfirmaSententia
}
