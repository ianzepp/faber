/// Resolvitor - Parser Interface for Mutual Recursion
///
/// Solves mutual recursion between expression and statement parsers.
/// Each parsing function receives a Resolvitor instead of raw Parser,
/// and calls methods for cross-module parsing.
///
/// WHY: Expression parsers need to parse blocks (for lambdas), and
///      statement parsers need to parse expressions. This creates
///      circular imports. By using a pactum (interface), each module
///      depends only on Resolvitor, not on each other.
///
/// The concrete implementation (ResolvitorImpl) is defined in index.fab,
/// which imports all the actual parsing functions.
///
/// LATIN: resolvitor = "one who resolves/parses"

ex "./nucleus" importa Parser
ex "../ast/positio" importa Locus

// Forward declarations for AST types used in method signatures.
// These are minimal stubs - the real types live in ast/.

discretio Expressia {
    Vacua { }
}

discretio Sententia {
    Vacua { }
}

genus MassaSententia {
    Locus locus
    lista<Sententia> corpus
}

genus TypusAnnotatio {
    Locus locus
    textus nomen
}

/// Parser interface for cross-module parsing.
///
/// Usage in parsing functions:
///   functio parseFoo(Resolvitor r) -> Foo {
///       fixum expr = r.expressia()    // parse expression
///       fixum block = r.massa()       // parse block
///       ...
///   }
pactum Resolvitor {
    functio parser() -> Parser
    functio expressia() -> Expressia
    functio sententia() -> Sententia
    functio massa() -> MassaSententia
    functio adnotatio() -> TypusAnnotatio
}
