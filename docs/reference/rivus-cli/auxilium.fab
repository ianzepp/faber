# ═══════════════════════════════════════════════════════════════════════════════
# AUXILIUM - Shared CLI utilities
# ═══════════════════════════════════════════════════════════════════════════════
#
# Common helpers for rivus CLI commands: input handling, display names,
# path manipulation, and error formatting.
#
# ═══════════════════════════════════════════════════════════════════════════════

§ ex "../../norma/hal/solum" importa solum
§ ex "../../norma/hal/consolum" importa consolum

§ ex "../rivus/lexor/index" importa lexare
§ ex "../rivus/parser/index" importa resolvere
§ ex "../rivus/ast/radix" importa SectioAnnotatio

# ═══════════════════════════════════════════════════════════════════════════════
# INPUT HANDLING
# ═══════════════════════════════════════════════════════════════════════════════

# Read source from file or stdin
# If inputFile is nil or "-", reads from stdin
@ publica
@ futura
functio hauriSource(textus? inputFile) -> textus {
    si nihil inputFile aut inputFile == "-" {
        figendum result = cede consolum.hauriOmnia()
        redde result
    }
    figendum result = cede solum.lege(inputFile)
    redde result
}

# Human-readable name for error messages
# Returns "<stdin>" for nil or "-"
@ publica
functio nomenOstende(textus? inputFile) -> textus {
    si nihil inputFile aut inputFile == "-" {
        redde "<stdin>"
    }
    redde inputFile
}

# ═══════════════════════════════════════════════════════════════════════════════
# PATH UTILITIES
# ═══════════════════════════════════════════════════════════════════════════════

# Replace file extension (e.g., ".fab" -> ".ts")
@ publica
functio mutaExtensionem(textus via, textus novaExtensio) -> textus {
    fixum ultimusPunctum = via.lastIndexOf(".")
    si ultimusPunctum == -1 {
        redde scriptum("§§", via, novaExtensio)
    }
    redde scriptum("§§", via.slice(0, ultimusPunctum), novaExtensio)
}

# Compute relative path between two absolute paths
@ publica
functio viaRelativa(textus fons, textus destinatio) -> textus {
    fixum partes_fons = fons.split("/")
    fixum partes_dest = destinatio.split("/")

    # Find common prefix length
    varia numerus communis = 0
    dum communis < partes_fons.length et communis < partes_dest.length et partes_fons[communis] == partes_dest[communis] {
        communis = communis + 1
    }

    varia resultatum = [] innatum lista<textus>

    # Add ".." for each remaining segment in source path
    varia numerus i = 0
    dum i < partes_fons.length - communis {
        resultatum.push("..")
        i = i + 1
    }

    # Add remaining segments from target path
    varia numerus j = 0
    dum j < partes_dest.length - communis {
        resultatum.push(partes_dest[communis + j])
        j = j + 1
    }

    redde resultatum.join("/")
}

# ═══════════════════════════════════════════════════════════════════════════════
# VALIDATION
# ═══════════════════════════════════════════════════════════════════════════════

# Check if input is valid (nil/"-" = stdin = always valid, else check file exists)
@ publica
functio validaInput(textus? inputFile) -> bivalens {
    si nihil inputFile aut inputFile == "-" {
        redde verum
    }
    redde solum.exstat(inputFile)
}

# ═══════════════════════════════════════════════════════════════════════════════
# MANIFEST LOADING
# ═══════════════════════════════════════════════════════════════════════════════

# Load sectiones from a manifest file (faber.fab)
# Returns nihil if no manifest path provided
# Throws on file not found or parse errors
@ publica
@ futura
functio loadManifestSectiones(textus? manifestPath) -> lista<SectioAnnotatio>? {
    si nihil manifestPath { redde nihil }

    si non solum.exstat(manifestPath) {
        iace novum Error(scriptum("Manifest not found: §", manifestPath))
    }

    figendum content = solum.lege(manifestPath)

    fixum lexResult = lexare(content)
    si positivum lexResult.errores.longitudo() {
        fixum msg = lexResult.errores[0].textus
        iace novum Error(scriptum("Manifest lexor error: §", msg))
    }

    fixum parseResult = resolvere(lexResult.symbola)
    si positivum parseResult.errores.longitudo() {
        fixum msg = parseResult.errores[0].nuntius
        iace novum Error(scriptum("Manifest parser error: §", msg))
    }

    si nihil parseResult.programma {
        iace novum Error("Failed to parse manifest")
    }

    redde parseResult.programma.sectiones
}
