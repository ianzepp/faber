# ls - list directory contents
#
# Usage: ls [OPTION]... [FILE]...
# Exit status: 0 on success, 1 on minor problems, 2 on serious trouble

ex "../lib/norma/hal/solum" importa solum
ex "../lib/norma/hal/consolum" importa consolum

@ cli "ls"
@ versio "0.1.0"
@ descriptio "List directory contents"

# Display options
@ optio bivalens a brevis "a" longum "all" descriptio "Do not ignore entries starting with ."
@ optio bivalens A brevis "A" longum "almost-all" descriptio "Do not list implied . and .."
@ optio bivalens l brevis "l" descriptio "Use long listing format"
@ optio bivalens h brevis "h" longum "human-readable" descriptio "Print sizes in human readable format"
@ optio bivalens i brevis "i" longum "inode" descriptio "Print index number of each file"
@ optio bivalens s brevis "s" longum "size" descriptio "Print allocated size of each file"
@ optio bivalens F brevis "F" longum "classify" descriptio "Append indicator (*/=>@|) to entries"
@ optio bivalens d brevis "d" longum "directory" descriptio "List directories themselves, not contents"
@ optio bivalens singleColumn brevis "1" descriptio "List one file per line"

# Sorting options
@ optio bivalens t brevis "t" descriptio "Sort by modification time, newest first"
@ optio bivalens sortBySize brevis "S" descriptio "Sort by file size, largest first"
@ optio bivalens r brevis "r" longum "reverse" descriptio "Reverse order while sorting"

# Recursion
@ optio bivalens R brevis "R" longum "recursive" descriptio "List subdirectories recursively"

# Color (long-only)
@ optio textus color longum "color" descriptio "Colorize output (always, auto, never)"

# Positional
@ operandus ceteri textus paths descriptio "Files or directories to list"

incipiet argumenta args exitus code {
    # Default to current directory if no paths given
    varia paths = args.paths
    si paths.longitudo == 0 {
        paths = ["."]
    }

    # Print directory header when listing multiple paths or recursive
    varia showHeader = paths.longitudo > 1 aut args.R

    # Process each path
    ex paths pro path {
        tempta {
            # Check if path exists
            si non solum.exstat(path) {
                consolum.errorLineam("ls: cannot access '" + path + "': No such file or directory")
                code = 1
                perge
            }

            # -d: list directory itself, not contents
            si args.d {
                cede fundeEntry(path, path, args)
                perge
            }

            # If it's a file, just print it
            si solum.estLimae(path) {
                cede fundeEntry(path, path, args)
                perge
            }

            # Show header for multiple directories
            si showHeader {
                consolum.fundeLineam(path + ":")
            }

            # List directory contents
            varia lista<textus> entries = cede solum.elenca(path)

            # Filter hidden files unless -a or -A
            si non args.a et non args.A {
                entries = entries.filtrata(pro textus e: non e.initium("."))
            }
            secus si args.A {
                # -A: show hidden but not . and ..
                entries = entries.filtrata(pro textus e: e != "." et e != "..")
            }

            # Sort entries
            entries = cede sortEntries(entries, path, args)

            # Reverse if requested
            si args.r {
                entries = entries.inversa()
            }

            # Print each entry
            ex entries pro entry {
                fixum fullPath = solum.iunge([path, entry])
                cede fundeEntry(fullPath, entry, args)
            }

            # Recursive listing
            si args.R {
                ex entries pro entry {
                    fixum fullPath = solum.iunge([path, entry])
                    si solum.estDirectorii(fullPath) et entry != "." et entry != ".." {
                        consolum.fundeLineam("")
                        paths.adde(fullPath)
                    }
                }
            }
        }
        cape err {
            consolum.errorLineam("ls: " + err textatum)
            code = 1
        }
    }
}

# Sort entries based on options
@ futura
functio sortEntries(lista<textus> entries, textus dir, Argumenta args) -> lista<textus> {
    # Default: alphabetical sort
    redde entries.ordinata()
}

# Format and print a single entry
@ futura
functio fundeEntry(textus fullPath, textus name, Argumenta args) -> vacuum {
    varia output = ""

    # -s: print size (in blocks, 1 block = 512 bytes for ls compat)
    si args.s {
        fixum size = cede solum.magnitudo(fullPath)
        fixum blocks = ((size + 511) / 512) numeratum
        output = output + blocks textatum + "\t"
    }

    varia displayName = name

    # -F: classify with indicator
    si args.F {
        si solum.estDirectorii(fullPath) {
            displayName = displayName + "/"
        }
        # TODO: detect executables (*), symlinks (@), etc.
    }

    consolum.fundeLineam(output + displayName)
}
