#!/usr/bin/env bun
/**
 * Build standalone faber executable.
 *
 * Steps:
 *   1. Compile faber CLI to standalone binary
 *
 * Note: norma.gen.ts is now generated by build:norma (not here)
 */

import { mkdir, readFile, writeFile } from 'fs/promises';
import { join } from 'path';
import { $ } from 'bun';

const ROOT = join(import.meta.dir, '..');

interface RegistryEntry {
    innatum?: Record<string, string>;
    radixForms?: string[];
    method?: string;
    template?: string;
    params?: string[];
}

interface Translation {
    method?: string;
    template?: string;
    params?: string[];
}

interface NormaCollection {
    innatum?: string;
    methods: Record<string, Translation>;
}

/**
 * Extract TS-only entries from the full norma registry.
 */
async function generateNormaTs(): Promise<void> {
    const jsonPath = join(ROOT, 'fons', 'norma', 'index.json');
    const outPath = join(ROOT, 'fons', 'faber', 'codegen', 'norma.gen.ts');

    const raw = await readFile(jsonPath, 'utf-8');
    const registry: Record<string, RegistryEntry> = JSON.parse(raw);

    // Extract collections and their TS translations
    const collections: Record<string, NormaCollection> = {};
    const radixForms: Record<string, Record<string, string[]>> = {};

    for (const [key, entry] of Object.entries(registry)) {
        const parts = key.split(':');

        if (parts.length === 1) {
            // Collection-level: "lista" -> { innatum: { ts: "Array", ... } }
            const collName = parts[0]!;
            if (entry.innatum?.ts) {
                collections[collName] ??= { methods: {} };
                collections[collName]!.innatum = entry.innatum.ts;
            }
        }
        else if (parts.length === 2) {
            // Method-level: "lista:adde" -> { radixForms: [...] }
            const [collName, methodName] = parts as [string, string];
            if (entry.radixForms) {
                radixForms[collName] ??= {};
                radixForms[collName]![methodName] = entry.radixForms;
            }
        }
        else if (parts.length === 3 && parts[2] === 'ts') {
            // Translation-level: "lista:adde:ts" -> { method: "push" }
            const [collName, methodName] = parts as [string, string, string];
            collections[collName] ??= { methods: {} };
            if (entry.method || entry.template) {
                collections[collName]!.methods[methodName] = {
                    method: entry.method,
                    template: entry.template,
                    params: entry.params,
                };
            }
        }
    }

    // Generate TypeScript
    const lines: string[] = [
        '/**',
        ' * Generated TS-only norma registry.',
        ' * Source: fons/norma/index.json',
        ' * Generator: scripta/build-faber.ts',
        ' */',
        '',
        'export interface Translation {',
        '    method?: string;',
        '    template?: string;',
        '    params?: string[];',
        '}',
        '',
        'export interface NormaCollection {',
        '    innatum?: string;',
        '    methods: Record<string, Translation>;',
        '}',
        '',
        'export const norma: Record<string, NormaCollection> = ' + JSON.stringify(collections, null, 2) + ';',
        '',
        'export const radixForms: Record<string, Record<string, string[]>> = ' + JSON.stringify(radixForms, null, 2) + ';',
        '',
    ];

    await writeFile(outPath, lines.join('\n'));
}

async function main() {
    const start = performance.now();

    // norma.gen.ts is now generated by build:norma (not here)

    const binDir = join(ROOT, 'opus', 'bin');
    await mkdir(binDir, { recursive: true });
    const outExe = join(binDir, 'faber');
    await $`bun build ${join(ROOT, 'fons', 'faber', 'cli.ts')} --compile --outfile=${outExe}`.quiet();
    await $`bash -c 'rm -f .*.bun-build 2>/dev/null || true'`.quiet();

    const elapsed = performance.now() - start;
    console.log(`Built opus/bin/faber (${elapsed.toFixed(0)}ms)`);
}

main().catch(err => {
    console.error(err);
    process.exit(1);
});
