#!/usr/bin/env bun
/**
 * Build script: Generate norma-registry.gen.ts from fons/norma/*.fab
 *
 * WHY: Generates registry at build time using Faber's parser.
 * The parser attaches annotations directly to AST nodes.
 *
 * Usage: bun run build:norma
 */

import { readdir, readFile, writeFile } from 'fs/promises';
import { join } from 'path';

// WHY: Use Faber's actual parser - no hacky regex needed
import { tokenize } from '../fons/faber-ts/tokenizer';
import { parse } from '../fons/faber-ts/parser';
import type { Annotation, FunctioDeclaration, GenusDeclaration, Program } from '../fons/faber-ts/parser/ast';

// =============================================================================
// CONSTANTS AND CONFIGURATION
// =============================================================================

const NORMA_DIR = join(import.meta.dir, '..', 'fons', 'norma');
const INNATUM_DIR = join(NORMA_DIR, 'innatum');
const CODEGEN_DIR = join(import.meta.dir, '..', 'fons', 'faber-ts', 'codegen');
const OUTPUT_FAB = join(import.meta.dir, '..', 'fons', 'rivus', 'codegen', 'norma.gen.fab');
const TARGETS = ['ts', 'py', 'rs', 'cpp', 'zig'] as const;

// =============================================================================
// TYPES
// =============================================================================

interface VerteTranslation {
    method?: string;
    template?: string;
    params?: string[];
}

interface MethodDef {
    name: string;
    translations: Map<string, VerteTranslation>;
    radixForms?: string[];
}

interface CollectionDef {
    name: string;
    innatum: Map<string, string>;
    methods: Map<string, MethodDef>;
}

// =============================================================================
// AST WALKER
// =============================================================================

function extractCollections(ast: Program): CollectionDef[] {
    const collections: CollectionDef[] = [];
    let currentCollection: CollectionDef | null = null;

    for (const stmt of ast.body) {
        // Look for genus declarations with @ innatum
        if (stmt.type === 'GenusDeclaration') {
            const genus = stmt as GenusDeclaration;
            const innatum = findInnatum(genus.annotations);

            if (innatum) {
                currentCollection = {
                    name: genus.name.name,
                    innatum,
                    methods: new Map(),
                };
                collections.push(currentCollection);
            }
        }

        // Look for functio declarations with @ verte
        if (stmt.type === 'FunctioDeclaration' && currentCollection) {
            const func = stmt as FunctioDeclaration;
            const methodDef = extractMethod(func);

            if (methodDef) {
                currentCollection.methods.set(methodDef.name, methodDef);
            }
        }
    }

    return collections;
}

function findInnatum(annotations?: Annotation[]): Map<string, string> | null {
    if (!annotations) return null;

    for (const ann of annotations) {
        if (ann.name === 'innatum' && ann.targetMappings) {
            return ann.targetMappings;
        }
    }
    return null;
}

function extractMethod(func: FunctioDeclaration): MethodDef | null {
    if (!func.annotations || func.annotations.length === 0) return null;

    const translations = new Map<string, VerteTranslation>();
    let radixForms: string[] | undefined;

    for (const ann of func.annotations) {
        if (ann.name === 'verte' && ann.verteTarget) {
            const trans: VerteTranslation = {};

            if (ann.verteMethod) {
                trans.method = ann.verteMethod;
            } else if (ann.verteTemplate && ann.verteParams) {
                trans.template = ann.verteTemplate;
                trans.params = ann.verteParams;
            }

            if (trans.method || trans.template) {
                translations.set(ann.verteTarget, trans);
            }
        }

        if (ann.name === 'radix' && ann.radixForms) {
            radixForms = ann.radixForms;
        }
    }

    if (translations.size === 0) return null;

    const method: MethodDef = {
        name: func.name.name,
        translations,
    };

    if (radixForms) {
        method.radixForms = radixForms;
    }

    return method;
}

// =============================================================================
// TYPESCRIPT CODE GENERATOR (for Faber)
// =============================================================================

function generateRegistryCode(collections: CollectionDef[]): string {
    const lines: string[] = [];

    lines.push('/**');
    lines.push(' * AUTO-GENERATED FILE - DO NOT EDIT');
    lines.push(' * Generated by: bun run build:norma');
    lines.push(' * Source: fons/norma/*.fab');
    lines.push(' */');
    lines.push('');
    lines.push("import type { NormaCollection } from './norma-registry';");
    lines.push('');
    lines.push('export const registry: Map<string, NormaCollection> = new Map([');

    for (const coll of collections) {
        lines.push(`    ['${coll.name}', {`);
        lines.push(`        name: '${coll.name}',`);

        lines.push('        innatum: new Map([');
        for (const [target, type] of coll.innatum) {
            lines.push(`            ['${target}', '${type}'],`);
        }
        lines.push('        ]),');

        lines.push('        methods: new Map([');
        for (const [methodName, method] of coll.methods) {
            lines.push(`            ['${methodName}', {`);
            lines.push(`                name: '${methodName}',`);
            lines.push('                translations: new Map([');
            for (const [target, trans] of method.translations) {
                if (trans.method) {
                    lines.push(`                    ['${target}', { method: '${trans.method}' }],`);
                } else if (trans.template && trans.params) {
                    const paramsStr = trans.params.map(p => `'${p}'`).join(', ');
                    const templateEsc = trans.template.replace(/'/g, "\\'");
                    lines.push(`                    ['${target}', { template: '${templateEsc}', params: [${paramsStr}] }],`);
                }
            }
            lines.push('                ]),');
            if (method.radixForms && method.radixForms.length > 0) {
                const formsStr = method.radixForms.map(f => `'${f}'`).join(', ');
                lines.push(`                radixForms: [${formsStr}],`);
            }
            lines.push('            }],');
        }
        lines.push('        ]),');
        lines.push('    }],');
    }

    lines.push(']);');
    lines.push('');

    return lines.join('\n');
}

// =============================================================================
// FABER CODE GENERATOR (for Rivus)
// =============================================================================

function generateFaberCode(collections: CollectionDef[]): string {
    const lines: string[] = [];

    lines.push('# AUTO-GENERATED FILE - DO NOT EDIT');
    lines.push('# Generated by: bun run build:norma');
    lines.push('# Source: fons/norma/');
    lines.push('');
    lines.push('# Translation result type');
    lines.push('@ publicum');
    lines.push('genus VerteTranslation {');
    lines.push('    si textus method');
    lines.push('    si textus template');
    lines.push('    si lista<textus> params');
    lines.push('}');
    lines.push('');
    lines.push('# Registry data structure (type inferred)');
    lines.push('fixum norma = {');

    for (let i = 0; i < collections.length; i++) {
        const coll = collections[i]!;
        const comma = i < collections.length - 1 ? ',' : '';

        lines.push(`    "${coll.name}": {`);
        lines.push('        "methods": {');

        const methods = Array.from(coll.methods.entries());
        for (let j = 0; j < methods.length; j++) {
            const [methodName, method] = methods[j]!;
            const methodComma = j < methods.length - 1 ? ',' : '';

            lines.push(`            "${methodName}": {`);

            const targets = Array.from(method.translations.entries());
            for (let k = 0; k < targets.length; k++) {
                const [target, trans] = targets[k]!;
                const targetComma = k < targets.length - 1 ? ',' : '';

                if (trans.method) {
                    lines.push(`                "${target}": { "method": "${trans.method}" }${targetComma}`);
                } else if (trans.template && trans.params) {
                    const paramsStr = trans.params.map(p => `"${p}"`).join(', ');
                    lines.push(`                "${target}": { "template": "${trans.template}", "params": [${paramsStr}] }${targetComma}`);
                }
            }

            lines.push(`            }${methodComma}`);
        }

        lines.push('        }');
        lines.push(`    }${comma}`);
    }

    lines.push('}');
    lines.push('');
    lines.push('# Lookup translation for target/collection/method');
    lines.push('@ publica');
    lines.push('functio getNormaTranslation(de textus target, de textus collection, de textus method) -> si VerteTranslation {');
    lines.push('    fixum coll = norma[collection]');
    lines.push('    si nihil coll { redde nihil }');
    lines.push('');
    lines.push('    fixum methodMap = coll.methods[method]');
    lines.push('    si nihil methodMap { redde nihil }');
    lines.push('');
    lines.push('    redde methodMap[target]');
    lines.push('}');
    lines.push('');

    return lines.join('\n');
}

// =============================================================================
// TYPESCRIPT GENERATOR (for Faber - direct from .fab)
// =============================================================================

function generateTypescriptRegistry(collections: CollectionDef[], target: string): string {
    const lines: string[] = [];

    lines.push('/**');
    lines.push(` * Generated ${target.toUpperCase()} norma registry.`);
    lines.push(' * Source: fons/norma/');
    lines.push(' * Generator: bun run build:norma');
    lines.push(' */');
    lines.push('');
    lines.push('export interface Translation {');
    lines.push('    method?: string;');
    lines.push('    template?: string;');
    lines.push('    params?: string[];');
    lines.push('}');
    lines.push('');
    lines.push('export interface NormaCollection {');
    lines.push('    innatum?: string;');
    lines.push('    methods: Record<string, Translation>;');
    lines.push('}');
    lines.push('');
    lines.push(`export const norma: Record<string, NormaCollection> = {`);

    for (let i = 0; i < collections.length; i++) {
        const coll = collections[i]!;
        const comma = i < collections.length - 1 ? ',' : '';

        lines.push(`  ${JSON.stringify(coll.name)}: {`);
        lines.push('    "methods": {');

        const methods = Array.from(coll.methods.entries());
        for (let j = 0; j < methods.length; j++) {
            const [methodName, method] = methods[j]!;
            const methodComma = j < methods.length - 1 ? ',' : '';

            // Get translation for this target only
            const trans = method.translations.get(target);
            if (!trans) continue;

            lines.push(`      ${JSON.stringify(methodName)}: {`);
            if (trans.method) {
                lines.push(`        "method": ${JSON.stringify(trans.method)}`);
            } else if (trans.template && trans.params) {
                lines.push(`        "template": ${JSON.stringify(trans.template)},`);
                lines.push(`        "params": ${JSON.stringify(trans.params)}`);
            }
            lines.push(`      }${methodComma}`);
        }

        lines.push('    }');

        // Add innatum if exists for this target
        const innatum = coll.innatum.get(target);
        if (innatum) {
            lines.push(`    , "innatum": ${JSON.stringify(innatum)}`);
        }

        lines.push(`  }${comma}`);
    }

    lines.push('}');
    lines.push('');

    // Generate radixForms lookup
    lines.push('export const radixForms: Record<string, Record<string, string[]>> = {');
    for (let i = 0; i < collections.length; i++) {
        const coll = collections[i]!;
        const collComma = i < collections.length - 1 ? ',' : '';

        // Check if any methods have radixForms
        const methodsWithForms = Array.from(coll.methods.entries()).filter(([_, m]) => m.radixForms);
        if (methodsWithForms.length === 0) continue;

        lines.push(`  ${JSON.stringify(coll.name)}: {`);

        for (let j = 0; j < methodsWithForms.length; j++) {
            const [methodName, method] = methodsWithForms[j]!;
            const methodComma = j < methodsWithForms.length - 1 ? ',' : '';
            lines.push(`    ${JSON.stringify(methodName)}: ${JSON.stringify(method.radixForms)}${methodComma}`);
        }

        lines.push(`  }${collComma}`);
    }
    lines.push('}');
    lines.push('');

    return lines.join('\n');
}

// =============================================================================
// UTILITY FUNCTIONS
// =============================================================================

/**
 * Finds all .fab files in norma directories
 */
async function findNormaFiles(): Promise<{ dir: string; file: string }[]> {
    const topLevelFiles = await readdir(NORMA_DIR);
    const topLevelFabs = topLevelFiles.filter(f => f.endsWith('.fab')).map(f => ({ dir: NORMA_DIR, file: f }));

    const innatumFiles = await readdir(INNATUM_DIR);
    const innatumFabs = innatumFiles.filter(f => f.endsWith('.fab')).map(f => ({ dir: INNATUM_DIR, file: f }));

    return [...topLevelFabs, ...innatumFabs];
}

/**
 * Parses a .fab file and extracts collections, handling errors gracefully
 */
async function parseNormaFile(fileInfo: { dir: string; file: string }): Promise<CollectionDef[]> {
    const { dir, file } = fileInfo;
    const filePath = join(dir, file);
    const content = await readFile(filePath, 'utf-8');

    // WHY: Use Faber's parser to get proper AST with annotations
    const tokenResult = tokenize(content);
    if (tokenResult.errors.length > 0) {
        console.error(`Tokenizer errors in ${file}:`);
        for (const err of tokenResult.errors) {
            console.error(`  ${err.position.line}:${err.position.column} - ${err.text}`);
        }
        process.exit(1);
    }

    const result = parse(tokenResult.tokens);
    if (result.errors.length > 0) {
        console.error(`Parse errors in ${file}:`);
        for (const err of result.errors) {
            console.error(`  ${err.position.line}:${err.position.column} - ${err.message}`);
        }
        process.exit(1);
    }

    if (!result.program) {
        console.error(`No program generated for ${file}`);
        process.exit(1);
    }

    return extractCollections(result.program);
}

// =============================================================================
// MAIN
// =============================================================================

async function main() {
    // Discover norma files
    const allFiles = await findNormaFiles();

    if (allFiles.length === 0) {
        console.error('No .fab files found in fons/norma/ or fons/norma/innatum/');
        process.exit(1);
    }

    const topLevelFabs = allFiles.filter(f => f.dir === NORMA_DIR);
    const innatumFabs = allFiles.filter(f => f.dir === INNATUM_DIR);

    console.log(`Found ${allFiles.length} norma file(s)`);
    console.log(`  Top-level: ${topLevelFabs.map(f => f.file).join(', ')}`);
    console.log(`  Innatum: ${innatumFabs.map(f => f.file).join(', ')}`);

    // Parse all norma files and collect collections
    const allCollections: CollectionDef[] = [];

    for (const fileInfo of allFiles) {
        const collections = await parseNormaFile(fileInfo);
        for (const coll of collections) {
            allCollections.push(coll);
            console.log(`  ${fileInfo.file}: ${coll.name} with ${coll.methods.size} method(s)`);
        }
    }

    // Generate code for all targets
    console.log('\nGenerating TypeScript registries...');
    for (const target of TARGETS) {
        const outputTs = join(CODEGEN_DIR, `norma.${target}.gen.ts`);
        const tsCode = generateTypescriptRegistry(allCollections, target);
        await writeFile(outputTs, tsCode, 'utf-8');
        console.log(`  ✓ ${outputTs}`);
    }

    console.log('\nGenerating Faber registry...');
    const fabCode = generateFaberCode(allCollections);
    await writeFile(OUTPUT_FAB, fabCode, 'utf-8');
    console.log(`  ✓ ${OUTPUT_FAB}`);
}

main().catch(err => {
    console.error('Error:', err);
    process.exit(1);
});
