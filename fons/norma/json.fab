# json.fab - JSON Encoding/Decoding Device
#
# Etymology: "JSON" - JavaScript Object Notation (universal, kept as-is).
#
# Part of the Hardware Abstraction Layer (HAL).
#
# Design principles:
#   - pange (compose) for serialization: composing the JSON text
#   - solve (untangle) for parsing: solving/extracting data from text
#   - All operations are synchronous (pure in-memory transforms)

@ subsidia ts "../norma-ts/json.ts"
pactum json {
    # =========================================================================
    # SERIALIZATION
    # =========================================================================
    # Verb: pange from "pangere" (to fasten, compose)
    # Why: Composing/fastening data into JSON text representation.

    # Serialize value to JSON string
    # indentum = 0 or omitted: compact output
    # indentum > 0: pretty-printed with that many spaces
    @ externa
    functio pange(quidlibet valor, si numerus indentum) -> textus

    # =========================================================================
    # PARSING
    # =========================================================================
    # Verb: solve from "solvere" (to loosen, untangle)
    # Why: Untangling/extracting data from JSON text.

    # Parse JSON string to value (throws on error)
    @ externa
    functio solve(textus json) -> quidlibet

    # Verb: tempta from "temptare" (to try, attempt)
    # Why: Attempting to parse, returning null on failure instead of throwing.

    # Attempt to parse JSON string (returns null on error)
    @ externa
    functio tempta(textus json) -> si quidlibet

    # =========================================================================
    # TYPE CHECKING
    # =========================================================================
    # Predicates: "est X" = "it is X" - natural Latin predicate form

    @ externa
    functio estNihil(quidlibet valor) -> bivalens

    @ externa
    functio estBivalens(quidlibet valor) -> bivalens

    @ externa
    functio estNumerus(quidlibet valor) -> bivalens

    @ externa
    functio estTextus(quidlibet valor) -> bivalens

    @ externa
    functio estLista(quidlibet valor) -> bivalens

    @ externa
    functio estTabula(quidlibet valor) -> bivalens

    # =========================================================================
    # VALUE EXTRACTION
    # =========================================================================
    # Pattern: "ut X" = "as X" - extract as type with default

    @ externa
    functio utTextus(quidlibet valor, textus defVal) -> textus

    @ externa
    functio utNumerus(quidlibet valor, numerus defVal) -> numerus

    @ externa
    functio utBivalens(quidlibet valor, bivalens defVal) -> bivalens

    # =========================================================================
    # VALUE ACCESS
    # =========================================================================

    # Verb: cape from "capere" (to take, seize)
    # Get value by key (returns null if missing)
    @ externa
    functio cape(quidlibet valor, textus clavis) -> quidlibet

    # Verb: carpe from "carpere" (to pluck)
    # Pluck value by array index (returns null if out of bounds)
    @ externa
    functio carpe(quidlibet valor, numerus index) -> quidlibet

    # Verb: inveni from "invenire" (to find)
    # Find value by dotted path (returns null if not found)
    @ externa
    functio inveni(quidlibet valor, textus via) -> quidlibet
}
