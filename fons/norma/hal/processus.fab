# processus.fab - Process Device
#
# Etymology: "processus" from "pro-" (forward) + "cedere" (to go)
#            A going forward, a process in motion.
#
# Part of the Hardware Abstraction Layer (HAL).
#
# Design principles:
#   - Different verbs for different spawn semantics:
#     - genera: spawn attached, caller manages lifecycle
#     - dimitte: spawn detached, dismiss to run independently
#   - Shell execution uses traditional sync/async:
#     - Imperative (exsequi): sync, blocks until complete
#     - Future (exsequetur): async, returns promise
#   - Environment uses lege/scribe (read/write) - simple and consistent

# =============================================================================
# TYPES
# =============================================================================

# Spawned subprocess handle for attached processes
# Maps to: Bun.spawn() result
genus Subprocessus {
    numerus pid              # process ID
    promissum<numerus> expiravit   # resolves to exit code when process ends
}

@ subsidia ts "codegen/ts/processus.ts"
pactum processus {
    # =========================================================================
    # SPAWN - Attached
    # =========================================================================
    # Verb: genera from "generare" (to generate, beget, bring forth)
    # Why: Creating/generating a new process. Caller maintains control -
    #      can wait for exit, capture output via handle.
    # Maps to: Bun.spawn() with handle returned

    # Spawn attached process - caller can wait for exit via handle.expiravit
    @ externa
    functio genera(
        lista<textus> argumenta,
        si textus directorium,
        si tabula<textus, textus> ambitus
    ) -> Subprocessus

    # =========================================================================
    # SPAWN - Detached
    # =========================================================================
    # Verb: dimitte from "dimittere" (to send away, dismiss, release)
    # Why: Dismissing the process to run on its own - fire and forget.
    #      Process continues independently, survives parent exit.
    #      Distinct verb from genera to indicate different lifecycle semantics.
    # Maps to: Bun.spawn() with proc.unref(), stdio ignored

    # Dismiss process to run independently - returns PID
    @ externa
    functio dimitte(
        lista<textus> argumenta,
        si textus directorium,
        si tabula<textus, textus> ambitus
    ) -> numerus

    # =========================================================================
    # SHELL EXECUTION
    # =========================================================================
    # Verb: exsequi/exsequetur from "exsequi" (to follow out, execute, accomplish)
    # Why: Executing a command through to completion. Shell features available
    #      (pipes, redirects, &&, ||, etc). Returns stdout.
    # Maps to: sh -c "cmd" via Bun.spawnSync / Bun.spawn

    # Execute shell command, block until complete, return stdout (sync)
    @ externa
    functio exsequi(textus imperium) -> textus

    # Execute shell command, return stdout when complete (async)
    @ futura
    @ externa
    functio exsequetur(textus imperium) -> textus

    # =========================================================================
    # ENVIRONMENT - Read
    # =========================================================================
    # Verb: lege from "legere" (to read, gather)
    # Why: Reading a value from the process environment. Same verb as file
    #      reading - context (processus vs solum) disambiguates.
    # Maps to: Bun.env[name] / process.env[name]

    # Read environment variable (returns nihil if not set)
    @ externa
    functio lege(textus nomen) -> si textus

    # =========================================================================
    # ENVIRONMENT - Write
    # =========================================================================
    # Verb: scribe from "scribere" (to write)
    # Why: Writing a value to the process environment. Same verb as file
    #      writing - context disambiguates.
    # Maps to: Bun.env[name] = value / process.env[name] = value

    # Write environment variable
    @ externa
    functio scribe(textus nomen, textus valor) -> vacuum

    # =========================================================================
    # PROCESS INFO - Working Directory
    # =========================================================================
    # Noun: sedes (seat, dwelling place, residence)
    # Why: Where the process "dwells" in the filesystem tree. The CWD is
    #      the process's seat/residence. Avoids collision with solum.directorium
    #      which extracts directory from path strings.
    # Maps to: process.cwd()

    # Get current working directory (where the process dwells)
    @ externa
    functio sedes() -> textus

    # =========================================================================
    # PROCESS INFO - Change Directory
    # =========================================================================
    # Verb: muta from "mutare" (to change, alter)
    # Why: Changing/altering the working directory. Generic "change" verb
    #      fits well - you're mutating process state.
    # Maps to: process.chdir(path)

    # Change current working directory
    @ externa
    functio muta(textus via) -> vacuum

    # =========================================================================
    # PROCESS INFO - Identity
    # =========================================================================
    # Noun: identitas (identity)
    # Why: Accessor for process identity (PID). Not a verb - it's a property.
    # Maps to: process.pid

    # Get process ID
    @ externa
    functio identitas() -> numerus

    # =========================================================================
    # PROCESS INFO - Arguments
    # =========================================================================
    # Noun: argumenta (arguments)
    # Why: Accessor for command line arguments. Not a verb - it's a property.
    # Maps to: Bun.argv.slice(2) / process.argv.slice(2)

    # Get command line arguments (excludes runtime and script path)
    @ externa
    functio argumenta() -> lista<textus>

    # =========================================================================
    # EXIT
    # =========================================================================
    # Verb: exi from "exire" (to go out, exit, depart)
    # Why: Direct Latin root of English "exit". Process departs/goes out.
    #      Returns numquam (never) - this call does not return.
    # Maps to: process.exit(code)

    # Exit process with code (never returns)
    @ externa
    functio exi(numerus code) -> numquam
}
