# solum.fab - File System Device
#
# Etymology: "solum" - ground, floor, base. Local/ground I/O (vs caelum/sky/network).
#
# Part of the Hardware Abstraction Layer (HAL).
#
# Design principles:
#   - Verb conjugation encodes sync/async semantics:
#     - Imperative (-a, -e, -i): synchronous operation
#     - Future indicative (-et, -ebit): asynchronous operation (returns promissum)
#   - Different verbs for different data types (text vs bytes vs lines)
#   - No "Latin as paint" - verbs chosen for semantic fit, not translation

# =============================================================================
# TYPES
# =============================================================================

# Full file status returned by describe/describet
# Maps to: stat(), lstat()
genus SolumStatus {
    numerus modus         # permission bits (e.g., 0o755)
    numerus nexus         # hard link count
    numerus possessor     # owner uid
    numerus grex          # group gid
    numerus magnitudo     # size in bytes
    numerus modificatum   # mtime (ms since epoch)
    bivalens estDirectorii
    bivalens estVinculum  # is symlink
}

@ subsidia ts "../../norma-ts/hal/solum.ts"
@ subsidia rs "../../norma-rs/hal/solum.rs"
@ subsidia go "../../norma-go/hal/solum/solum.go"
pactum solum {
    # =========================================================================
    # READING - Text
    # =========================================================================
    # Verb: lege/leget from "legere" (to read, gather)
    # Why: The primary Latin verb for reading. Text is the "readable" format.
    # Maps to: fs.readFileSync(path, 'utf8') / fs.readFile(path, 'utf8')

    # Read entire file as text (sync)
    @ externa
    functio lege(textus via) -> textus

    # Read entire file as text (async)
    @ futura
    @ externa
    functio leget(textus via) -> textus

    # =========================================================================
    # READING - Bytes
    # =========================================================================
    # Verb: hauri/hauriet from "haurire" (to draw up, draw water)
    # Why: Drawing bytes from a file like drawing water from a well.
    #      Distinct from "reading" text - this is raw extraction.
    # Maps to: fs.readFileSync(path) / fs.readFile(path) returning Buffer

    # Draw entire file as bytes (sync)
    @ externa
    functio hauri(textus via) -> octeti

    # Draw entire file as bytes (async)
    @ futura
    @ externa
    functio hauriet(textus via) -> octeti

    # =========================================================================
    # READING - Lines
    # =========================================================================
    # Verb: carpe/carpiet from "carpere" (to pluck, pick, harvest)
    # Why: Plucking lines one by one, like picking fruit from a tree.
    #      Different from bulk reading - implies iteration/selection.
    # Maps to: readline interface or line-by-line file reading

    # Pluck lines from file (sync)
    @ externa
    functio carpe(textus via) -> lista<textus>

    # Pluck lines from file (async)
    @ futura
    @ externa
    functio carpiet(textus via) -> lista<textus>

    # =========================================================================
    # WRITING - Text
    # =========================================================================
    # Verb: scribe/scribet from "scribere" (to write)
    # Why: The primary Latin verb for writing. Natural fit for text output.
    #      Also handles writing lines (text with newlines).
    # Maps to: fs.writeFileSync(path, data, 'utf8') / fs.writeFile(...)

    # Write text to file, overwrites existing (sync)
    @ externa
    functio scribe(textus via, textus data) -> vacuum

    # Write text to file, overwrites existing (async)
    @ futura
    @ externa
    functio scribet(textus via, textus data) -> vacuum

    # =========================================================================
    # WRITING - Bytes
    # =========================================================================
    # Verb: funde/fundet from "fundere" (to pour, pour out)
    # Why: Pouring bytes into a file like pouring liquid into a vessel.
    #      Counterpart to "hauri" (drawing out) - funde pours in.
    # Maps to: fs.writeFileSync(path, buffer) / fs.writeFile(path, buffer)

    # Pour bytes to file, overwrites existing (sync)
    @ externa
    functio funde(textus via, octeti data) -> vacuum

    # Pour bytes to file, overwrites existing (async)
    @ futura
    @ externa
    functio fundet(textus via, octeti data) -> vacuum

    # =========================================================================
    # WRITING - Append
    # =========================================================================
    # Verb: appone/apponet from "apponere" (to place near, add to)
    # Why: Adding content to the end of existing content.
    #      Not overwriting - placing alongside what's already there.
    # Maps to: fs.appendFileSync(path, data) / fs.appendFile(path, data)

    # Append text to file (sync)
    @ externa
    functio appone(textus via, textus data) -> vacuum

    # Append text to file (async)
    @ futura
    @ externa
    functio apponet(textus via, textus data) -> vacuum

    # =========================================================================
    # FILE INFO - Existence
    # =========================================================================
    # Verb: exstat/exstabit from "exstare" (to stand out, exist, be visible)
    # Why: Asking if something exists/stands in the filesystem.
    # Maps to: fs.existsSync(path) / fs.access(path)

    # Check if path exists (sync)
    @ externa
    functio exstat(textus via) -> bivalens

    # Check if path exists (async)
    @ futura
    @ externa
    functio exstabit(textus via) -> bivalens

    # =========================================================================
    # FILE INFO - Details
    # =========================================================================
    # Verb: describe/describet from "describere" (to write down, delineate, describe)
    # Why: Asking the filesystem to describe/detail the file's properties.
    #      Returns full metadata struct, not just existence.
    # Maps to: fs.statSync(path) / fs.stat(path) - uses lstat to not follow symlinks

    # Get file details (sync)
    @ externa
    functio describe(textus via) -> SolumStatus

    # Get file details (async)
    @ futura
    @ externa
    functio describet(textus via) -> SolumStatus

    # =========================================================================
    # FILE INFO - Symlinks
    # =========================================================================
    # Verb: sequere/sequetur from "sequi" (to follow)
    # Why: Following a symbolic link to discover its target.
    #      Like following a trail or path to its destination.
    # Maps to: fs.readlinkSync(path) / fs.readlink(path)

    # Follow symlink to get target path (sync)
    @ externa
    functio sequere(textus via) -> textus

    # Follow symlink to get target path (async)
    @ futura
    @ externa
    functio sequetur(textus via) -> textus

    # =========================================================================
    # FILE OPERATIONS - Delete
    # =========================================================================
    # Verb: dele/delet from "delere" (to destroy, delete, erase)
    # Why: Direct Latin root of English "delete". Unambiguous.
    #      Files only - use amputa/amputabit for directories.
    # Maps to: fs.unlinkSync(path) / fs.unlink(path)

    # Delete file (sync)
    @ externa
    functio dele(textus via) -> vacuum

    # Delete file (async)
    @ futura
    @ externa
    functio delet(textus via) -> vacuum

    # =========================================================================
    # FILE OPERATIONS - Copy
    # =========================================================================
    # Verb: exscribe/exscribet from "exscribere" (to copy out, transcribe)
    # Why: Writing out a copy of something. More precise than generic "copy".
    #      The "ex-" prefix implies extracting/copying from source.
    # Maps to: fs.copyFileSync(src, dest) / fs.copyFile(src, dest)

    # Copy file (sync)
    @ externa
    functio exscribe(textus fons, textus destinatio) -> vacuum

    # Copy file (async)
    @ futura
    @ externa
    functio exscribet(textus fons, textus destinatio) -> vacuum

    # =========================================================================
    # FILE OPERATIONS - Rename/Move
    # =========================================================================
    # Verb: renomina/renominabit from "renominare" (to rename)
    # Why: Connects to "nomen" terminology used throughout Faber.
    #      Handles both rename and move (same underlying syscall).
    # Maps to: fs.renameSync(src, dest) / fs.rename(src, dest)

    # Rename or move file (sync)
    @ externa
    functio renomina(textus fons, textus destinatio) -> vacuum

    # Rename or move file (async)
    @ futura
    @ externa
    functio renominabit(textus fons, textus destinatio) -> vacuum

    # =========================================================================
    # FILE OPERATIONS - Touch
    # =========================================================================
    # Verb: tange/tanget from "tangere" (to touch)
    # Why: Direct Latin root of English "touch". Creates if missing,
    #      updates mtime if exists. Light contact with the file.
    # Maps to: touch behavior (utimes or create empty file)

    # Touch file - create or update mtime (sync)
    @ externa
    functio tange(textus via) -> vacuum

    # Touch file - create or update mtime (async)
    @ futura
    @ externa
    functio tanget(textus via) -> vacuum

    # =========================================================================
    # DIRECTORY OPERATIONS - Create
    # =========================================================================
    # Verb: crea/creabit from "creare" (to create, bring forth)
    # Why: Creating something new. In this context, always a directory.
    #      Recursive by default (creates parent dirs as needed).
    # Maps to: fs.mkdirSync(path, {recursive: true}) / fs.mkdir(...)

    # Create directory (sync)
    @ externa
    functio crea(textus via) -> vacuum

    # Create directory (async)
    @ futura
    @ externa
    functio creabit(textus via) -> vacuum

    # =========================================================================
    # DIRECTORY OPERATIONS - List
    # =========================================================================
    # Verb: enumera/enumerabit from "enumerare" (to count out, enumerate)
    # Why: Listing/counting the contents of a directory.
    #      More precise than "list" - implies systematic enumeration.
    # Maps to: fs.readdirSync(path) / fs.readdir(path)

    # List directory contents (sync)
    @ externa
    functio enumera(textus via) -> lista<textus>

    # List directory contents (async)
    @ futura
    @ externa
    functio enumerabit(textus via) -> lista<textus>

    # =========================================================================
    # DIRECTORY OPERATIONS - Prune/Remove
    # =========================================================================
    # Verb: amputa/amputabit from "amputare" (to cut off, prune)
    # Why: Pruning a branch from a tree (directory tree).
    #      Recursive deletion - removes directory and all contents.
    #      Avoids "puto" which also means "to think".
    # Maps to: fs.rmSync(path, {recursive: true}) / fs.rm(...)

    # Prune directory tree (sync)
    @ externa
    functio amputa(textus via) -> vacuum

    # Prune directory tree (async)
    @ futura
    @ externa
    functio amputabit(textus via) -> vacuum

    # =========================================================================
    # PATH UTILITIES
    # =========================================================================
    # These are pure functions operating on path strings, not filesystem I/O.
    # Sync only - no async variants needed. Not verb-based (accessors/transformers).
    # Maps to: path.join, path.dirname, path.basename, path.extname, path.resolve

    # Join path segments
    # Maps to: path.join(...parts)
    @ externa
    functio iunge(lista<textus> partes) -> textus

    # Get directory part of path
    # Maps to: path.dirname(path)
    @ externa
    functio directorium(textus via) -> textus

    # Get filename part of path
    # Maps to: path.basename(path)
    @ externa
    functio basis(textus via) -> textus

    # Get file extension (includes dot)
    # Maps to: path.extname(path)
    @ externa
    functio extensio(textus via) -> textus

    # Resolve to absolute path
    # Maps to: path.resolve(path)
    @ externa
    functio absolve(textus via) -> textus

    # Get user's home directory
    # Maps to: os.homedir()
    @ externa
    functio domus() -> textus

    # Get system temp directory
    # Maps to: os.tmpdir()
    @ externa
    functio temporarium() -> textus
}
