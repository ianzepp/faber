# nuncius.fab - Inter-Process Communication Device
#
# Etymology: "nuncius" - messenger, envoy. Communication between processes.
#
# Part of the Hardware Abstraction Layer (HAL).
# Maps to IPCDevice from monk-os-kernel.
#
# Design notes:
#   - Verb conjugation encodes sync/async:
#     - Imperative (-a, -e, -i): synchronous
#     - Future indicative (-et, -ebit): asynchronous
#   - Shared memory for fast data exchange
#   - Mutex/semaphore/condvar for synchronization
#   - Message ports for structured communication

@ subsidia ts "../../norma-ts/hal/nuncius.ts"
pactum nuncius {
    # =========================================================================
    # SHARED MEMORY
    # =========================================================================

    # Allocate shared memory buffer
    @ externa
    functio alloca(numerus magnitudo) -> octeti

    # =========================================================================
    # MESSAGE PORTS
    # =========================================================================
    # Verb: aperi from "aperire" (to open, uncover)
    # Why: Opening a communication channel between endpoints.

    # Open a connected message port pair
    @ externa
    functio aperi() -> ParPortarum

    # =========================================================================
    # SYNCHRONIZATION PRIMITIVES
    # =========================================================================
    # Verb: restringe from "restringere" (to restrict, bind back)
    # Why: A mutex restricts access to a resource.
    #
    # Verb: numera from "numerare" (to count, reckon)
    # Why: A semaphore counts available permits.
    #
    # Verb: vigila from "vigilare" (to watch, keep watch)
    # Why: Threads keep watch at a condition variable.

    # Restrict access via mutex backed by shared memory
    @ externa
    functio restringe(octeti memoria, numerus offset) -> Mutex

    # Count permits via semaphore backed by shared memory
    @ externa
    functio numera(octeti memoria, numerus offset, numerus valor) -> Semaphorum

    # Keep watch via condition variable backed by shared memory
    @ externa
    functio vigila(octeti memoria, numerus offset) -> Conditio
}

# Message port pair
pactum ParPortarum {
    @ externa
    functio a() -> Porta

    @ externa
    functio b() -> Porta
}

# Message port (one end of a channel)
pactum Porta {
    # Send message
    @ externa
    functio mitte(quidlibet nuntius) -> vacuum

    # Receive message (async, blocks until available)
    @ futura
    @ externa
    functio recipiet() -> quidlibet

    # Check if message available
    @ externa
    functio paratum() -> bivalens

    # Close port
    @ externa
    functio claude() -> vacuum
}

# Mutual exclusion lock
pactum Mutex {
    # Acquire lock (blocks until available)
    @ externa
    functio obstringe() -> vacuum

    # Try to acquire without blocking
    @ externa
    functio tempta() -> bivalens

    # Release lock
    @ externa
    functio solve() -> vacuum
}

# Counting semaphore
pactum Semaphorum {
    # Wait (decrement, blocks if zero)
    @ externa
    functio exspecta() -> vacuum

    # Try to decrement without blocking
    @ externa
    functio tempta() -> bivalens

    # Post (increment, wakes one waiter)
    @ externa
    functio signa() -> vacuum

    # Read current value
    @ externa
    functio lege() -> numerus
}

# Condition variable
pactum Conditio {
    # Wait for signal (must hold mutex)
    @ externa
    functio exspecta(Mutex mutex) -> vacuum

    # Wait with timeout, returns false if timed out
    @ externa
    functio exspectaUsque(Mutex mutex, numerus ms) -> bivalens

    # Wake one waiting thread
    @ externa
    functio signa() -> vacuum

    # Wake all waiting threads
    @ externa
    functio diffunde() -> vacuum
}
