# crypta.fab - Cryptography Device
#
# Etymology: "crypta" - vault, crypt, hidden chamber. Secret operations.
#
# Part of the Hardware Abstraction Layer (HAL).
# Maps to CryptoDevice from monk-os-kernel.
#
# Design notes:
#   - Hash: SHA-256, SHA-384, SHA-512, MD5, BLAKE2b
#   - Encrypt: AES-256-GCM (authenticated), AES-256-CBC
#   - Sign: HMAC, RSA, Ed25519
#   - KDF: PBKDF2, Argon2id, scrypt

@ subsidia ts "codegen/ts/crypta.ts"
pactum crypta {
    # =========================================================================
    # HASHING
    # =========================================================================

    # Hash bytes with algorithm (sha256, sha384, sha512, md5, blake2b)
    @ futura
    @ externa
    functio digere(textus algorithmus, octeti data) -> octeti

    # Hash text (convenience - encodes as UTF-8 first)
    @ futura
    @ externa
    functio digereTextum(textus algorithmus, textus data) -> octeti

    # Hash to hex string
    @ futura
    @ externa
    functio digereHex(textus algorithmus, octeti data) -> textus

    # =========================================================================
    # HMAC
    # =========================================================================

    # HMAC with algorithm and key
    @ futura
    @ externa
    functio hmac(textus algorithmus, octeti clavis, octeti data) -> octeti

    # HMAC to hex string
    @ futura
    @ externa
    functio hmacHex(textus algorithmus, octeti clavis, octeti data) -> textus

    # =========================================================================
    # SYMMETRIC ENCRYPTION
    # =========================================================================

    # Encrypt with algorithm (aes-256-gcm, aes-256-cbc)
    # Returns ciphertext with IV prepended
    @ futura
    @ externa
    functio encripta(textus algorithmus, octeti clavis, octeti data) -> octeti

    # Decrypt (expects IV prepended to ciphertext)
    @ futura
    @ externa
    functio decripta(textus algorithmus, octeti clavis, octeti data) -> octeti

    # =========================================================================
    # KEY DERIVATION
    # =========================================================================

    # Derive key from password (pbkdf2, argon2id, scrypt)
    @ futura
    @ externa
    functio derivaClavem(textus algorithmus, textus password, octeti sal, numerus longitudo) -> octeti

    # =========================================================================
    # KEY GENERATION
    # =========================================================================

    # Generate symmetric key (aes-256)
    @ futura
    @ externa
    functio generaClavem(textus algorithmus) -> octeti

    # Generate key pair (rsa-2048, rsa-4096, ed25519)
    @ futura
    @ externa
    functio generaParClavium(textus algorithmus) -> ParClavium

    # =========================================================================
    # ASYMMETRIC SIGNATURES
    # =========================================================================

    # Sign data with private key
    @ futura
    @ externa
    functio signa(octeti clavisPrivata, octeti data) -> octeti

    # Verify signature with public key
    @ futura
    @ externa
    functio verifica(octeti clavisPublica, octeti data, octeti signatura) -> bivalens

    # =========================================================================
    # ENCODING UTILITIES
    # =========================================================================

    # Encode bytes as hex
    @ externa
    functio hexCodifica(octeti data) -> textus

    # Decode hex to bytes
    @ externa
    functio hexDecodifica(textus hex) -> octeti

    # Encode bytes as base64
    @ externa
    functio base64Codifica(octeti data) -> textus

    # Decode base64 to bytes
    @ externa
    functio base64Decodifica(textus b64) -> octeti
}

# Key pair (asymmetric)
pactum ParClavium {
    @ externa
    functio publica() -> octeti

    @ externa
    functio privata() -> octeti

    @ externa
    functio algorithmus() -> textus
}
