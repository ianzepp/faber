# yaml.fab - YAML Serialization Library
#
# Etymology: "YAML" - YAML Ain't Markup Language (kept as-is)
#
# Core functions use Latin verbs from forma.fab:
#   solve  - dissolve/loosen (serialize: structured -> textus)
#   pange  - compose/fasten (deserialize: textus -> structured)
#
# Note: YAML support varies by target. TypeScript/Zig require external libraries.
# Mappings: ts=yaml.dump/load (npm), py=yaml.safe_dump/safe_load, rs=serde_yaml

# =============================================================================
# TARGET AVAILABILITY
# =============================================================================
#
# | Target | Library          | Notes                    |
# |--------|------------------|--------------------------|
# | ts     | yaml (npm)       | Requires: npm i yaml     |
# | py     | PyYAML (stdlib)  | import yaml              |
# | rs     | serde_yaml       | Requires: cargo add      |
# | cpp    | yaml-cpp         | Requires: vcpkg/conan    |
# | zig    | -                | No stdlib YAML support   |

# =============================================================================
# SERIALIZATION
# =============================================================================

# Serialize value to YAML string
@ verte ts (val) -> "YAML.stringify(§)"
@ verte py (val) -> "yaml.safe_dump(§)"
@ verte rs (val) -> "serde_yaml::to_string(&§).unwrap()"
@ verte cpp (val) -> "YAML::Dump(§)"
@ externa
functio solve(quidlibet val) -> textus

# Serialize multiple documents to YAML string (--- separated)
@ verte ts (docs) -> "§.map(d => YAML.stringify(d)).join('---\\n')"
@ verte py (docs) -> "yaml.safe_dump_all(§)"
@ verte rs (docs) -> "§.iter().map(|d| serde_yaml::to_string(d).unwrap()).collect::<Vec<_>>().join(\"---\\n\")"
@ verte cpp (docs) -> "@compileError(\"Multi-doc YAML not supported in yaml-cpp single expression\")"
@ externa
functio solveMulti(lista<quidlibet> docs) -> textus

# =============================================================================
# DESERIALIZATION
# =============================================================================

# Parse YAML string to value (first document if multi-doc)
@ verte ts (textus) -> "YAML.parse(§)"
@ verte py (textus) -> "yaml.safe_load(§)"
@ verte rs (textus) -> "serde_yaml::from_str(&§).unwrap()"
@ verte cpp (textus) -> "YAML::Load(§)"
@ externa
functio pange(textus yaml) -> quidlibet

# Parse multi-document YAML string to list of values
@ verte ts (textus) -> "YAML.parseAllDocuments(§).map(d => d.toJSON())"
@ verte py (textus) -> "list(yaml.safe_load_all(§))"
@ verte rs (textus) -> "serde_yaml::Deserializer::from_str(&§).map(|d| d.unwrap()).collect()"
@ verte cpp (textus) -> "YAML::LoadAll(§)"
@ externa
functio pangeMulti(textus yaml) -> lista<quidlibet>

# =============================================================================
# TYPE CHECKING
# =============================================================================
# YAML uses same dynamic types as JSON - reuse json.fab type checks
# or call JSON equivalents since YAML is a superset of JSON

# Check if value is null
@ verte ts (val) -> "(§ === null || § === undefined)"
@ verte py (val) -> "(§ is None)"
@ verte rs (val) -> "§.is_null()"
@ verte cpp (val) -> "§.IsNull()"
@ externa
functio estNihil(quidlibet val) -> bivalens

# Check if value is string
@ verte ts (val) -> "(typeof § === 'string')"
@ verte py (val) -> "isinstance(§, str)"
@ verte rs (val) -> "§.is_string()"
@ verte cpp (val) -> "§.IsScalar()"
@ externa
functio estTextus(quidlibet val) -> bivalens

# Check if value is number
@ verte ts (val) -> "(typeof § === 'number')"
@ verte py (val) -> "isinstance(§, (int, float))"
@ verte rs (val) -> "§.is_number()"
@ verte cpp (val) -> "§.IsScalar()"
@ externa
functio estNumerus(quidlibet val) -> bivalens

# Check if value is sequence (list/array)
@ verte ts (val) -> "Array.isArray(§)"
@ verte py (val) -> "isinstance(§, list)"
@ verte rs (val) -> "§.is_sequence()"
@ verte cpp (val) -> "§.IsSequence()"
@ externa
functio estLista(quidlibet val) -> bivalens

# Check if value is mapping (object/dict)
@ verte ts (val) -> "(typeof § === 'object' && § !== null && !Array.isArray(§))"
@ verte py (val) -> "isinstance(§, dict)"
@ verte rs (val) -> "§.is_mapping()"
@ verte cpp (val) -> "§.IsMap()"
@ externa
functio estTabula(quidlibet val) -> bivalens
