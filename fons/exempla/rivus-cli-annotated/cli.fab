# ═══════════════════════════════════════════════════════════════════════════════
# RIVUS - Bootstrap Faber Compiler CLI
# ═══════════════════════════════════════════════════════════════════════════════
#
# Multi-target compiler for bootstrap testing.
# Compiles Faber source to TypeScript, Go, or other targets.
#
# Usage:
#   rivus emit hello.fab                 # compile to stdout (default: ts)
#   rivus emit hello.fab -t go           # compile to Go
#   rivus emit hello.fab -o hello.ts     # compile to file
#   rivus build main.fab -o dist/        # build with dependencies
#   rivus parse hello.fab                # dump AST as JSON
#   rivus check hello.fab                # validate without codegen
#
# ═══════════════════════════════════════════════════════════════════════════════

# Commands
importa ex "./cli/commands/emit" privata emitCommand
importa ex "./cli/commands/build" privata buildCommand
importa ex "./cli/commands/parse" privata parseCommand
importa ex "./cli/commands/check" privata checkCommand
importa ex "./cli/commands/test" privata testCommand
importa ex "./cli/commands/fetch" privata mandatumArcessere
importa ex "./cli/commands/run" privata mandatumCurrere

@ cli "rivus"
@ versio "0.1.0"
@ descriptio "Bootstrap Faber compiler - compiles Faber source to TypeScript or Go"
incipit {}

# ─────────────────────────────────────────────────────────────────────────────
# version - show version
# ─────────────────────────────────────────────────────────────────────────────

@ imperium "version"
@ alias "v"
functio version() -> vacuum {
    scribe "rivus v0.1.0"
}

# ─────────────────────────────────────────────────────────────────────────────
# emit - compile single file to target language
# ─────────────────────────────────────────────────────────────────────────────

@ imperium "emit"
@ alias "compile"
@ descriptio "Emit code (warns on errors unless --strict)"
@ futura
@ optio textus target brevis "t" longum "target" descriptio "Target language: ts (default), go"
@ optio textus output brevis "o" longum "output" descriptio "Output file (default: stdout)"
@ optio textus include brevis "I" longum "include" descriptio "Add import search path"
@ optio textus manifest brevis "m" longum "manifest" descriptio "Project manifest file (faber.fab)"
@ optio textus stdinFilename longum "stdin-filename" descriptio "Filename for error messages when reading stdin"
@ optio bivalens json longum "json" descriptio "Output errors as JSON"
@ optio bivalens dryRun longum "dry-run" descriptio "Check without emitting code"
@ optio bivalens stripTests longum "strip-tests" descriptio "Strip probandum/proba test blocks from output"
@ optio bivalens stripComments longum "strip-comments" descriptio "Strip comments from output"
@ optio bivalens strict longum "strict" descriptio "Fail on semantic errors instead of warning"
functio emit(
    si textus input,
    si textus target,
    si textus output,
    si textus include,
    si textus manifest,
    si textus stdinFilename,
    si bivalens json,
    si bivalens dryRun,
    si bivalens stripTests,
    si bivalens stripComments,
    si bivalens strict
) exitus code -> vacuum {
    fixum result = cede emitCommand(input, target, output, include, manifest, stdinFilename, json, dryRun, stripTests, stripComments, strict)
    code = result
}

# ─────────────────────────────────────────────────────────────────────────────
# build - compile entry and dependencies to directory
# ─────────────────────────────────────────────────────────────────────────────

@ imperium "build"
@ alias "aedifica"
@ descriptio "Build entry file and all dependencies to output directory"
@ futura
@ optio textus target brevis "t" longum "target" descriptio "Target language: ts (default), go"
@ optio textus output brevis "o" longum "output" descriptio "Output directory (default: ./dist)"
@ optio textus include brevis "I" longum "include" descriptio "Add import search path"
@ optio textus manifest brevis "m" longum "manifest" descriptio "Project manifest file (faber.fab)"
@ optio bivalens json longum "json" descriptio "Output errors as JSON"
@ optio bivalens dryRun longum "dry-run" descriptio "Check without writing files"
@ optio bivalens listFiles longum "list-files" descriptio "List files that would be compiled"
@ optio bivalens stripComments longum "strip-comments" descriptio "Strip comments from output"
functio build(
    textus input,
    si textus target,
    si textus output,
    si textus include,
    si textus manifest,
    si bivalens json,
    si bivalens dryRun,
    si bivalens listFiles,
    si bivalens stripComments
) exitus code -> vacuum {
    fixum result = cede buildCommand(input, target, output, include, manifest, json, dryRun, listFiles, stripComments)
    code = result
}

# ─────────────────────────────────────────────────────────────────────────────
# parse - lex and parse, dump AST
# ─────────────────────────────────────────────────────────────────────────────

@ imperium "parse"
@ alias "ast"
@ descriptio "Parse source and dump AST as JSON (reads stdin if no input)"
@ futura
@ optio textus output brevis "o" longum "output" descriptio "Output file (default: stdout)"
@ optio textus stdinFilename longum "stdin-filename" descriptio "Filename for error messages when reading stdin"
@ optio bivalens compact longum "compact" descriptio "Output compact JSON (no indentation)"
functio parse(
    si textus input,
    si textus output,
    si textus stdinFilename,
    si bivalens compact
) exitus code -> vacuum {
    fixum result = cede parseCommand(input, output, stdinFilename, compact)
    code = result
}

# ─────────────────────────────────────────────────────────────────────────────
# check - validate without codegen
# ─────────────────────────────────────────────────────────────────────────────

@ imperium "check"
@ alias "proba"
@ descriptio "Validate source without codegen (reads stdin if no input)"
@ futura
@ optio textus output brevis "o" longum "output" descriptio "Write error report to file"
@ optio textus include brevis "I" longum "include" descriptio "Add import search path"
@ optio textus manifest brevis "m" longum "manifest" descriptio "Project manifest file (faber.fab)"
@ optio textus stdinFilename longum "stdin-filename" descriptio "Filename for error messages when reading stdin"
@ optio bivalens json longum "json" descriptio "Output errors as JSON"
@ optio bivalens strict longum "strict" descriptio "Enable all strict checks"
functio check(
    si textus input,
    si textus output,
    si textus include,
    si textus manifest,
    si textus stdinFilename,
    si bivalens json,
    si bivalens strict
) exitus code -> vacuum {
    fixum result = cede checkCommand(input, output, include, manifest, stdinFilename, json, strict)
    code = result
}

# ─────────────────────────────────────────────────────────────────────────────
# test - compile and run tests with standalone harness
# ─────────────────────────────────────────────────────────────────────────────

@ imperium "test"
@ alias "probandum"
@ descriptio "Compile and run tests with standalone harness"
@ futura
@ optio textus target brevis "t" longum "target" descriptio "Target language: ts (default)"
@ optio textus tag longum "tag" descriptio "Run only tests with this tag"
@ optio textus exclude longum "exclude" descriptio "Exclude tests with this tag"
@ optio textus stdinFilename longum "stdin-filename" descriptio "Filename to use for stdin input"
@ optio bivalens json longum "json" descriptio "Output errors as JSON"
@ optio bivalens dryRun longum "dry-run" descriptio "Compile only, don't execute"
@ optio bivalens solo longum "only" descriptio "Run only tests marked @ solum"
functio test(
    textus input,
    si textus target,
    si textus tag,
    si textus exclude,
    si textus stdinFilename,
    si bivalens json,
    si bivalens dryRun,
    si bivalens solo
) exitus code -> vacuum {
    fixum result = cede testCommand(input, target, tag, exclude, stdinFilename, json, dryRun, solo)
    code = result
}

# ─────────────────────────────────────────────────────────────────────────────
# fetch - download and cache GitHub dependencies
# ─────────────────────────────────────────────────────────────────────────────

@ imperium "fetch"
@ descriptio "Download and cache GitHub dependencies from manifest"
@ futura
@ optio textus manifest brevis "m" longum "manifest" descriptio "Project manifest file (faber.fab)"
@ optio bivalens force brevis "f" longum "force" descriptio "Re-fetch even if cached"
@ optio bivalens json longum "json" descriptio "Output as JSON"
functio fetch(
    si textus manifest,
    si bivalens force,
    si bivalens json
) exitus code -> vacuum {
    fixum result = cede mandatumArcessere(manifest, force, json)
    code = result
}

# ─────────────────────────────────────────────────────────────────────────────
# run - execute build scripts from manifest
# ─────────────────────────────────────────────────────────────────────────────

@ imperium "run"
@ descriptio "Execute build scripts registered via § scriptum"
@ futura
@ optio textus manifest brevis "m" longum "manifest" descriptio "Project manifest file (default: faber.fab)"
@ optio bivalens list brevis "l" longum "list" descriptio "List available scripts"
@ optio bivalens json longum "json" descriptio "Output as JSON"
functio run(
    si textus script,
    si textus manifest,
    si bivalens list,
    si bivalens json
) exitus code -> vacuum {
    # TODO: arg forwarding - for now, pass empty list
    varia scriptArgs = [] innatum lista<textus>
    fixum result = cede mandatumCurrere(script, manifest, list, json, scriptArgs)
    code = result
}
