# ═══════════════════════════════════════════════════════════════════════════════
# EMIT - Emit Faber source as target language (fast, warns on errors)
# ═══════════════════════════════════════════════════════════════════════════════
#
# Pipeline: lex -> parse -> semantic -> codegen
# Warns on semantic errors but continues to emit code.
# Use 'compile' command to fail on errors.
#
# Usage:
#   rivus emit                           # stdin -> stdout (default: ts)
#   rivus emit hello.fab                 # file -> stdout
#   rivus emit hello.fab -t go           # emit as Go
#   rivus emit hello.fab -o hello.ts     # file -> file
#   echo 'scribe "hi"' | rivus emit      # pipe works naturally
#   rivus emit --stdin-filename=foo.fab  # stdin with filename for errors
#   rivus emit hello.fab --dry-run       # check without emitting
#   rivus emit hello.fab --json          # errors as JSON
#
# ═══════════════════════════════════════════════════════════════════════════════

§ ex "../rivus/lexor/index" importa lexare
§ ex "../rivus/parser/index" importa resolvere
§ ex "../rivus/semantic/index" importa analyze
§ ex "../rivus/codegen/index" importa generate, generateWithStripping
§ ex "../rivus/ast/radix" importa Programma

§ ex "../../norma/hal/solum" importa solum
§ ex "../../norma/hal/consolum" importa consolum
§ ex "../../norma/hal/json" importa json

§ ex "../auxilium" importa hauriSource, nomenOstende, validaInput, loadManifestSectiones

# ═══════════════════════════════════════════════════════════════════════════════
# EMIT COMMAND
# ═══════════════════════════════════════════════════════════════════════════════

@ publica
@ futura
functio emitCommand(
    si textus input,
    si textus target,
    si textus output,
    si textus include,
    si textus manifest,
    si textus stdinFilename,
    si bivalens jsonOutput,
    si bivalens dryRun,
    si bivalens stripTests,
    si bivalens stripComments,
    si bivalens strict
) -> numerus {
    fixum targetLang = target vel "ts"
    fixum displayName = stdinFilename vel nomenOstende(input)
    fixum estStdin = nihil input aut input == "-"

    # Validate input exists
    custodi {
        si non validaInput(input) {
            si jsonOutput {
                consolum.fundeLineam(json.solve({ error: scriptum("File not found: §", input) }))
            }
            secus {
                mone "File not found: §", input
            }
            redde 1
        }
    }

    figendum source = hauriSource(input)

    # Collect errors for potential JSON output
    varia errores = [] innatum lista<tabula<textus, ignotum>>

    # Lexical analysis
    fixum lexResult = lexare(source)

    si positivum lexResult.errores.longitudo() {
        si jsonOutput {
            ex lexResult.errores fixum err {
                errores.push({
                    phase: "lexor",
                    file: displayName,
                    line: err.locus.linea,
                    column: err.locus.columna,
                    message: err.textus
                } innatum tabula<textus, ignotum>)
            }
        }
        secus {
            mone "Lexor errors:"
            ex lexResult.errores fixum err {
                mone "  §:§:§ - §", displayName, err.locus.linea, err.locus.columna, err.textus
            }
        }
        si jsonOutput {
            consolum.fundeLineam(json.solve({ errors: errores }))
        }
        redde 1
    }

    # Parsing
    fixum parseResult = resolvere(lexResult.symbola)

    si positivum parseResult.errores.longitudo() {
        si jsonOutput {
            ex parseResult.errores fixum err {
                errores.push({
                    phase: "parser",
                    file: displayName,
                    line: err.locus.linea,
                    column: err.locus.columna,
                    message: err.nuntius
                } innatum tabula<textus, ignotum>)
            }
        }
        secus {
            mone "Parser errors:"
            ex parseResult.errores fixum err {
                mone "  §:§:§ - §", displayName, err.locus.linea, err.locus.columna, err.nuntius
            }
        }
        si jsonOutput {
            consolum.fundeLineam(json.solve({ errors: errores }))
        }
        redde 1
    }

    si nihil parseResult.programma {
        si jsonOutput {
            consolum.fundeLineam(json.solve({ error: "Failed to parse program" }))
        }
        secus {
            mone "Failed to parse program"
        }
        redde 1
    }

    # Load manifest sectiones if provided
    figendum manifestSectiones = loadManifestSectiones(manifest)

    # Semantic analysis
    fixum viaIngressus = estStdin sic nihil secus solum.absolve(input qua textus)
    fixum semResult = analyze(parseResult.programma qua Programma, viaIngressus, manifestSectiones)

    # Handle semantic errors: strict mode fails, emit mode warns and continues
    si positivum semResult.errores.longitudo() {
        si strict {
            # Strict mode (compile command): fail on errors
            si jsonOutput {
                ex semResult.errores fixum err {
                    errores.push({
                        phase: "semantic",
                        file: displayName,
                        line: err.locus.linea,
                        column: err.locus.columna,
                        message: err.nuntius
                    } innatum tabula<textus, ignotum>)
                }
                consolum.fundeLineam(json.solve({ errors: errores }))
            } secus {
                mone "Semantic errors:"
                ex semResult.errores fixum err {
                    mone "  §:§:§ - §", displayName, err.locus.linea, err.locus.columna, err.nuntius
                }
            }
            redde 1
        } secus {
            # Emit mode: warn but continue
            si jsonOutput {
                ex semResult.errores fixum err {
                    errores.push({
                        phase: "semantic",
                        file: displayName,
                        line: err.locus.linea,
                        column: err.locus.columna,
                        message: err.nuntius
                    } innatum tabula<textus, ignotum>)
                }
                consolum.errorLineam(json.solve({ warnings: errores }))
            } secus {
                mone "Semantic warnings (use --strict to fail):"
                ex semResult.errores fixum err {
                    mone "  §:§:§ - §", displayName, err.locus.linea, err.locus.columna, err.nuntius
                }
            }
        }
    }

    # Dry run stops here
    si dryRun {
        si jsonOutput {
            consolum.fundeLineam(json.solve({ success: verum, file: displayName }))
        }
        secus {
            scribe "§: OK", displayName
        }
        redde 0
    }

    # Code generation
    varia generated = ""
    si stripTests vel stripComments {
        generated = generateWithStripping((parseResult.programma qua Programma).corpus, targetLang, stripTests, stripComments)
    } secus {
        generated = generate((parseResult.programma qua Programma).corpus, targetLang)
    }

    # Output
    si output {
        cede solum.scribe(output, generated)
        si non jsonOutput {
            mone "Compiled: § -> §", displayName, output
        }
    }
    secus {
        consolum.fundeTextum(generated)
    }

    redde 0
}
