# RIVUS - Bootstrap Faber Compiler CLI
#
# Multi-target compiler for bootstrap testing.
# Compiles Faber source to TypeScript, Go, or other targets.
#
# Usage:
#   rivus emit hello.fab                 # compile to stdout (default: ts)
#   rivus emit hello.fab -t go           # compile to Go
#   rivus emit hello.fab -o hello.ts     # compile to file
#   rivus build main.fab -o dist/        # build with dependencies
#   rivus parse hello.fab                # dump AST as JSON
#   rivus check hello.fab                # validate without codegen

# Runtime globals
@ externa
fixum ignotum process

# Command implementations
§ ex "./commands/emit" importa emitCommand
§ ex "./commands/build" importa buildCommand
§ ex "./commands/parse" importa parseCommand
§ ex "./commands/check" importa checkCommand
§ ex "./commands/test" importa testCommand
§ ex "./commands/fetch" importa mandatumArcessere
§ ex "./commands/run" importa mandatumCurrere

fixum VERSION = "0.1.0"

fixum HELP_TEXT = """
rivus - Bootstrap Faber compiler

Usage:
  rivus <command> [options] [input]

Commands:
  emit, compile    Emit code (warns on errors unless --strict)
  build, aedifica  Build entry file and all dependencies to output directory
  parse, ast       Parse source and dump AST as JSON
  check, proba     Validate source without codegen
  test, probandum  Compile and run tests with standalone harness
  fetch            Download and cache GitHub dependencies from manifest
  run              Execute build scripts registered via @ scriptum
  version, v       Show version
  help, -h         Show this help

Options (vary by command):
  -t, --target <lang>      Target language: ts (default), go
  -o, --output <path>      Output file or directory
  -I, --include <path>     Add import search path
  -m, --manifest <file>    Project manifest file (faber.fab)
  --stdin-filename <name>  Filename for error messages when reading stdin
  --json                   Output as JSON
  --dry-run                Check without emitting/writing
  --strict                 Fail on semantic errors (emit/check)
  --strip-tests            Strip probandum/proba blocks (emit)
  --strip-comments         Strip comments (emit/build)
  --compact                Compact JSON output (parse)
  --list-files             List files that would be compiled (build)
  --tag <tag>              Run only tests with this tag (test)
  --exclude <tag>          Exclude tests with this tag (test)
  --only                   Run only tests marked @ solum (test)
  -f, --force              Re-fetch even if cached (fetch)
  -l, --list               List available scripts (run)
"""

@ futura
functio main() -> vacuum {
    fixum args = process.argv.slice(2) qua lista<textus>

si args.length == 0 {
    scribe HELP_TEXT
    process.exit(0)
}

fixum command = args[0]

# Help and version shortcuts
si command == "-h" aut command == "--help" aut command == "help" {
    scribe HELP_TEXT
    process.exit(0)
}

si command == "-v" aut command == "--version" aut command == "version" aut command == "v" {
    scribe scriptum("rivus v§", VERSION)
    process.exit(0)
}

# Parse remaining arguments into options
varia input = nihil qua textus?
varia target = nihil qua textus?
varia output = nihil qua textus?
varia include = nihil qua textus?
varia manifest = nihil qua textus?
varia stdinFilename = nihil qua textus?
varia tag = nihil qua textus?
varia exclude = nihil qua textus?
varia script = nihil qua textus?

varia jsonOutput = falsum
varia dryRun = falsum
varia stripTests = falsum
varia stripComments = falsum
varia strict = falsum
varia compact = falsum
varia listFiles = falsum
varia solo = falsum
varia force = falsum
varia list = falsum

# Parse flags and positional arguments
varia i = 1
dum i < args.length {
    fixum arg = args[i] qua textus

    si arg == "-t" aut arg == "--target" {
        i += 1
        target = args[i]
    } secus si arg == "-o" aut arg == "--output" {
        i += 1
        output = args[i]
    } secus si arg == "-I" aut arg == "--include" {
        i += 1
        include = args[i]
    } secus si arg == "-m" aut arg == "--manifest" {
        i += 1
        manifest = args[i]
    } secus si arg == "--stdin-filename" {
        i += 1
        stdinFilename = args[i]
    } secus si arg == "--tag" {
        i += 1
        tag = args[i]
    } secus si arg == "--exclude" {
        i += 1
        exclude = args[i]
    } secus si arg == "--json" {
        jsonOutput = verum
    } secus si arg == "--dry-run" {
        dryRun = verum
    } secus si arg == "--strip-tests" {
        stripTests = verum
    } secus si arg == "--strip-comments" {
        stripComments = verum
    } secus si arg == "--strict" {
        strict = verum
    } secus si arg == "--compact" {
        compact = verum
    } secus si arg == "--list-files" {
        listFiles = verum
    } secus si arg == "--only" {
        solo = verum
    } secus si arg == "-f" aut arg == "--force" {
        force = verum
    } secus si arg == "-l" aut arg == "--list" {
        list = verum
    } secus si non (arg.startsWith("-")) {
        # Positional argument
        si nihil input {
            input = arg
        } secus si nihil script {
            # For 'run' command, second positional is script name
            script = input
            input = nihil
        }
    } secus {
        mone scriptum("Unknown option: §", arg)
        process.exit(1)
    }

    i += 1
}

# Dispatch to command
varia exitCode = 0

si command == "emit" aut command == "compile" {
    exitCode = cede emitCommand(input, target, output, include, manifest, stdinFilename, jsonOutput, dryRun, stripTests, stripComments, strict)
} secus si command == "build" aut command == "aedifica" {
    si nihil input {
        mone "build requires an input file"
        process.exit(1)
    }
    exitCode = cede buildCommand(input, target, output, include, manifest, jsonOutput, dryRun, listFiles, stripComments)
} secus si command == "parse" aut command == "ast" {
    exitCode = cede parseCommand(input, output, stdinFilename, compact)
} secus si command == "check" aut command == "proba" {
    exitCode = cede checkCommand(input, output, include, manifest, stdinFilename, jsonOutput, strict)
} secus si command == "test" aut command == "probandum" {
    si nihil input {
        mone "test requires an input file"
        process.exit(1)
    }
    exitCode = cede testCommand(input, target, tag, exclude, stdinFilename, jsonOutput, dryRun, solo)
} secus si command == "fetch" {
    exitCode = cede mandatumArcessere(manifest, force, jsonOutput)
} secus si command == "run" {
    fixum scriptName = script vel input
    varia scriptArgs = [] innatum lista<textus>
    exitCode = cede mandatumCurrere(scriptName, manifest, list, jsonOutput, scriptArgs)
} secus {
    mone scriptum("Unknown command: §", command)
    scribe HELP_TEXT
    process.exit(1)
}

process.exit(exitCode)
}

main()
