# Resolvitor - Parser Interface for Mutual Recursion
#
# Solves mutual recursion between expression and statement parsers.
# Each parsing function receives a Resolvitor instead of raw Parser,
# and calls methods for cross-module parsing.
#
# WHY: Expression parsers need to parse blocks (for lambdas), and
#      statement parsers need to parse expressions. This creates
#      circular imports. By using a pactum (interface), each module
#      depends only on Resolvitor, not on each other.
#
# The concrete implementation (ResolvitorImpl) is defined in index.fab,
# which imports all the actual parsing functions.
#
# LATIN: resolvitor = "one who resolves/parses"

importa ex "./nucleus" privata Parser
importa ex "../ast/expressia" privata Expressia
importa ex "../ast/sententia" privata Sententia
importa ex "../ast/sententia" privata MassaSententia
importa ex "../ast/typus" privata TypusAnnotatio

# Parser interface for cross-module parsing.
#
# Usage in parsing functions:
#   functio parseFoo(Resolvitor r) -> Foo {
#       fixum p = r.parser()           # get parser state
#       fixum expr = r.expressia()     # parse expression
#       fixum block = r.massa()        # parse block
#       fixum typ = r.adnotatio()      # parse type annotation
#       ...
#   }
@ publica
pactum Resolvitor {
    # Get the underlying parser state
    functio parser() -> Parser

    # Parse an expression (handles precedence)
    functio expressia() -> Expressia

    # Parse a single statement
    functio sententia() -> Sententia

    # Parse a block of statements (MassaSententia)
    functio massa() -> MassaSententia

    # Parse a type annotation
    functio adnotatio() -> TypusAnnotatio
}
