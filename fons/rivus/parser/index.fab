# Parser - Recursive Descent Parser for Latin Source Code
#
# COMPILER PHASE: Syntactic
#
# Transforms token stream from lexical analyzer into Abstract Syntax Tree.
# Uses predictive parsing with one token of lookahead.
#
# INVARIANTS:
# - Never throws exceptions - collects errors and continues
# - Synchronizes at statement boundaries after errors
# - All AST nodes include position for error reporting
# - Empty input produces valid Program with empty body
#
# LATIN VOCABULARY:
# - parse = resolvere (to resolve/analyze)
# - resultatum = result
# - programma = program
# - errores = errors

importa ex "./nucleus" privata Parser
importa ex "./nucleus" privata novumParser
importa ex "./errores" privata ParserError
importa ex "./errores" privata ParserErrorCodice
importa ex "./resolvitor" privata Resolvitor
importa ex "../ast/positio" privata Locus
importa ex "../ast/expressia" privata Expressia
importa ex "../ast/sententia" privata Sententia
importa ex "../ast/sententia" privata MassaSententia
importa ex "../ast/typus" privata TypusAnnotatio
importa ex "../ast/lexema" privata Symbolum
importa ex "../ast/radix" privata Programma

# Import parsing functions
importa ex "./sententia/massa" privata parseProgramma
importa ex "./sententia/massa" privata parseMassaSententia
importa ex "./sententia/index" privata parseSententia
importa ex "./expressia/binaria" privata parseAssignatio
importa ex "./typus" privata parseTypusAnnotatio

# Result of parsing
@ publica
genus ParserResultatum {
    si Programma programma        # AST root (nil on catastrophic failure)
    lista<ParserError> errores  # Parse errors encountered
}

# Parsator - concrete implementation of pactum Resolvitor
#
# Wires up all parsing functions so they can call each other
# through the Resolvitor interface without circular imports.
#
# LATIN: parsator = "one who parses" (agent noun)
@ publica
genus Parsator implet Resolvitor {
    Parser p

    @ publica
    functio parser() -> Parser {
        redde ego.p
    }

    @ publica
    functio expressia() -> Expressia {
        # Full expression parser starting at assignment (highest precedence entry)
        redde parseAssignatio(ego)
    }

    @ publica
    functio sententia() -> Sententia {
        # Statement dispatcher routes to appropriate parser
        redde parseSententia(ego)
    }

    @ publica
    functio massa() -> MassaSententia {
        # Parse block statement
        redde parseMassaSententia(ego)
    }

    @ publica
    functio adnotatio() -> TypusAnnotatio {
        # Parse type annotation
        redde parseTypusAnnotatio(ego)
    }
}

# Create a new Parsator
@ publica
functio novumParsator(in Parser p) -> Parsator {
    redde novum Parsator { p: p }
}

# Parse a token stream into an AST
#
# Main entry point for the parser.
# Creates a Parser instance and parses the program.
@ publica
functio resolvere(ex lista<Symbolum> symbola) -> ParserResultatum {
    # Create parser state
    fixum p = novumParser(symbola)

    # Create Parsator to wire up parsing functions
    fixum r = novumParsator(p)

    # Parse the program
    # NOTE: No try/catch here. The parser collects errors in p.errores rather than
    # throwing. Any panic (mori) indicates a bug that should crash, not be swallowed.
    # This keeps rivus Go-compilable (no exception handling translation needed).
    fixum programma = parseProgramma(r)

    redde {
        programma: programma,
        errores: p.errores
    } novum ParserResultatum
}
