# Morphologia - Latin Verb Conjugation Parser
#
# Parses Latin verb endings to derive semantic flags for collection methods.
# The morphology determines: mutation, async, allocation.
#
# WHY: Latin grammar as semantic machinery. The verb conjugation encodes
#      behavior that would otherwise require separate method definitions.

# ============================================================================
# TYPES
# ============================================================================

# Semantic flags derived from verb morphology
@ publica
genus MorphologiaFlagga {
    bivalens mutare           # Modifies receiver in place
    bivalens async            # Returns Promise
    bivalens reddeNovum       # Returns new collection (allocates)
    bivalens allocatio        # Needs allocator (Zig target)
}

# Result of parsing a method name
@ publica
genus RadixEtFlagga {
    textus radix              # Verb stem (e.g., "filtr", "add", "ordin")
    MorphologiaFlagga flagga
}

# Map semantic flags to canonical form name
@ publica
functio formaExFlagga(de MorphologiaFlagga flagga) -> textus {
    si flagga.mutare et non flagga.async et non flagga.reddeNovum {
        redde "imperativus"
    }
    si non flagga.mutare et non flagga.async et flagga.reddeNovum {
        redde "perfectum"
    }
    si flagga.mutare et flagga.async et non flagga.reddeNovum {
        redde "futurum_indicativum"
    }
    si non flagga.mutare et flagga.async et flagga.reddeNovum {
        redde "futurum_activum"
    }
    redde "ignotum"
}

# ============================================================================
# FLAG CONSTANTS
# ============================================================================

# Imperative: adde, filtra, ordina - mutates in place, sync
fixum FLAGGA_IMPERATIVUS = {
    mutare: verum,
    async: falsum,
    reddeNovum: falsum,
    allocatio: falsum
} novum MorphologiaFlagga

# Perfect passive participle: addita, filtrata, ordinata - returns new, sync
fixum FLAGGA_PERFECTUM = {
    mutare: falsum,
    async: falsum,
    reddeNovum: verum,
    allocatio: verum
} novum MorphologiaFlagga

# Future active participle: additura, filtratura - returns new, async
fixum FLAGGA_FUTURUM_ACTIVUM = {
    mutare: falsum,
    async: verum,
    reddeNovum: verum,
    allocatio: verum
} novum MorphologiaFlagga

# Future indicative: addet, filtrabit - mutates, async
fixum FLAGGA_FUTURUM_INDICATIVUM = {
    mutare: verum,
    async: verum,
    reddeNovum: falsum,
    allocatio: falsum
} novum MorphologiaFlagga

# ============================================================================
# MORPHOLOGY PARSER
# ============================================================================

# Parse a method name to extract verb stem and semantic flags
#
# WHY: Longest-first matching prevents false positives from suffix overlap.
#   "filtratura" must match -atura (5), not -ura (3) or -a (1).
#   Without this, "filtratura" would parse as stem "filtratur" + imperative -a,
#   yielding wrong semantics (sync mutate vs async return-new).
#
# WHY: The specific character boundaries (5,4,3,2,1) derive from Latin morphology:
#   - 5 chars: -atura/-itura (future active participle, async + allocates)
#   - 4 chars: -abit/-ebit (future indicative, async + mutates)
#   - 3 chars: -ata/-ita/-iet (perfect participle / 3rd conj future)
#   - 2 chars: -ta/-sa (contracted participles like inversus → invers-a)
#   - 1 char:  -a/-e/-i (imperative, the default sync-mutate form)
#
# WHY: Check length before substring extraction:
#   "si longitudo > N" guards against stems that would be empty or negative.
#   A 4-char word can't have a 5-char suffix and meaningful stem.
#
# Edge cases:
#   - Words < 2 chars return nihil (no stem possible)
#   - Unrecognized endings return nihil (caller handles fallback)
#   - No disambiguation of homophonous endings (context-free parse)
#
# Returns nihil if no recognized morphology.
@ publica
functio parseMethodum(de textus nomen) -> RadixEtFlagga? {
    fixum longitudo = nomen.longitudo()

    # Need at least 2 chars (1 stem + 1 ending)
    si longitudo < 2 {
        redde nihil
    }

    # Future active participle: -atura, -itura (async, returns new)
    si longitudo > 5 {
        fixum suffix5 = nomen.sectio(longitudo - 5, longitudo)
        si suffix5 == "atura" aut suffix5 == "itura"
            reddit { radix: nomen.sectio(0, longitudo - 5), flagga: FLAGGA_FUTURUM_ACTIVUM } novum RadixEtFlagga
    }

    # Future indicative: -abit, -ebit (async, mutates)
    si longitudo > 4 {
        fixum suffix4 = nomen.sectio(longitudo - 4, longitudo)
        si suffix4 == "abit" aut suffix4 == "ebit"
            reddit { radix: nomen.sectio(0, longitudo - 4), flagga: FLAGGA_FUTURUM_INDICATIVUM } novum RadixEtFlagga
    }

    # Also check -iet for 3rd conjugation futures
    si longitudo > 3 {
        fixum suffix3 = nomen.sectio(longitudo - 3, longitudo)
        si suffix3 == "iet"
            reddit { radix: nomen.sectio(0, longitudo - 3), flagga: FLAGGA_FUTURUM_INDICATIVUM } novum RadixEtFlagga
    }

    # Perfect passive participle: -ata, -ita, -ta (sync, returns new)
    si longitudo > 3 {
        fixum suffix3 = nomen.sectio(longitudo - 3, longitudo)
        si suffix3 == "ata" aut suffix3 == "ita"
            reddit { radix: nomen.sectio(0, longitudo - 3), flagga: FLAGGA_PERFECTUM } novum RadixEtFlagga
    }

    # Check 2-char endings: -ta, -sa (some participles)
    # WHY: 3rd conjugation verbs like invertere → inversus have -sa participle
    si longitudo > 2 {
        fixum suffix2 = nomen.sectio(longitudo - 2, longitudo)
        si suffix2 == "ta" aut suffix2 == "sa"
            reddit { radix: nomen.sectio(0, longitudo - 2), flagga: FLAGGA_PERFECTUM } novum RadixEtFlagga
    }

    # Imperative: -a, -e, -i (sync, mutates)
    fixum ultimum = nomen.sectio(longitudo - 1, longitudo)
    si ultimum == "a" aut ultimum == "e" aut ultimum == "i"
        reddit { radix: nomen.sectio(0, longitudo - 1), flagga: FLAGGA_IMPERATIVUS } novum RadixEtFlagga

    # No recognized morphology
    redde nihil
}

# Check if a stem is a known lista verb
@ publica
functio estRadixListae(de textus radix) -> bivalens {
    # Core action verbs for lista operations
    # WHY: Some verbs have different stems for different conjugations.
    #      e.g., invertere → invert- (present), invers- (perfect participle)
    elige radix {
        casu "add" reddit verum       # add element
        casu "praepon" reddit verum   # prepend
        casu "praepos" reddit verum   # prepend (participle stem)
        casu "remov" reddit verum     # remove last
        casu "decapit" reddit verum   # remove first
        casu "filtr" reddit verum     # filter
        casu "mapp" reddit verum      # map/transform
        casu "ordin" reddit verum     # sort
        casu "invert" reddit verum    # reverse (present: inverte)
        casu "invers" reddit verum    # reverse (participle: used by -ita forms)
        casu "inver" reddit verum     # reverse (participle: inversa with -sa ending)
        ceterum reddit falsum
    }
}
