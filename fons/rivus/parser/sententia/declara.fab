# Declaration Statement Parsers
#
# Handles: functio, genus, pactum, ordo, discretio, typus, importa
#
# GRAMMAR:
#   functioDecl := 'functio' IDENT '(' params? ')' returnType? blockStmt
#   genusDecl := 'genus' IDENT genericParams? ('sub' IDENT)? ('implet' IDENT+)? '{' members '}'
#   pactumDecl := 'pactum' IDENT genericParams? '{' methods '}'
#   ordoDecl := 'ordo' IDENT '{' members '}'
#   discretioDecl := 'discretio' IDENT genericParams? '{' variants '}'
#   typusDecl := 'typus' IDENT '=' type
#   importaDecl := 'ex' STRING 'importa' specifiers
#
# LATIN VOCABULARY:
# - functio = function
# - genus = kind/class/struct
# - pactum = agreement/interface
# - ordo = order/enum
# - discretio = distinction/tagged union
# - typus = type alias
# - importa = import

importa ex "../resolvitor" privata Resolvitor
importa ex "../../ast/positio" privata Locus
importa ex "../../ast/expressia" privata Expressia
importa ex "../../ast/sententia" privata Sententia
importa ex "../../ast/sententia" privata MassaSententia
importa ex "../../ast/sententia" privata FunctioDeclaratio
importa ex "../../ast/sententia" privata Parametrum
importa ex "../../ast/sententia" privata TypusParametrum
importa ex "../../ast/sententia" privata CampusDeclaratio
importa ex "../../ast/sententia" privata PactumMethodus
importa ex "../../ast/sententia" privata OrdoMembrum
importa ex "../../ast/sententia" privata VariansDeclaratio
importa ex "../../ast/sententia" privata VariansCampus
importa ex "../../ast/sententia" privata Visibilitas
importa ex "../../ast/sententia" privata ReddeVerbum
importa ex "../../ast/sententia" privata ImportaSpecificator
importa ex "../../ast/sententia" privata MorphologiaDeclaratio
importa ex "../../ast/sententia" privata FunctioModificator
importa ex "../../ast/sententia" privata OptionesModificator
importa ex "../../ast/sententia" privata ExitusModificator
importa ex "../../ast/typus" privata TypusAnnotatio
importa ex "../../ast/typus" privata typusSimplicis
importa ex "../../ast/lexema" privata SymbolumGenus
importa ex "../../ast/lexema" privata VerbumId
importa ex "../errores" privata ParserErrorCodice
importa ex "./massa" privata parseMassaSententia
importa ex "./varia" privata parseNomenVelVerbum
importa ex "../../ast/annotatio" privata Annotatio
importa ex "./annotatio" privata parseAnnotationes

# ============================================================================
# FUNCTION DECLARATIONS
# ============================================================================

# Parse post-parameter function modifiers
functio parseFunctioModificatores(in Resolvitor r) -> lista<FunctioModificator> {
    fixum p = r.parser()
    varia lista<FunctioModificator> modificatores = []

    dum verum {
        si p.congruetVerbum("curata") {
            fixum locus = p.praevius().locus
            fixum curatorSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
            modificatores.appende(finge CurataModificator { locus: locus, nomen: curatorSym.valor } qua FunctioModificator)
        } sin p.congruetVerbum("errata") {
            fixum locus = p.praevius().locus
            fixum errataSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
            modificatores.appende(finge ErrataModificator { locus: locus, nomen: errataSym.valor } qua FunctioModificator)
        } sin p.congruetVerbum("immutata") {
            fixum locus = p.praevius().locus
            modificatores.appende(finge ImmutataModificator { locus: locus } qua FunctioModificator)
        } sin p.congruetVerbum("iacit") {
            fixum locus = p.praevius().locus
            modificatores.appende(finge IacitModificator { locus: locus } qua FunctioModificator)
        } sin p.congruetVerbum("optiones") {
            # Bundle all @ optio annotations into a Map<string, string> named <name>
            fixum locus = p.praevius().locus
            fixum optionesSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
            modificatores.appende(finge OptionesModificator { locus: locus, nomen: optionesSym.valor } qua FunctioModificator)
        } sin p.congruetVerbum("exitus") {
            # Exit code modifier: exitus <name> -> sets process.exit(<name>) at function end
            fixum locus = p.praevius().locus
            fixum exitusSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
            modificatores.appende(finge ExitusModificator { locus: locus, nomen: exitusSym.valor } qua FunctioModificator)
        } secus {
            rumpe
        }
    }

    redde modificatores
}

# Parse function declaration
#
# GRAMMAR:
#   functioDecl := 'functio' IDENT genericParams? '(' params? ')' funcModifier* returnType? blockStmt?
#   funcModifier := 'curata' IDENT | 'errata' IDENT | 'exitus' IDENT | 'immutata' | 'iacit' | 'optiones' IDENT
#   returnType := '->' type
#
# NOTE: fit/fiet/fiunt/fient return syntax is disabled pending Go/Zig backend support.
#
# Examples:
#   functio salve() { scribe "hello" }
#   functio add(numerus a, numerus b) -> numerus { redde a + b }
@ publica
functio parseFunctioDeclaratio(in Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'functio'
    p.expectaVerbum("functio", ParserErrorCodice.ExpectaturFunctio)

    # Parse function name
    fixum nomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
    fixum nomen = nomenSym.valor

    # Optional generic parameters: either `prae typus T, U` or `<T, U>`
    varia lista<TypusParametrum> generaParametra = []
    si p.probaVerbum("prae") {
        generaParametra = parseTypusParametra(r)
    } sin p.congruet(SymbolumGenus.Minor) {
        fixum nomina = parseGenericaNomina(r)
        itera ex nomina fixum n {
            generaParametra.appende({ locus: locus, nomen: n } qua TypusParametrum)
        }
    }

    # Parse parameters
    p.expecta(SymbolumGenus.ParensSin, ParserErrorCodice.ExpectaturParensSin)

    # Optional generic parameters inside parameter list: (prae typus T, ...)
    varia parenGenera = [] innatum lista<TypusParametrum>
    dum p.probaVerbum("prae") {
        p.procede()
        p.expectaVerbum("typus", ParserErrorCodice.ExpectaturTypus)

        fixum paramLocus = p.locusActualis()
        fixum nomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
        parenGenera.appende({
            locus: paramLocus,
            nomen: nomenSym.valor
        } qua TypusParametrum)

        si p.congruet(SymbolumGenus.Coma) {
            si p.probaVerbum("prae") {
                perge
            }
        }
        rumpe
    }

    si parenGenera.longitudo() > 0 {
        si generaParametra.longitudo() == 0 {
            generaParametra = parenGenera
        } secus {
            itera ex parenGenera fixum g {
                generaParametra.appende(g)
            }
        }
    }

    fixum parametra = parseParametra(r)
    p.expecta(SymbolumGenus.ParensDex, ParserErrorCodice.ExpectaturParensDex)

    varia modificatores = parseFunctioModificatores(r)

    # Parse return type
    varia typusReditus = nihil qua si TypusAnnotatio
    varia asynca = falsum
    varia generator = falsum
    varia reddeVerbum = nihil qua si ReddeVerbum

    # NOTE: fit/fiet/fiunt/fient return syntax is disabled pending Go/Zig backend support.
    # The Responsum protocol machinery remains in codegen but is dormant until re-enabled here.
    # When re-enabling, restore: VerbumId.Fit, VerbumId.Fiet, VerbumId.Fiunt, VerbumId.Fient
    si p.congruet(SymbolumGenus.Sagitta) {
        reddeVerbum = ReddeVerbum.Sagitta
        typusReditus = r.adnotatio()
    }

    # Parse body (optional for @ externa declarations)
    # WHY: Body is optional for @ externa declarations (external functions have no body)
    # If no opening brace, function has no body (validated in semantic phase)
    varia corpus = nihil qua si MassaSententia
    si p.proba(SymbolumGenus.UncusSin) {
        corpus = parseMassaSententia(r) qua MassaSententia
    }

    redde finge FunctioDeclaratio {
        locus: locus,
        nomen: nomen,
        generaParametra: generaParametra,
        parametra: parametra,
        typusReditus: typusReditus,
        corpus: corpus,
        asynca: asynca,
        generator: generator,
        abstracta: falsum,
        structor: falsum,
        externa: falsum,
        visibilitas: nihil,
        reddeVerbum: reddeVerbum,
        morphologia: nihil,
        modificatores: modificatores,
        annotationes: nihil
    } qua Sententia
}

# ============================================================================
# GENUS (CLASS/STRUCT) DECLARATIONS
# ============================================================================

# Parse genus (class/struct) declaration
#
# GRAMMAR:
#   genusDecl := 'genus' IDENT genericParams? ('sub' IDENT)? ('implet' IDENT+)? '{' members '}'
#
# Examples:
#   genus Persona { textus nomen, numerus aetas }
#   genus Cursor<T> { varia index = 0 }
#   genus Admin sub Persona implet Serializable { ... }
@ publica
functio parseGenusDeclaratio(in Resolvitor r, bivalens abstractum) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'genus'
    p.expectaVerbum("genus", ParserErrorCodice.ExpectaturGenus)

    # Parse name
    fixum nomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
    fixum nomen = nomenSym.valor

    # Optional generic parameters
    varia lista<textus> generaParametra = []
    si p.congruet(SymbolumGenus.Minor) {
        generaParametra = parseGenericaNomina(r)
    }

    # Optional extends
    varia extendit = nihil qua si textus
    si p.congruetVerbum("sub") {
        fixum parentSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
        extendit = parentSym.valor
    }

    # Optional implements
    varia lista<textus> implet = []
    si p.congruetVerbum("implet") {
        fac {
            fixum ifaceSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
            implet.appende(ifaceSym.valor)
        } dum p.congruet(SymbolumGenus.Coma)
    }

    # Parse body
    p.expecta(SymbolumGenus.UncusSin, ParserErrorCodice.ExpectaturUncusSin)

    varia campi = [] innatum lista<CampusDeclaratio>
    varia methodi = [] innatum lista<FunctioDeclaratio>
    varia structor = nihil qua si FunctioDeclaratio

    dum non p.proba(SymbolumGenus.UncusDex) et non p.estFinis() {
        # Parse annotations for visibility/abstract/morphologia
        fixum annotationes = parseAnnotationes(r)

        # Parse visibility modifier
        varia visibilitas = Visibilitas.Privata
        varia visibilitasExplicita = falsum
        itera ex annotationes fixum a {
            si a.nomen inter ["publicum", "publica", "publicus"] {
                visibilitas = Visibilitas.Publica
                visibilitasExplicita = verum
            } sin a.nomen inter ["protectum", "protecta", "protectus"] {
                visibilitas = Visibilitas.Protecta
                visibilitasExplicita = verum
            } sin a.nomen inter ["privatum", "privata", "privatus"] {
                visibilitas = Visibilitas.Privata
                visibilitasExplicita = verum
            }
        }
        si p.congruetVerbum("publicus") {
            visibilitas = Visibilitas.Publica
            visibilitasExplicita = verum
        } sin p.congruetVerbum("privatus") {
            visibilitas = Visibilitas.Privata
            visibilitasExplicita = verum
        } sin p.congruetVerbum("protectus") {
            visibilitas = Visibilitas.Protecta
            visibilitasExplicita = verum
        }

        # Check for static modifier
        varia staticum = falsum
        si p.congruetVerbum("generis") {
            staticum = verum
        }

        # Check if this is a method or field
        si p.probaVerbum("functio") {
            # WHY: Methods use full functio syntax but remain inside genus.
            p.procede()
            fixum methodLocus = p.locusActualis()
            fixum methodNomen = parseNomenVelVerbum(r)

            p.expecta(SymbolumGenus.ParensSin, ParserErrorCodice.ExpectaturParensSin)
            fixum params = parseParametra(r)
            p.expecta(SymbolumGenus.ParensDex, ParserErrorCodice.ExpectaturParensDex)

            varia modificatores = parseFunctioModificatores(r)

            varia retTypus = nihil qua si TypusAnnotatio
            varia asynca = falsum
            varia generator = falsum

            # NOTE: fit/fiet/fiunt/fient disabled - see parseFunctioDeclaratio comment
            si p.congruet(SymbolumGenus.Sagitta) {
                retTypus = r.adnotatio()
            }

            varia body = nihil qua si MassaSententia
            si p.proba(SymbolumGenus.UncusSin) {
                # WHY: Abstract methods omit bodies inside abstract genera.
                body = parseMassaSententia(r)
            }

            varia estStructor = methodNomen == "creo"
            varia abstracta = falsum
            itera ex annotationes fixum a {
                si a.nomen inter ["abstractum", "abstracta", "abstractus"] {
                    abstracta = verum
                }
            }
            si estStructor {
                visibilitas = Visibilitas.Privata
            }

            # NOTE: we keep this as a plain record cast rather than `finge`.
            # WHY: inside Rivus itself, `finge` is currently not preserving literal
            #      tag types for nested discriminated unions in TS output.
            fixum methodus = {
                tag: "FunctioDeclaratio",
                locus: methodLocus,
                nomen: methodNomen,
                generaParametra: nihil,
                parametra: params,
                typusReditus: retTypus,
                corpus: body,
                asynca: asynca,
                generator: generator,
                abstracta: abstracta,
                structor: estStructor,
                externa: falsum,
                visibilitas: visibilitas,
                reddeVerbum: nihil,
                morphologia: morphologiaEx(annotationes),
                modificatores: modificatores,
                annotationes: nihil
            } qua FunctioDeclaratio

            si estStructor {
                structor = methodus
            }
            methodi.appende(methodus)
        } secus {
            # Field: type name or name: default
            fixum campusLocus = p.locusActualis()
            fixum typusAnnotatio = r.adnotatio()
            fixum campusNomen = parseNomenVelVerbum(r)

            varia valor = nihil qua si Expressia
            si p.congruet(SymbolumGenus.Colon) {
                valor = r.expressia()
            }

            campi.appende({
                locus: campusLocus,
                nomen: campusNomen,
                typus: typusAnnotatio,
                valor: valor,
                visibilitas: visibilitas,
                staticum: staticum
            } novum CampusDeclaratio)
        }

        # Optional comma/semicolon between members
        p.congruet(SymbolumGenus.Coma)
        p.congruet(SymbolumGenus.PunctumColon)
    }

    p.expecta(SymbolumGenus.UncusDex, ParserErrorCodice.ExpectaturUncusDex)

    redde finge GenusDeclaratio {
        locus: locus,
        nomen: nomen,
        generaParametra: generaParametra,
        extendit: extendit,
        implet: implet,
        abstractum: abstractum,
        campi: campi,
        structor: structor,
        methodi: methodi,
        morphologia: nihil,
        visibilitas: nihil
    } qua Sententia
}

# ============================================================================
# PACTUM (INTERFACE) DECLARATIONS
# ============================================================================

# Parse pactum (interface) declaration
#
# GRAMMAR: pactumDecl := 'pactum' IDENT genericParams? '{' methods '}'
#
# Examples:
#   pactum Iterabilis { functio sequens() -> si T }
#   pactum Comparabilis<T> { functio compara(T alius) -> numerus }
@ publica
functio parsePactumDeclaratio(in Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'pactum'
    p.expectaVerbum("pactum", ParserErrorCodice.ExpectaturPactum)

    # Parse name
    fixum nomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
    fixum nomen = nomenSym.valor

    # Optional generic parameters
    varia lista<textus> generaParametra = []
    si p.congruet(SymbolumGenus.Minor) {
        generaParametra = parseGenericaNomina(r)
    }

    # Parse body
    p.expecta(SymbolumGenus.UncusSin, ParserErrorCodice.ExpectaturUncusSin)

    varia methodi = [] innatum lista<PactumMethodus>

    dum non p.proba(SymbolumGenus.UncusDex) et non p.estFinis() {
        # Optional annotations (e.g., @ futura, @ radix)
        fixum annotationes = parseAnnotationes(r)

        # Each method: functio name(params) funcModifier* returnType
        # Method names can be keywords (e.g., cape, tempta in HAL modules)
        p.expectaVerbum("functio", ParserErrorCodice.ExpectaturFunctio)

        fixum methodLocus = p.praevius().locus
        fixum methodNomen = parseNomenVelVerbum(r)

        p.expecta(SymbolumGenus.ParensSin, ParserErrorCodice.ExpectaturParensSin)
        fixum params = parseParametra(r)
        p.expecta(SymbolumGenus.ParensDex, ParserErrorCodice.ExpectaturParensDex)

        varia modificatores = parseFunctioModificatores(r)

        varia typusReditus = nihil qua si TypusAnnotatio
        varia asynca = falsum
        varia generator = falsum

        # NOTE: fit/fiet/fiunt/fient disabled - see parseFunctioDeclaratio comment
        si p.congruet(SymbolumGenus.Sagitta) {
            typusReditus = r.adnotatio()
        }

        itera ex annotationes fixum a {
            si a.nomen == "futura" {
                asynca = verum
            }
        }

        methodi.appende({
            locus: methodLocus,
            nomen: methodNomen,
            parametra: params,
            typusReditus: typusReditus,
            asynca: asynca,
            generator: generator,
            modificatores: modificatores,
            morphologia: morphologiaEx(annotationes)
        } novum PactumMethodus)

        # Optional separator
        p.congruet(SymbolumGenus.Coma)
        p.congruet(SymbolumGenus.PunctumColon)
    }

    p.expecta(SymbolumGenus.UncusDex, ParserErrorCodice.ExpectaturUncusDex)

    redde finge PactumDeclaratio {
        locus: locus,
        nomen: nomen,
        generaParametra: generaParametra,
        methodi: methodi,
        visibilitas: nihil
    } qua Sententia
}

# ============================================================================
# ORDO (ENUM) AND DISCRETIO (TAGGED UNION) DECLARATIONS
# ============================================================================

# Parse ordo (enum) declaration
#
# GRAMMAR: ordoDecl := 'ordo' IDENT '{' (IDENT ('=' value)?)* '}'
#
# Examples:
#   ordo Color { Rubrum, Viridis, Caeruleum }
#   ordo Status { Pendens = 0, Actum = 1, Completum = 2 }
@ publica
functio parseOrdoDeclaratio(in Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'ordo'
    p.expectaVerbum("ordo", ParserErrorCodice.ExpectaturOrdo)

    # Parse name
    fixum nomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
    fixum nomen = nomenSym.valor

    # Parse body
    p.expecta(SymbolumGenus.UncusSin, ParserErrorCodice.ExpectaturUncusSin)

    varia membra = [] innatum lista<OrdoMembrum>

    dum non p.proba(SymbolumGenus.UncusDex) et non p.estFinis() {
        fixum membrumLocus = p.locusActualis()
        fixum membrumNomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
        fixum membrumNomen = membrumNomenSym.valor

        varia valor = nihil qua si textus
        si p.congruet(SymbolumGenus.Aequum) {
            # Parse value (number or string)
            si p.congruet(SymbolumGenus.Minus) {
                # Negative numeric literal
                fixum valorSym = p.procede()
                valor = scriptum("-§", valorSym.valor)
            } secus {
                fixum valorSym = p.procede()
                si valorSym.species === SymbolumGenus.Textus {
                    valor = scriptum("\"§\"", valorSym.valor)
                } secus {
                    valor = valorSym.valor
                }
            }
        }

        membra.appende({
            locus: membrumLocus,
            nomen: membrumNomen,
            valor: valor
        } novum OrdoMembrum)

        # Optional comma
        p.congruet(SymbolumGenus.Coma)
    }

    p.expecta(SymbolumGenus.UncusDex, ParserErrorCodice.ExpectaturUncusDex)

    redde finge OrdoDeclaratio {
        locus: locus,
        nomen: nomen,
        membra: membra,
        visibilitas: nihil
    } qua Sententia
}

# Parse discretio (tagged union) declaration
#
# GRAMMAR: discretioDecl := 'discretio' IDENT genericParams? '{' variants '}'
#
# Examples:
#   discretio Option<T> { Aliquid { T valor }, Nihil }
#   discretio Event { Click { numerus x, numerus y }, Quit }
@ publica
functio parseDiscretioDeclaratio(in Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'discretio'
    p.expectaVerbum("discretio", ParserErrorCodice.ExpectaturDiscretio)

    # Parse name
    fixum nomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
    fixum nomen = nomenSym.valor

    # Optional generic parameters
    varia lista<textus> generaParametra = []
    si p.congruet(SymbolumGenus.Minor) {
        generaParametra = parseGenericaNomina(r)
    }

    # Parse body
    p.expecta(SymbolumGenus.UncusSin, ParserErrorCodice.ExpectaturUncusSin)

    varia variantes = [] innatum lista<VariansDeclaratio>

    dum non p.proba(SymbolumGenus.UncusDex) et non p.estFinis() {
        fixum variansLocus = p.locusActualis()
        fixum variansNomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
        fixum variansNomen = variansNomenSym.valor

        varia campi = [] innatum lista<VariansCampus>

        # Optional fields in braces or parens
        si p.congruet(SymbolumGenus.UncusSin) {
            dum non p.proba(SymbolumGenus.UncusDex) et non p.estFinis() {
                campi.appende(parseVariansCampusNominatus(r))
                p.congruet(SymbolumGenus.Coma)
            }
            p.expecta(SymbolumGenus.UncusDex, ParserErrorCodice.ExpectaturUncusDex)
        } sin p.congruet(SymbolumGenus.ParensSin) {
            varia index = 1
            si non p.proba(SymbolumGenus.ParensDex) {
                fac {
                    fixum campusLocus = p.locusActualis()
                    fixum campusTypus = r.adnotatio()
                    fixum campusNomen = (index == 1) sic "value" secus scriptum("value§", index)
                    index += 1
                    campi.appende({
                        locus: campusLocus,
                        nomen: campusNomen,
                        typus: campusTypus
                    } novum VariansCampus)
                } dum p.congruet(SymbolumGenus.Coma)
            }
            p.expecta(SymbolumGenus.ParensDex, ParserErrorCodice.ExpectaturParensDex)
        }

        variantes.appende({
            locus: variansLocus,
            nomen: variansNomen,
            campi: campi
        } novum VariansDeclaratio)

        # Optional comma between variants
        p.congruet(SymbolumGenus.Coma)
    }

    p.expecta(SymbolumGenus.UncusDex, ParserErrorCodice.ExpectaturUncusDex)

    redde finge DiscretioDeclaratio {
        locus: locus,
        nomen: nomen,
        generaParametra: generaParametra,
        variantes: variantes,
        visibilitas: nihil
    } qua Sententia
}

# ============================================================================
# TYPE ALIAS DECLARATIONS
# ============================================================================

# Parse type alias declaration
#
# GRAMMAR: typusDecl := 'typus' IDENT '=' type
#
# Examples:
#   typus ID = textus
#   typus Callback = functio(numerus) -> vacuum
@ publica
functio parseTypusAliasDeclaratio(in Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'typus'
    p.expectaVerbum("typus", ParserErrorCodice.ExpectaturTypus)

    # Parse name
    fixum nomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
    fixum nomen = nomenSym.valor

    # Expect '='
    p.expecta(SymbolumGenus.Aequum, ParserErrorCodice.ExpectaturAequale)

    # Parse type (or typeof alias)
    varia scopusNomen = nihil qua si textus
    varia typusAlias = nihil qua si TypusAnnotatio

    si p.probaVerbum("typus") {
        p.procede()
        fixum scopusSym = p.specta(0)
        si scopusSym.species == SymbolumGenus.Nomen aut scopusSym.species == SymbolumGenus.Verbum {
            p.procede()
            scopusNomen = scopusSym.valor
            typusAlias = typusSimplicis("ignotum", locus)
        } secus {
            p.renuncia(ParserErrorCodice.ExpectaturNomen, scriptum("got '§'", scopusSym.valor))
            p.procede()
            typusAlias = typusSimplicis("ignotum", locus)
        }
    } secus {
        typusAlias = r.adnotatio()
    }

    redde finge TypusAliasDeclaratio {
        locus: locus,
        nomen: nomen,
        typus: typusAlias,
        scopusNomen: scopusNomen,
        visibilitas: nihil
    } qua Sententia
}

# ============================================================================
# HELPER FUNCTIONS
# ============================================================================

functio morphologiaEx(de lista<Annotatio> annotationes) -> si MorphologiaDeclaratio {
    itera ex annotationes fixum a {
        si a.nomen == "radix" {
            redde { locus: a.locus, formae: a.argumenta } novum MorphologiaDeclaratio
        }
    }
    redde nihil
}

# Parse function parameters
@ publica
functio parseParametra(in Resolvitor r) -> lista<Parametrum> {
    fixum p = r.parser()
    varia parametra = [] innatum lista<Parametrum>

    si p.proba(SymbolumGenus.ParensDex) {
        redde parametra
    }

    fac {
        fixum paramLocus = p.locusActualis()

        # Optional parameter marker (must come before preposition per EBNF)
        varia optionalis = falsum
        si p.probaVerbum("si") {
            optionalis = verum
            p.procede()
        }

        # Check for preposition (de, in, ex)
        varia praepositio = nihil qua si textus
        si p.estPraepositio(p.specta(0)) {
            praepositio = p.procede().verbum
        }

        # Check for rest parameter
        varia residuum = falsum
        si p.probaVerbum("ceteri") {
            residuum = verum
            p.procede()
        }

        # Parse type (required)
        varia paramTypus = nihil qua si TypusAnnotatio
        si p.estTypusNomen(p.specta(0)) {
            paramTypus = r.adnotatio()
        } sin p.proba(SymbolumGenus.ParensSin) {
            # Function type annotation: (T) -> U
            paramTypus = r.adnotatio()
        } sin p.proba(SymbolumGenus.Verbum) et p.specta(1).species == SymbolumGenus.Nomen {
            # Type keyword token followed by identifier
            paramTypus = r.adnotatio()
        } sin p.proba(SymbolumGenus.Nomen) et (
            p.specta(1).species == SymbolumGenus.Nomen aut
            p.specta(1).species == SymbolumGenus.Minor aut
            p.specta(1).species == SymbolumGenus.QuadratusSin aut
            p.specta(1).species == SymbolumGenus.Rogatio
        ) {
            # User-defined type (Point, Point[], Point?, Point<T>)
            paramTypus = r.adnotatio()
        } secus {
            p.renuncia(ParserErrorCodice.ExpectaturTypusNomen, scriptum("got '§'", p.specta(0).valor))
            paramTypus = typusSimplicis("ignotum", paramLocus)
        }

        # Parse name (keywords like `page` allowed)
        fixum nomen = parseNomenVelVerbum(r)

        # Optional alias: ut alias
        varia paramAlias = nihil qua si textus
        si p.probaVerbum("ut") {
            p.procede()
            paramAlias = parseNomenVelVerbum(r)
        }

        # Optional default: vel value
        varia praedefinitum = nihil qua si Expressia
        si p.probaVerbum("vel") {
            p.procede()
            praedefinitum = r.expressia()
        } sin p.congruet(SymbolumGenus.Colon) {
            # LEGACY: `textus name: "World"` style defaults
            praedefinitum = r.expressia()
        }

        parametra.appende({
            locus: paramLocus,
            nomen: nomen,
            alias: paramAlias,
            typus: paramTypus,
            praedefinitum: praedefinitum,
            praepositio: praepositio,
            optionalis: optionalis,
            residuum: residuum
        } novum Parametrum)

    } dum p.congruet(SymbolumGenus.Coma)

    redde parametra
}

# Parse compile-time type parameters (prae typus T, U)
@ publica
functio parseTypusParametra(in Resolvitor r) -> lista<TypusParametrum> {
    fixum p = r.parser()
    varia parametra = [] innatum lista<TypusParametrum>

    # Already consumed 'prae', expect 'typus'
    p.expectaVerbum("typus", ParserErrorCodice.ExpectaturTypus)

    fac {
        fixum paramLocus = p.locusActualis()
        fixum nomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)

        parametra.appende({
            locus: paramLocus,
            nomen: nomenSym.valor
        } qua TypusParametrum)
    } dum p.congruet(SymbolumGenus.Coma)

    redde parametra
}

# Parse generic type names in angle brackets: <T, U>
@ publica
functio parseGenericaNomina(in Resolvitor r) -> lista<textus> {
    fixum p = r.parser()
    varia nomina = [] innatum lista<textus>

    # Already consumed '<'
    fac {
        fixum nomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
        nomina.appende(nomenSym.valor)
    } dum p.congruet(SymbolumGenus.Coma)

    p.expecta(SymbolumGenus.Maior, ParserErrorCodice.ExpectaturAngulusDex)

    redde nomina
}

# Parse a single named variant field (brace syntax)
#
# GRAMMAR: variantField := type IDENTIFIER
#
# EDGE: Allows keywords as field names for compiler-internal ASTs.
#       Example: `TypusAnnotatio? typus`, `CapeClausula? cape`.
@ publica
functio parseVariansCampusNominatus(in Resolvitor r) -> VariansCampus {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    fixum typus = r.adnotatio()

    # Allow keywords as field names
    fixum nomenSym = p.specta(0)
    varia nomen = ""
    si nomenSym.species == SymbolumGenus.Nomen aut nomenSym.species == SymbolumGenus.Verbum {
        p.procede()
        nomen = nomenSym.valor
    } secus {
        p.renuncia(ParserErrorCodice.ExpectaturNomen, scriptum("got '§'", nomenSym.valor))
        p.procede()
        nomen = nomenSym.valor
    }

    redde {
        locus: locus,
        nomen: nomen,
        typus: typus
    } novum VariansCampus
}

# ============================================================================
# IMPORT DECLARATIONS
# ============================================================================

# Parse import declaration (new verb-first syntax per issue #304)
#
# GRAMMAR:
#   importaDecl := 'importa' 'ex' (STRING | IDENT) ('privata' | 'publica') (IDENT | '*') ('ut' IDENT)?
#
# Examples:
#   importa ex "path" privata T
#   importa ex "path" privata T ut alias
#   importa ex "path" publica T           (re-export)
#   importa ex "path" privata * ut ns     (wildcard)
@ publica
functio parseImportaSententia(in Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'importa'
    p.expectaVerbum("importa", ParserErrorCodice.ExpectaturImporta)

    # Consume 'ex'
    p.expectaVerbum("ex", ParserErrorCodice.ExpectaturEx)

    # Parse source (string or identifier for norma modules)
    varia fons = ""
    si p.proba(SymbolumGenus.Textus) {
        fixum fonsSym = p.procede()
        fons = fonsSym.valor
    } secus {
        fixum fonsSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
        fons = fonsSym.valor
    }

    # Require explicit visibility: privata or publica
    varia publica = falsum
    si p.congruetVerbum("publica") {
        publica = verum
    } sin p.congruetVerbum("privata") {
        publica = falsum
    } secus {
        p.renuncia(ParserErrorCodice.ExpectaturVisibilitas, "expected 'privata' or 'publica' after import path")
    }

    # Parse imported name or wildcard
    varia totum = falsum
    varia importatum = nihil qua si textus
    varia locale = ""

    si p.congruet(SymbolumGenus.Stella) {
        # Wildcard import: * ut alias (alias required)
        totum = verum
        p.expectaVerbum("ut", ParserErrorCodice.ExpectaturUt)
        fixum aliasSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
        locale = aliasSym.valor
    } secus {
        # Named import: T [ut alias]
        fixum nomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
        importatum = nomenSym.valor
        locale = nomenSym.valor

        si p.congruetVerbum("ut") {
            fixum aliasSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
            locale = aliasSym.valor
        }
    }

    redde finge ImportaSententia {
        locus: locus,
        fons: fons,
        importatum: importatum,
        locale: locale,
        totum: totum,
        publica: publica
    } qua Sententia
}
