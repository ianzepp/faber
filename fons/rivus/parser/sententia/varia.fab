# Variable Declaration Parsers
#
# Variable declarations, destructuring patterns, and related constructs.
#
# GRAMMAR:
#   varDecl := ('varia' | 'fixum' | 'figendum' | 'variandum') typeAnnotation? IDENTIFIER ('=' expression)?
#   arrayPattern := '[' arrayPatternElement (',' arrayPatternElement)* ']'
#   objectPattern := '{' patternProperty (',' patternProperty)* '}'
#
# LATIN VOCABULARY:
# - varia = variable (let it vary)
# - fixum = fixed (const)
# - figendum = to be fixed (const + await)
# - variandum = to be varied (let + await)
# - ceteri = the rest (rest pattern)
# - omissum = omitted/skipped (placeholder _)

§ ex "../resolvitor" importa Resolvitor
§ ex "../../ast/positio" importa Locus
§ ex "../../ast/expressia" importa Expressia
§ ex "../../ast/sententia" importa Sententia, VariaGenus, ImportaSpecificator
§ ex "../../ast/sententia" importa SeriesDestructuraElementum, IteratioVariabilis, IteratioGenus, CapeClausula
§ ex "../../ast/typus" importa TypusAnnotatio
§ ex "../../ast/lexema" importa SymbolumGenus
§ ex "../errores" importa ParserErrorCodice
§ ex "./massa" importa parseMassaSententia
§ ex "./imperium" importa parseCapeClausula

# ============================================================================
# IDENTIFIER PARSING
# ============================================================================

# Parse an identifier (simple name reference)
@ publica
functio parseNomen(in Resolvitor r) -> textus {
    fixum p = r.parser()
    fixum symbolum = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
    redde symbolum.valor
}

# Parse identifier or keyword (for import specifiers, property names)
# Keywords like 'scribe' can be valid identifiers in some contexts
@ publica
functio parseNomenVelVerbum(in Resolvitor r) -> textus {
    fixum p = r.parser()
    fixum s = p.specta(0)

    si s.species === SymbolumGenus.Nomen aut s.species === SymbolumGenus.Verbum {
        p.procede()
        redde s.valor
    }

    # Error: expected identifier
    p.renuncia(ParserErrorCodice.ExpectaturNomen, scriptum("got '§'", s.valor))
    p.procede()
    redde s.valor
}

# ============================================================================
# DESTRUCTURING
# ============================================================================

# Parse destructure declaration
#
# GRAMMAR: destruct := 'ex' expr (fixum|varia|figendum|variandum) spec (',' spec)*
#          | 'ex' expr (fixum|varia|figendum|variandum) '[' pattern ']' ('{' block '}' | '=' expr)
# spec := IDENT ('ut' IDENT)? | 'ceteri' IDENT
@ publica
functio parseDestructuraSententia(in Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    p.expectaVerbum("ex", ParserErrorCodice.ExpectaturEx)
    fixum fons = r.expressia()

    # Binding kind
    fixum verbum = p.specta(0).verbum
    varia species = VariaGenus.Fixum
    elige verbum {
        casu "fixum" { species = VariaGenus.Fixum }
        casu "varia" { species = VariaGenus.Varia }
        casu "figendum" { species = VariaGenus.Figendum }
        casu "variandum" { species = VariaGenus.Variandum }
    }
    p.procede()

    # Array destructuring: ex source fixum [a, b] or ex source fixum [k, v] { }
    si p.proba(SymbolumGenus.QuadratusSin) {
        fixum elementa = parseSeriesDestructura(r)

        # Check for block body -> for-of loop with destructuring
        si p.proba(SymbolumGenus.UncusSin) {
            fixum corpus = parseMassaSententia(r)

            # Optional catch
            varia cape = nihil qua si CapeClausula
            si p.probaVerbum("cape") {
                cape = parseCapeClausula(r)
            }

            fixum asynca = species == VariaGenus.Figendum aut species == VariaGenus.Variandum
            fixum mutabilis = species == VariaGenus.Varia aut species == VariaGenus.Variandum
            varia variabilis = nihil qua si IteratioVariabilis
            variabilis = finge Series { elementa: elementa } qua IteratioVariabilis

            redde finge IteratioSententia {
                locus: locus,
                species: IteratioGenus.Ex,
                variabilis: variabilis qua IteratioVariabilis,
                iterabile: fons,
                corpus: corpus,
                asynca: asynca,
                mutabilis: mutabilis,
                cape: cape
            } qua Sententia
        }

        # No block -> one-shot destructuring
        redde finge SeriesDestructuraSententia {
            locus: locus,
            species: species,
            elementa: elementa,
            fons: fons
        } qua Sententia
    }

    # Object destructuring: ex persona fixum nomen, aetas
    varia specificatores = [] innatum lista<ImportaSpecificator>

    fac {
        fixum specLocus = p.locusActualis()

        varia residuum = falsum
        si p.probaVerbum("ceteri") {
            residuum = verum
            p.procede()
        }

        fixum importatum = parseNomenVelVerbum(r)
        varia locale = importatum

        si p.probaVerbum("ut") {
            p.procede()
            locale = parseNomenVelVerbum(r)
        }

        specificatores.adde({
            locus: specLocus,
            importatum: importatum,
            locale: locale,
            residuum: residuum
        } novum ImportaSpecificator)

    } dum p.congruet(SymbolumGenus.Coma)

    redde finge DestructuraSententia {
        locus: locus,
        fons: fons,
        species: species,
        specificatores: specificatores
    } qua Sententia
}

# Parse array destructuring pattern: [a, b, ceteri rest]
@ publica
functio parseSeriesDestructura(in Resolvitor r) -> lista<SeriesDestructuraElementum> {
    fixum p = r.parser()

    p.expecta(SymbolumGenus.QuadratusSin, ParserErrorCodice.ExpectaturQuadratusSin)

    varia elementa = [] innatum lista<SeriesDestructuraElementum>
    si non p.proba(SymbolumGenus.QuadratusDex) {
        fac {
            fixum locus = p.locusActualis()
            varia residuum = falsum
            varia omissum = falsum
            varia nomen = nihil qua si textus

            si p.probaVerbum("ceteri") {
                residuum = verum
                p.procede()
            }

            fixum s = p.specta(0)
            si s.species === SymbolumGenus.Nomen aut s.species === SymbolumGenus.Verbum {
                p.procede()
                si s.valor == "_" {
                    omissum = verum
                } secus {
                    nomen = s.valor
                }
            } secus {
                p.renuncia(ParserErrorCodice.ExpectaturNomen, scriptum("got '§'", s.valor))
                p.procede()
            }

            elementa.adde({
                locus: locus,
                nomen: nomen,
                residuum: residuum,
                omissum: omissum
            } novum SeriesDestructuraElementum)
        } dum p.congruet(SymbolumGenus.Coma)
    }

    p.expecta(SymbolumGenus.QuadratusDex, ParserErrorCodice.ExpectaturQuadratusDex)

    redde elementa
}

# ============================================================================
# VARIABLE DECLARATIONS
# ============================================================================

# Parse variable declaration
#
# GRAMMAR: varDecl := ('varia'|'fixum'|'figendum'|'variandum') type? name ('=' expr)?
#
# Supports:
# - Type inference: fixum x = 42
# - Type-first: fixum numerus x = 42
# - Array destructuring: fixum [a, b] = coords (TODO)
@ publica
functio parseVariaSententia(in Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Get declaration kind from keyword
    fixum verbum = p.specta(0).verbum
    varia species = VariaGenus.Varia

    elige verbum {
        casu "varia" { species = VariaGenus.Varia }
        casu "fixum" { species = VariaGenus.Fixum }
        casu "figendum" { species = VariaGenus.Figendum }
        casu "variandum" { species = VariaGenus.Variandum }
    }

    # Consume the keyword
    p.procede()

    # -------------------------------------------------------------------------
    # Array destructuring: fixum [a, b] = coords
    # -------------------------------------------------------------------------
    si p.proba(SymbolumGenus.QuadratusSin) {
        fixum elementa = parseSeriesDestructura(r)
        p.expecta(SymbolumGenus.Aequum, ParserErrorCodice.ExpectaturAequale)
        fixum fons = r.expressia()
        redde finge SeriesDestructuraSententia {
            locus: locus,
            species: species,
            elementa: elementa,
            fons: fons
        } qua Sententia
    }

    # -------------------------------------------------------------------------
    # Determine what follows: type or name
    # -------------------------------------------------------------------------
    varia adnotatio = nihil qua si TypusAnnotatio
    varia nomen = ""

    si p.estTypusNomen(p.specta(0)) {
        # Builtin type: fixum numerus x = 42
        adnotatio = r.adnotatio()
        nomen = parseNomenVelVerbum(r)
    } sin p.proba(SymbolumGenus.Nomen) et p.specta(1).species === SymbolumGenus.Nomen {
        # Two identifiers: first is type, second is name
        # Handles user-defined types: fixum UserId id = 42
        adnotatio = r.adnotatio()
        nomen = parseNomenVelVerbum(r)
    } secus {
        # Just a name (type inference): fixum x = 42
        nomen = parseNomenVelVerbum(r)

        # =====================================================================
        # SYNTAXIS ALIENA DETECTION: TypeScript-style colon type annotation
        # =====================================================================
        # Detect `fixum x: textus` pattern (TypeScript habit) and emit helpful error.
        # The correct Faber syntax is `fixum textus x`.
        si p.proba(SymbolumGenus.Colon) {
            p.renuncia(ParserErrorCodice.SyntaxisAlienaColonTypus, scriptum("found '§:'", nomen))
            # Skip the colon and whatever follows to attempt recovery
            p.procede()
            si p.proba(SymbolumGenus.Nomen) aut p.proba(SymbolumGenus.Verbum) {
                p.procede()
            }
        }
    }

    # -------------------------------------------------------------------------
    # Parse optional initializer
    # -------------------------------------------------------------------------
    varia valor = nihil qua si Expressia

    si p.congruet(SymbolumGenus.Aequum) {
        valor = r.expressia()
    }

    redde finge VariaSententia {
        locus: locus,
        species: species,
        nomen: nomen,
        typus: adnotatio,
        valor: valor,
        externa: falsum,
        visibilitas: nihil
    } qua Sententia
}
