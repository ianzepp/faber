# Annotation Parser - @ and § Directive Parsing
#
# Parses line-based annotations that modify declarations.
#
# TWO ANNOTATION SYSTEMS:
#   @ = Code semantics (futura, externa, publica, verte, etc.)
#   § = Project/build configuration (opus, scopos, exitus, dependentia, etc.)
#
# GRAMMAR:
#   annotation := '@' IDENTIFIER arguments?
#   sectio := '§' IDENTIFIER arguments?
#   arguments := (IDENTIFIER | STRING)* (same line only)
#
# STDLIB @ ANNOTATIONS:
#   innatumAnnotation := '@' 'innatum' targetMapping (',' targetMapping)*
#   subsidiaAnnotation := '@' 'subsidia' targetMapping (',' targetMapping)*
#   radixAnnotation := '@' 'radix' IDENTIFIER (',' IDENTIFIER)*
#   verteAnnotation := '@' 'verte' IDENTIFIER (STRING | '(' IDENTIFIER (',' IDENTIFIER)* ')' '->' STRING)
#   targetMapping := IDENTIFIER STRING
#
# § ANNOTATIONS (build config):
#   § opus nomen "name"              -> project name
#   § opus versio "1.0.0"            -> project version
#   § scopos "ts"                    -> target language
#   § exitus "dist"                  -> output directory
#   § dependentia "name" via "path"  -> Faber library dependency
#   § externa "alias" ex "package"   -> external package
#   § modulus "path/to/module"       -> module identity
#
# Examples:
#   @ futura                         -> marks function as async
#   @ radix filtr, imperativus, perfectum -> verb morphology forms
#   @ publica                        -> visibility modifier
#   @ externa                        -> external declaration
#   @ innatum ts "Array", py "list"  -> native type mapping
#   @ subsidia zig "file.zig"        -> external implementation file
#   @ verte ts "push"                -> simple method rename
#   @ verte ts (ego, elem) -> "[...S, S]" -> template transformation
#
# LATIN VOCABULARY:
# - annotatio = annotation/note
# - sectio = section (for build config)
# - innatum = inborn/native
# - subsidia = supports/implementation
# - radix = root/stem
# - verte = turn/transform
# - opus = work/project
# - scopos = target/goal
# - exitus = exit/output
# - dependentia = dependency

§ ex "../resolvitor" importa Resolvitor
§ ex "../../ast/positio" importa Locus
§ ex "../../ast/lexema" importa SymbolumGenus
§ ex "../../ast/radix" importa SectioAnnotatio
§ ex "../../ast/annotatio" importa Annotatio
§ ex "../errores" importa ParserErrorCodice

# ============================================================================
# HELPERS
# ============================================================================

# Check if token is identifier or keyword (both valid for annotation names)
functio estNomenAutVerbum(SymbolumGenus species) -> bivalens {
    redde species == SymbolumGenus.Nomen aut species == SymbolumGenus.Verbum
}

# ============================================================================
# STDLIB ANNOTATION PARSERS
# ============================================================================

# Parse @ innatum or @ subsidia: target-to-value mappings
# Grammar: targetMapping (',' targetMapping)*
# Example: @ innatum ts "Array", py "list", zig "Lista"
functio parseTargetMappingAnnotation(in Resolvitor r, de textus nomen, de Locus locus, numerus linea) -> Annotatio {
    fixum p = r.parser()
    varia targetMappings = {} innatum tabula<textus, textus>

    # Parse first mapping (required)
    si non p.estFinis() et p.specta(0).locus.linea == linea et estNomenAutVerbum(p.specta(0).species) {
        fac {
            # Parse target identifier (ts, py, rs, cpp, zig)
            si non estNomenAutVerbum(p.specta(0).species) aut p.specta(0).locus.linea != linea {
                p.renuncia(ParserErrorCodice.ExpectaturTargetNomen, scriptum("got '§'", p.specta(0).valor))
                rumpe
            }
            fixum target = p.specta(0).valor
            p.procede()

            # Parse value string
            si p.specta(0).species != SymbolumGenus.Textus aut p.specta(0).locus.linea != linea {
                p.renuncia(ParserErrorCodice.ExpectaturTargetValor, scriptum("after '§'", target))
                rumpe
            }
            fixum valor = p.specta(0).valor
            p.procede()

            targetMappings.pone(target, valor)
        } dum non p.estFinis() et p.specta(0).locus.linea == linea et p.congruet(SymbolumGenus.Coma)
    }

    redde {
        locus: locus,
        nomen: nomen,
        argumenta: [] innatum lista<textus>,
        targetMappings: targetMappings,
        radixForms: nihil,
        verteTarget: nihil,
        verteMethod: nihil,
        verteParams: nihil,
        verteTemplate: nihil,
        optioTypus: nihil,
        optioNomen: nihil,
        optioBrevis: nihil,
        optioLongum: nihil,
        optioDescriptio: nihil,
        optioBivalens: nihil,
        operandusTypus: nihil,
        operandusNomen: nihil,
        operandusCeteri: nihil,
        operandusDescriptio: nihil
    } novum Annotatio
}

# Parse @ radix: stem and morphological forms
# Grammar: IDENTIFIER (',' IDENTIFIER)*
# Example: @ radix filtr, imperativus, perfectum
# Note: First identifier is stem, rest are form names (no validation)
functio parseRadixAnnotation(in Resolvitor r, de Locus locus, numerus linea) -> Annotatio {
    fixum p = r.parser()
    varia radixForms = [] innatum lista<textus>

    # Parse comma-separated identifiers
    si non p.estFinis() et p.specta(0).locus.linea == linea et estNomenAutVerbum(p.specta(0).species) {
        fac {
            si non estNomenAutVerbum(p.specta(0).species) aut p.specta(0).locus.linea != linea {
                p.renuncia(ParserErrorCodice.ExpectaturNomen, scriptum("got '§'", p.specta(0).valor))
                rumpe
            }
            radixForms.adde(p.specta(0).valor)
            p.procede()
        } dum non p.estFinis() et p.specta(0).locus.linea == linea et p.congruet(SymbolumGenus.Coma)
    }

    redde {
        locus: locus,
        nomen: "radix",
        argumenta: [] innatum lista<textus>,
        targetMappings: nihil,
        radixForms: radixForms,
        verteTarget: nihil,
        verteMethod: nihil,
        verteParams: nihil,
        verteTemplate: nihil,
        optioTypus: nihil,
        optioNomen: nihil,
        optioBrevis: nihil,
        optioLongum: nihil,
        optioDescriptio: nihil,
        optioBivalens: nihil,
        operandusTypus: nihil,
        operandusNomen: nihil,
        operandusCeteri: nihil,
        operandusDescriptio: nihil
    } novum Annotatio
}

# Parse @ verte: codegen transformation
# Grammar: IDENTIFIER (STRING | '(' IDENTIFIER (',' IDENTIFIER)* ')' '->' STRING)
# Examples:
#   @ verte ts "push"
#   @ verte ts (ego, elem) -> "[...S, S]"
functio parseVerteAnnotation(in Resolvitor r, de Locus locus, numerus linea) -> Annotatio {
    fixum p = r.parser()

    # Parse target identifier (ts, py, rs, cpp, zig)
    si non estNomenAutVerbum(p.specta(0).species) aut p.specta(0).locus.linea != linea {
        p.renuncia(ParserErrorCodice.ExpectaturVerteTarget, scriptum("got '§'", p.specta(0).valor))
        redde {
            locus: locus,
            nomen: "verte",
            argumenta: [] innatum lista<textus>,
            targetMappings: nihil,
            radixForms: nihil,
            verteTarget: nihil,
            verteMethod: nihil,
            verteParams: nihil,
            verteTemplate: nihil,
            optioTypus: nihil,
            optioNomen: nihil,
            optioBrevis: nihil,
            optioLongum: nihil,
            optioDescriptio: nihil,
            optioBivalens: nihil,
            operandusTypus: nihil,
            operandusNomen: nihil,
            operandusCeteri: nihil,
            operandusDescriptio: nihil
        } novum Annotatio
    }
    fixum verteTarget = p.specta(0).valor
    p.procede()

    # Check for template form: (params) -> "template"
    si p.specta(0).species == SymbolumGenus.ParensSin et p.specta(0).locus.linea == linea {
        p.procede()  # consume '('

        varia verteParams = [] innatum lista<textus>

        # Parse parameter list
        si p.specta(0).species != SymbolumGenus.ParensDex {
            fac {
                si non estNomenAutVerbum(p.specta(0).species) aut p.specta(0).locus.linea != linea {
                    p.renuncia(ParserErrorCodice.ExpectaturVerteParam, scriptum("got '§'", p.specta(0).valor))
                    rumpe
                }
                verteParams.adde(p.specta(0).valor)
                p.procede()
            } dum p.congruet(SymbolumGenus.Coma)
        }

        # Expect closing paren
        si non p.congruet(SymbolumGenus.ParensDex) {
            p.renuncia(ParserErrorCodice.ExpectaturParensDex, "")
        }

        # Expect -> arrow
        si non p.congruet(SymbolumGenus.Sagitta) {
            p.renuncia(ParserErrorCodice.ExpectaturVerteSagitta, scriptum("got '§'", p.specta(0).valor))
        }

        # Parse template string
        si p.specta(0).species != SymbolumGenus.Textus aut p.specta(0).locus.linea != linea {
            p.renuncia(ParserErrorCodice.ExpectaturVerteTemplate, scriptum("got '§'", p.specta(0).valor))
            redde {
                locus: locus,
                nomen: "verte",
                argumenta: [] innatum lista<textus>,
                targetMappings: nihil,
                radixForms: nihil,
                verteTarget: verteTarget,
                verteMethod: nihil,
                verteParams: verteParams,
                verteTemplate: nihil,
                optioTypus: nihil,
                optioNomen: nihil,
                optioBrevis: nihil,
                optioLongum: nihil,
                optioDescriptio: nihil,
                operandusTypus: nihil,
                operandusNomen: nihil,
                operandusCeteri: nihil,
                operandusDescriptio: nihil
            } novum Annotatio
        }
        fixum verteTemplate = p.specta(0).valor
        p.procede()

        # Reject multiple targets on one line
        si p.specta(0).species == SymbolumGenus.Coma et p.specta(0).locus.linea == linea {
            p.renuncia(ParserErrorCodice.VerteMultiplicemTargets, "")
        }

        redde {
            locus: locus,
            nomen: "verte",
            argumenta: [] innatum lista<textus>,
            targetMappings: nihil,
            radixForms: nihil,
            verteTarget: verteTarget,
            verteMethod: nihil,
            verteParams: verteParams,
            verteTemplate: verteTemplate,
            optioTypus: nihil,
            optioNomen: nihil,
            optioBrevis: nihil,
            optioLongum: nihil,
            optioDescriptio: nihil,
            optioBivalens: nihil,
            operandusTypus: nihil,
            operandusNomen: nihil,
            operandusCeteri: nihil,
            operandusDescriptio: nihil
        } novum Annotatio
    }

    # Simple method form: "methodName"
    si p.specta(0).species != SymbolumGenus.Textus aut p.specta(0).locus.linea != linea {
        p.renuncia(ParserErrorCodice.ExpectaturVerteMethodAutTemplate, scriptum("got '§'", p.specta(0).valor))
        redde {
            locus: locus,
            nomen: "verte",
            argumenta: [] innatum lista<textus>,
            targetMappings: nihil,
            radixForms: nihil,
            verteTarget: verteTarget,
            verteMethod: nihil,
            verteParams: nihil,
            verteTemplate: nihil,
            optioTypus: nihil,
            optioNomen: nihil,
            optioBrevis: nihil,
            optioLongum: nihil,
            optioDescriptio: nihil,
            optioBivalens: nihil,
            operandusTypus: nihil,
            operandusNomen: nihil,
            operandusCeteri: nihil,
            operandusDescriptio: nihil
        } novum Annotatio
    }
    fixum verteMethod = p.specta(0).valor
    p.procede()

    # Reject multiple targets on one line
    si p.specta(0).species == SymbolumGenus.Coma et p.specta(0).locus.linea == linea {
        p.renuncia(ParserErrorCodice.VerteMultiplicemTargets, "")
    }

    redde {
        locus: locus,
        nomen: "verte",
        argumenta: [] innatum lista<textus>,
        targetMappings: nihil,
        radixForms: nihil,
        verteTarget: verteTarget,
        verteMethod: verteMethod,
        verteParams: nihil,
        verteTemplate: nihil,
        optioTypus: nihil,
        optioNomen: nihil,
        optioBrevis: nihil,
        optioLongum: nihil,
        optioDescriptio: nihil,
        operandusTypus: nihil,
        operandusNomen: nihil,
        operandusCeteri: nihil,
        operandusDescriptio: nihil
    } novum Annotatio
}

# Parse @ imperia: command re-export annotation
# Grammar: @ imperia STRING 'ex' IDENTIFIER
# Example: @ imperia "greet" ex greetModule
functio parseImperiaAnnotation(in Resolvitor r, de Locus locus, numerus linea) -> Annotatio {
    fixum p = r.parser()
    varia argumenta = [] innatum lista<textus>

    # Parse subcommand name (string)
    si p.specta(0).species == SymbolumGenus.Textus et p.specta(0).locus.linea == linea {
        argumenta.adde(p.specta(0).valor)
        p.procede()
    } secus {
        p.renuncia(ParserErrorCodice.ExpectaturTextus, scriptum("@ imperia requires subcommand name, got '§'", p.specta(0).valor))
    }

    # Parse 'ex' keyword
    si p.probaVerbum("ex") et p.specta(0).locus.linea == linea {
        p.procede()
    } secus {
        # No 'ex' - that's fine, just return what we have
        redde {
            locus: locus,
            nomen: "imperia",
            argumenta: argumenta,
            targetMappings: nihil,
            radixForms: nihil,
            verteTarget: nihil,
            verteMethod: nihil,
            verteParams: nihil,
            verteTemplate: nihil,
            optioTypus: nihil,
            optioNomen: nihil,
            optioBrevis: nihil,
            optioLongum: nihil,
            optioDescriptio: nihil,
            optioBivalens: nihil,
            operandusTypus: nihil,
            operandusNomen: nihil,
            operandusCeteri: nihil,
            operandusDescriptio: nihil
        } novum Annotatio
    }

    # Parse module identifier
    si estNomenAutVerbum(p.specta(0).species) et p.specta(0).locus.linea == linea {
        argumenta.adde(p.specta(0).valor)
        p.procede()
    } secus {
        p.renuncia(ParserErrorCodice.ExpectaturNomen, scriptum("@ imperia ex requires module name, got '§'", p.specta(0).valor))
    }

    redde {
        locus: locus,
        nomen: "imperia",
        argumenta: argumenta,
        targetMappings: nihil,
        radixForms: nihil,
        verteTarget: nihil,
        verteMethod: nihil,
        verteParams: nihil,
        verteTemplate: nihil,
        optioTypus: nihil,
        optioNomen: nihil,
        optioBrevis: nihil,
        optioLongum: nihil,
        optioDescriptio: nihil,
        operandusTypus: nihil,
        operandusNomen: nihil,
        operandusCeteri: nihil,
        operandusDescriptio: nihil
    } novum Annotatio
}

# Parse @ optio annotation for CLI flags
# Old grammar: @ optio <type> <binding> [brevis "x"] [longum "xxx"] [descriptio "..."]
# New grammar: @ optio <name> [brevis "x"] [longum "xxx"] [bivalens] [descriptio "..."]
#
# Detection: If the first token is a type keyword (textus, bivalens, numerus, fractus, lista),
# use old syntax. Otherwise, use new syntax where name comes first.
#
# Example (old): @ optio textus target brevis "t" longum "target" descriptio "Target language"
# Example (new): @ optio target brevis "t" longum "target" descriptio "Target language"
# Example (new): @ optio verbose brevis "v" longum "verbose" bivalens descriptio "Enable verbose"
functio parseOptioAnnotation(in Resolvitor r, de Locus locus, numerus linea) -> Annotatio {
    fixum p = r.parser()

    # Type keywords that indicate old syntax
    fixum typusVerba = ["textus", "bivalens", "numerus", "fractus", "lista"]

    # Check if first token is a type keyword (old syntax) or name (new syntax)
    varia optioTypus = nihil qua textus?
    varia optioNomen = nihil qua textus?
    varia optioBivalens = nihil qua bivalens?

    si estNomenAutVerbum(p.specta(0).species) et p.specta(0).locus.linea == linea {
        fixum primumValor = p.specta(0).valor
        si primumValor inter typusVerba {
            # Old syntax: @ optio <type> <name> ...
            optioTypus = primumValor
            p.procede()

            # Parse binding name (required)
            si estNomenAutVerbum(p.specta(0).species) et p.specta(0).locus.linea == linea {
                optioNomen = p.specta(0).valor
                p.procede()
            } secus {
                p.renuncia(ParserErrorCodice.ExpectaturNomen, scriptum("@ optio requires binding name, got '§'", p.specta(0).valor))
            }
        } secus {
            # New syntax: @ optio <name> [brevis] [longum] [bivalens] [descriptio]
            optioNomen = primumValor
            p.procede()
        }
    } secus {
        p.renuncia(ParserErrorCodice.ExpectaturNomen, scriptum("@ optio requires name, got '§'", p.specta(0).valor))
    }

    # Parse optional brevis "x"
    varia optioBrevis = nihil qua textus?
    si estNomenAutVerbum(p.specta(0).species) et p.specta(0).valor == "brevis" et p.specta(0).locus.linea == linea {
        p.procede()
        si p.specta(0).species == SymbolumGenus.Textus et p.specta(0).locus.linea == linea {
            optioBrevis = p.specta(0).valor
            p.procede()
        } secus {
            p.renuncia(ParserErrorCodice.ExpectaturTextus, "expected string after brevis")
        }
    }

    # Parse optional longum "xxx"
    varia optioLongum = nihil qua textus?
    si estNomenAutVerbum(p.specta(0).species) et p.specta(0).valor == "longum" et p.specta(0).locus.linea == linea {
        p.procede()
        si p.specta(0).species == SymbolumGenus.Textus et p.specta(0).locus.linea == linea {
            optioLongum = p.specta(0).valor
            p.procede()
        } secus {
            p.renuncia(ParserErrorCodice.ExpectaturTextus, "expected string after longum")
        }
    }

    # Parse optional bivalens modifier (new syntax only)
    si estNomenAutVerbum(p.specta(0).species) et p.specta(0).valor == "bivalens" et p.specta(0).locus.linea == linea {
        p.procede()
        optioBivalens = verum
    }

    # Validate: at least one of brevis/longum required
    si nihil optioBrevis et nihil optioLongum {
        p.renuncia(ParserErrorCodice.ExpectaturNomen, "@ optio requires brevis or longum")
    }

    # Parse optional descriptio "..."
    varia optioDescriptio = nihil qua textus?
    si estNomenAutVerbum(p.specta(0).species) et p.specta(0).valor == "descriptio" et p.specta(0).locus.linea == linea {
        p.procede()
        si p.specta(0).species == SymbolumGenus.Textus et p.specta(0).locus.linea == linea {
            optioDescriptio = p.specta(0).valor
            p.procede()
        } secus {
            p.renuncia(ParserErrorCodice.ExpectaturTextus, "expected string after descriptio")
        }
    }

    redde {
        locus: locus,
        nomen: "optio",
        argumenta: [] innatum lista<textus>,
        targetMappings: nihil,
        radixForms: nihil,
        verteTarget: nihil,
        verteMethod: nihil,
        verteParams: nihil,
        verteTemplate: nihil,
        optioTypus: optioTypus,
        optioNomen: optioNomen,
        optioBrevis: optioBrevis,
        optioLongum: optioLongum,
        optioDescriptio: optioDescriptio,
        optioBivalens: optioBivalens,
        operandusTypus: nihil,
        operandusNomen: nihil,
        operandusCeteri: nihil,
        operandusDescriptio: nihil
    } novum Annotatio
}

# Parse @ operandus annotation for CLI positional arguments
# Grammar: @ operandus [ceteri] <type> <name> [descriptio "..."]
# Example: @ operandus textus file descriptio "Input file"
functio parseOperandusAnnotation(in Resolvitor r, de Locus locus, numerus linea) -> Annotatio {
    fixum p = r.parser()

    # Check for optional 'ceteri' prefix (rest/variadic)
    varia operandusCeteri = falsum
    si estNomenAutVerbum(p.specta(0).species) et p.specta(0).valor == "ceteri" et p.specta(0).locus.linea == linea {
        p.procede()
        operandusCeteri = verum
    }

    # Parse type (required)
    varia operandusTypus = nihil qua textus?
    si estNomenAutVerbum(p.specta(0).species) et p.specta(0).locus.linea == linea {
        operandusTypus = p.specta(0).valor
        p.procede()
    } secus {
        p.renuncia(ParserErrorCodice.ExpectaturNomen, scriptum("@ operandus requires type, got '§'", p.specta(0).valor))
    }

    # Parse name (required)
    varia operandusNomen = nihil qua textus?
    si estNomenAutVerbum(p.specta(0).species) et p.specta(0).locus.linea == linea {
        operandusNomen = p.specta(0).valor
        p.procede()
    } secus {
        p.renuncia(ParserErrorCodice.ExpectaturNomen, scriptum("@ operandus requires name, got '§'", p.specta(0).valor))
    }

    # Parse optional descriptio "..."
    varia operandusDescriptio = nihil qua textus?
    si estNomenAutVerbum(p.specta(0).species) et p.specta(0).valor == "descriptio" et p.specta(0).locus.linea == linea {
        p.procede()
        si p.specta(0).species == SymbolumGenus.Textus et p.specta(0).locus.linea == linea {
            operandusDescriptio = p.specta(0).valor
            p.procede()
        } secus {
            p.renuncia(ParserErrorCodice.ExpectaturTextus, "expected string after descriptio")
        }
    }

    redde {
        locus: locus,
        nomen: "operandus",
        argumenta: [] innatum lista<textus>,
        targetMappings: nihil,
        radixForms: nihil,
        verteTarget: nihil,
        verteMethod: nihil,
        verteParams: nihil,
        verteTemplate: nihil,
        optioTypus: nihil,
        optioNomen: nihil,
        optioBrevis: nihil,
        optioLongum: nihil,
        optioDescriptio: nihil,
        optioBivalens: nihil,
        operandusTypus: operandusTypus,
        operandusNomen: operandusNomen,
        operandusCeteri: operandusCeteri,
        operandusDescriptio: operandusDescriptio
    } novum Annotatio
}

# ============================================================================
# MAIN PARSER
# ============================================================================

# Parse all annotations at current position
#
# Consumes @ directives until a non-@ token is found.
# Dispatches to specialized parsers for stdlib annotations.
@ publica
functio parseAnnotationes(in Resolvitor r) -> lista<Annotatio> {
    fixum p = r.parser()
    varia annotationes = [] innatum lista<Annotatio>

    dum p.congruet(SymbolumGenus.At) {
        fixum locus = p.praevius().locus
        fixum linea = locus.linea
        fixum sym = p.specta(0)

        varia nomen = ""
        si estNomenAutVerbum(sym.species) {
            p.procede()
            nomen = sym.valor
        } secus {
            p.renuncia(ParserErrorCodice.ExpectaturNomen, scriptum("got '§'", sym.valor))
            p.procede()
            perge
        }

        # Dispatch to specialized parsers for stdlib annotations
        si nomen == "innatum" aut nomen == "subsidia" {
            annotationes.adde(parseTargetMappingAnnotation(r, nomen, locus, linea))
            perge
        }

        si nomen == "radix" {
            annotationes.adde(parseRadixAnnotation(r, locus, linea))
            perge
        }

        si nomen == "verte" {
            annotationes.adde(parseVerteAnnotation(r, locus, linea))
            perge
        }

        # @ imperia "subcommand" ex moduleIdentifier
        # Mounts commands from imported module under a subcommand namespace
        si nomen == "imperia" {
            annotationes.adde(parseImperiaAnnotation(r, locus, linea))
            perge
        }

        # @ optio <type> <binding> [brevis "x"] [longum "xxx"] [descriptio "..."]
        si nomen == "optio" {
            annotationes.adde(parseOptioAnnotation(r, locus, linea))
            perge
        }

        # @ operandus [ceteri] <type> <name> [descriptio "..."]
        si nomen == "operandus" {
            annotationes.adde(parseOperandusAnnotation(r, locus, linea))
            perge
        }

        # Standard annotation: collect any arguments on the same line
        # This handles test annotations like @ tag "slow", @ temporis 5000
        varia argumenta = [] innatum lista<textus>
        dum non p.estFinis() et p.specta(0).locus.linea == linea {
            fixum argSym = p.specta(0)
            si argSym.species == SymbolumGenus.Textus {
                argumenta.adde(argSym.valor)
                p.procede()
            } sin argSym.species == SymbolumGenus.Numerus {
                argumenta.adde(argSym.valor)
                p.procede()
            } sin estNomenAutVerbum(argSym.species) {
                # Stop at next identifier (likely next annotation or statement)
                rumpe
            } secus {
                rumpe
            }
        }

        annotationes.adde({
            locus: locus,
            nomen: nomen,
            argumenta: argumenta,
            targetMappings: nihil,
            radixForms: nihil,
            verteTarget: nihil,
            verteMethod: nihil,
            verteParams: nihil,
            verteTemplate: nihil,
            optioTypus: nihil,
            optioNomen: nihil,
            optioBrevis: nihil,
            optioLongum: nihil,
            optioDescriptio: nihil,
            optioBivalens: nihil,
            operandusTypus: nihil,
            operandusNomen: nihil,
            operandusCeteri: nihil,
            operandusDescriptio: nihil
        } novum Annotatio)
    }

    redde annotationes
}

# ============================================================================
# SECTION ANNOTATIONS (§)
# ============================================================================

# SectioAnnotatio is defined in ast/radix.fab to avoid circular imports

# Parse all section annotations at current position
#
# Consumes § directives until a non-§ token is found.
# Section annotations are simpler than @ annotations - just name + arguments.
@ publica
functio parseSectiones(in Resolvitor r) -> lista<SectioAnnotatio> {
    fixum p = r.parser()
    varia sectiones = [] innatum lista<SectioAnnotatio>

    dum p.congruet(SymbolumGenus.Sectio) {
        fixum locus = p.praevius().locus
        fixum linea = locus.linea
        fixum sym = p.specta(0)

        varia nomen = ""
        si estNomenAutVerbum(sym.species) {
            p.procede()
            nomen = sym.valor
        } secus {
            p.renuncia(ParserErrorCodice.ExpectaturNomen, scriptum("got '§'", sym.valor))
            p.procede()
            perge
        }

        # Collect all arguments on the same line (identifiers and strings)
        varia argumenta = [] innatum lista<textus>
        dum non p.estFinis() et p.specta(0).locus.linea == linea {
            fixum argSym = p.specta(0)
            si estNomenAutVerbum(argSym.species) {
                argumenta.adde(argSym.valor)
                p.procede()
            } sin argSym.species == SymbolumGenus.Textus {
                argumenta.adde(argSym.valor)
                p.procede()
            } secus {
                # Stop at unexpected token
                rumpe
            }
        }

        sectiones.adde({
            locus: locus,
            nomen: nomen,
            argumenta: argumenta
        } novum SectioAnnotatio)
    }

    redde sectiones
}
