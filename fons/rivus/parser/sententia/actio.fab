# Action Statement Parsers
#
# Simple action statements: redde, rumpe, perge, iace, scribe.
# These are the smallest, most self-contained statement parsers.
#
# GRAMMAR:
#   returnStmt := 'redde' expression?
#   breakStmt := 'rumpe'
#   continueStmt := 'perge'
#   throwStmt := ('iace' | 'mori') expression
#   outputStmt := ('scribe' | 'vide' | 'mone') expression (',' expression)*
#
# LATIN VOCABULARY:
# - redde = return (give back)
# - rumpe = break
# - perge = continue (proceed)
# - iace = throw
# - mori = die/panic
# - scribe = write/log
# - vide = see/debug
# - mone = warn

§ ex "../resolvitor" importa Resolvitor
§ ex "../../ast/positio" importa Locus
§ ex "../../ast/expressia" importa Expressia
§ ex "../../ast/sententia" importa Sententia, ScribeGradus
§ ex "../../ast/lexema" importa SymbolumGenus
§ ex "../errores" importa ParserErrorCodice

# Parse return statement
#
# GRAMMAR: returnStmt := 'redde' expression?
#
# Return value is optional - bare 'redde' returns void.
# Doesn't consume expression if next token is closing brace.
@ publica
functio parseReddeSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'redde' keyword
    p.expectaVerbum("redde", ParserErrorCodice.ExpectaturRedde)

    # Check if there's a return value
    # Don't parse expression if we hit closing brace or end
    varia valor = nihil qua Expressia?

    si non p.proba(SymbolumGenus.UncusDex) et non p.estFinis() {
        valor = r.expressia()
    }

    redde finge ReddeSententia {
        locus: locus,
        valor: valor
    } qua Sententia
}

# Parse break statement
#
# GRAMMAR: breakStmt := 'rumpe'
#
# Exits the innermost loop.
@ publica
functio parseRumpeSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'rumpe' keyword (already validated by caller)
    p.procede()

    redde finge RumpeSententia {
        locus: locus
    } qua Sententia
}

# Parse continue statement
#
# GRAMMAR: continueStmt := 'perge'
#
# Skips to next loop iteration.
@ publica
functio parsePergeSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'perge' keyword (already validated by caller)
    p.procede()

    redde finge PergeSententia {
        locus: locus
    } qua Sententia
}

# Parse throw/panic statement
#
# GRAMMAR: throwStmt := ('iace' | 'mori') expression
#
# Two severity levels:
# - iace (throw): recoverable, can be caught
# - mori (die): fatal/panic, unrecoverable
@ publica
functio parseIaceSententia(Resolvitor r, bivalens fatale) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume keyword (iace or mori, already validated by caller)
    p.procede()

    # Parse the error expression
    fixum argumentum = r.expressia()

    redde finge IaceSententia {
        locus: locus,
        fatale: fatale,
        argumentum: argumentum
    } qua Sententia
}

# Parse output statement (scribe/vide/mone)
#
# GRAMMAR: outputStmt := ('scribe' | 'vide' | 'mone') scribeItem (',' scribeItem)*
#          scribeItem := STRING expression* | expression
#
# Maps to console output:
# - scribe → console.log
# - vide → console.debug
# - mone → console.warn
#
# STRING DESUGARING: String literals are automatically wrapped in scriptum expressions.
# The § placeholder count determines how many following arguments are consumed:
#   scribe "Found § errors", count  →  scribe scriptum("Found § errors", count)
#   scribe "hello"                  →  scribe scriptum("hello")
@ publica
functio parseScribeSententia(Resolvitor r, ScribeGradus gradus) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume keyword (already validated by caller)
    p.procede()

    varia argumenta = [] innatum lista<Expressia>
    argumenta.adde(parseScribeElementum(r))

    # Parse additional comma-separated items
    dum p.congruet(SymbolumGenus.Coma) {
        argumenta.adde(parseScribeElementum(r))
    }

    redde finge ScribeSententia {
        locus: locus,
        gradus: gradus,
        argumenta: argumenta
    } qua Sententia
}

# Parse a single scribe item, converting string literals to scriptum expressions.
#
# WHY: Syntactic sugar - string literals in scribe statements are implicitly
# wrapped in scriptum() for consistent formatting semantics. The § placeholder
# count determines how many following comma-separated arguments are consumed.
functio parseScribeElementum(Resolvitor r) -> Expressia {
    fixum p = r.parser()

    # String literals become scriptum expressions
    si p.proba(SymbolumGenus.Textus) {
        fixum token = p.procede()
        fixum locus = token.locus
        fixum textus exemplar = token.valor

        # Count § placeholders to determine how many args to consume
        varia placeholderNumerus = 0
        varia numerus i = 0
        dum i < exemplar.longitudo() {
            si exemplar[i] == "§" {
                placeholderNumerus += 1
            }
            i += 1
        }

        varia scriptumArgumenta = [] innatum lista<Expressia>

        varia numerus j = 0
        dum j < placeholderNumerus {
            si non p.congruet(SymbolumGenus.Coma) {
                p.renuncia(
                    ParserErrorCodice.ExpectaturExpressia,
                    scriptum("Expected argument for § placeholder (need §, got §)", placeholderNumerus, j)
                )
                rumpe
            }
            scriptumArgumenta.adde(r.expressia())
            j += 1
        }

        redde finge ScriptumExpressia {
            locus: locus,
            exemplar: exemplar,
            argumenta: scriptumArgumenta
        } qua Expressia
    }

    # Non-string expressions are parsed normally
    redde r.expressia()
}
