# Control Flow Statement Parsers
#
# Handles: si, dum, ex, de, in (conditionals and loops)
#
# GRAMMAR:
#   siStmt := 'si' expr blockStmt ('secus' 'si' expr blockStmt)* ('secus' blockStmt)?
#           | 'si' expr blockStmt 'cape' IDENT blockStmt
#   dumStmt := 'dum' expr blockStmt ('cape' IDENT blockStmt)?
#   exStmt := 'ex' expr 'pro' IDENT blockStmt ('cape' IDENT blockStmt)?
#   deStmt := 'de' expr 'pro' IDENT blockStmt ('cape' IDENT blockStmt)?
#   inStmt := 'in' expr blockStmt
#
# LATIN VOCABULARY:
# - si = if
# - secus = else
# - sin = else if
# - dum = while
# - ex = from (iterate values)
# - de = from (iterate keys)
# - in = into (mutation)
# - pro = for
# - cape = catch

§ ex "../resolvitor" importa Resolvitor
§ ex "../../ast/positio" importa Locus
§ ex "../../ast/expressia" importa Expressia
§ ex "../../ast/sententia" importa Sententia, CapeClausula, IteratioGenus
§ ex "../../ast/lexema" importa SymbolumGenus
§ ex "../errores" importa ParserErrorCodice
§ ex "./massa" importa parseMassaSententia

# ============================================================================
# CONDITIONAL STATEMENTS
# ============================================================================

# Parse if statement
#
# GRAMMAR:
#   siStmt := 'si' expr blockStmt ('secus' 'si' expr blockStmt)* ('secus' blockStmt)?
#           | 'si' expr blockStmt 'cape' IDENT blockStmt
#
# Examples:
#   si x > 0 { scribe "positive" }
#   si x > 0 { ... } secus { ... }
#   si x > 0 { ... } sin x < 0 { ... } secus { ... }
#   si fetch() cape err { handle(err) }
@ publica
functio parseSiSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'si'
    p.expectaVerbum("si", ParserErrorCodice.ExpectaturSi)

    # Parse condition
    fixum condicio = r.expressia()

    # Parse consequent body
    fixum consequens = parseCorpus(r)

    # Check for optional catch (si expr { } cape err { })
    varia cape = nihil qua CapeClausula?
    si p.probaVerbum("cape") {
        cape = parseCapeClausula(r)
    }

    # Check for else/else-if chain
    varia alternans = nihil qua Sententia?

    si p.probaVerbum("sin") {
        alternans = parseSinSententia(r)
    } sin p.probaVerbum("secus") {
        p.procede()
        si p.probaVerbum("si") {
            alternans = parseSiSententia(r)
        } secus {
            alternans = parseCorpusAutSententia(r)
        }
    }

    redde finge SiSententia {
        locus: locus,
        condicio: condicio,
        consequens: consequens,
        alternans: alternans,
        cape: cape
    } qua Sententia
}

# ============================================================================
# LOOP STATEMENTS
# ============================================================================

# Parse while statement
#
# GRAMMAR: dumStmt := 'dum' expr blockStmt ('cape' IDENT blockStmt)?
#
# Examples:
#   dum x > 0 { x = x - 1 }
#   dum iter.sequens() cape err { handle(err) }
@ publica
functio parseDumSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'dum'
    p.expectaVerbum("dum", ParserErrorCodice.ExpectaturDum)

    # Parse condition
    fixum condicio = r.expressia()

    # Parse body
    fixum corpus = parseCorpus(r)

    # Optional catch
    varia cape = nihil qua CapeClausula?
    si p.probaVerbum("cape") {
        cape = parseCapeClausula(r)
    }

    redde finge DumSententia {
        locus: locus,
        condicio: condicio,
        corpus: corpus,
        cape: cape
    } qua Sententia
}

# Parse for-of loop (iterate values)
#
# GRAMMAR: exStmt := 'ex' expr 'pro' IDENT blockStmt ('cape' IDENT blockStmt)?
#
# Examples:
#   ex items pro item { scribe item }
#   ex 0 ante 10 pro i { scribe i }
@ publica
functio parseExSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'ex'
    p.expectaVerbum("ex", ParserErrorCodice.ExpectaturEx)

    # Parse iterable expression
    fixum iterabile = r.expressia()

    varia asynca = falsum
    varia expectaPro = verum
    si p.probaVerbum("fiet") {
        asynca = verum
        expectaPro = falsum
        p.procede()
    }

    # Expect 'pro' for sync loops
    si expectaPro {
        p.expectaVerbum("pro", ParserErrorCodice.ExpectaturPro)
    }

    # Parse variable name
    fixum nomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
    fixum variabilis = nomenSym.valor

    # Parse body
    fixum corpus = parseCorpus(r)

    # Optional catch
    varia cape = nihil qua CapeClausula?
    si p.probaVerbum("cape") {
        cape = parseCapeClausula(r)
    }

    redde finge IteratioSententia {
        locus: locus,
        species: IteratioGenus.Ex,
        variabilis: variabilis,
        iterabile: iterabile,
        corpus: corpus,
        asynca: asynca,
        cape: cape
    } qua Sententia
}

# Parse for-in loop (iterate keys)
#
# GRAMMAR: deStmt := 'de' expr 'pro' IDENT blockStmt ('cape' IDENT blockStmt)?
#
# Examples:
#   de obiectum pro clavis { scribe clavis }
@ publica
functio parseDeSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'de'
    p.expectaVerbum("de", ParserErrorCodice.ExpectaturDe)

    # Parse iterable expression
    fixum iterabile = r.expressia()

    # Expect 'pro'
    p.expectaVerbum("pro", ParserErrorCodice.ExpectaturPro)

    # Parse variable name
    fixum nomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
    fixum variabilis = nomenSym.valor

    # Parse body
    fixum corpus = parseCorpus(r)

    # Optional catch
    varia cape = nihil qua CapeClausula?
    si p.probaVerbum("cape") {
        cape = parseCapeClausula(r)
    }

    redde finge IteratioSententia {
        locus: locus,
        species: IteratioGenus.De,
        variabilis: variabilis,
        iterabile: iterabile,
        corpus: corpus,
        asynca: falsum,
        cape: cape
    } qua Sententia
}

# ============================================================================
# HELPERS
# ============================================================================

# Parse catch clause
#
# GRAMMAR: capeClause := 'cape' IDENT blockStmt
#
# Example: cape err { handle(err) }
@ publica
functio parseCapeClausula(Resolvitor r) -> CapeClausula {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    p.expectaVerbum("cape", ParserErrorCodice.ExpectaturCape)

    # Parse error binding name
    fixum paramSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
    fixum param = paramSym.valor

    # Parse catch body
    fixum corpus = parseMassaSententia(r)

    redde {
        locus: locus,
        param: param,
        corpus: corpus
    } qua CapeClausula
}

# Parse a statement body (block or inline form)
#
# GRAMMAR:
#   body := 'tacet' | 'reddit' expr | 'iacit' expr | 'moritor' expr | 'ergo' stmt | block
#
# Used after conditions where a delimiter (ergo) is required for bare statements.
@ publica
functio parseCorpus(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    si p.probaVerbum("tacet") {
        p.procede()
        redde finge TacetSententia { locus: locus } qua Sententia
    }

    si p.probaVerbum("reddit") {
        p.procede()
        fixum valor = r.expressia()
        redde finge ReddeSententia { locus: locus, valor: valor } qua Sententia
    }

    si p.probaVerbum("iacit") {
        p.procede()
        fixum argumentum = r.expressia()
        redde finge IaceSententia { locus: locus, fatale: falsum, argumentum: argumentum } qua Sententia
    }

    si p.probaVerbum("moritor") {
        p.procede()
        fixum argumentum = r.expressia()
        redde finge IaceSententia { locus: locus, fatale: verum, argumentum: argumentum } qua Sententia
    }

    si p.probaVerbum("ergo") {
        p.procede()
        redde r.sententia()
    }

    redde parseMassaSententia(r) qua Sententia
}

# Parse a statement body without requiring 'ergo' for bare statements
#
# Used after secus/ceterum where no condition exists, so no delimiter is needed.
@ publica
functio parseCorpusAutSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    si p.probaVerbum("tacet") {
        p.procede()
        redde finge TacetSententia { locus: locus } qua Sententia
    }

    si p.probaVerbum("reddit") {
        p.procede()
        fixum valor = r.expressia()
        redde finge ReddeSententia { locus: locus, valor: valor } qua Sententia
    }

    si p.probaVerbum("iacit") {
        p.procede()
        fixum argumentum = r.expressia()
        redde finge IaceSententia { locus: locus, fatale: falsum, argumentum: argumentum } qua Sententia
    }

    si p.probaVerbum("moritor") {
        p.procede()
        fixum argumentum = r.expressia()
        redde finge IaceSententia { locus: locus, fatale: verum, argumentum: argumentum } qua Sententia
    }

    si p.proba(SymbolumGenus.UncusSin) {
        redde parseMassaSententia(r) qua Sententia
    }

    redde r.sententia()
}

# Parse a "sin" (else-if) clause
@ publica
functio parseSinSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    p.expectaVerbum("sin", ParserErrorCodice.ExpectaturSi)

    fixum condicio = r.expressia()
    fixum consequens = parseCorpus(r)

    varia alternans = nihil qua Sententia?
    si p.probaVerbum("sin") {
        alternans = parseSinSententia(r)
    } sin p.probaVerbum("secus") {
        p.procede()
        si p.probaVerbum("si") {
            alternans = parseSiSententia(r)
        } secus {
            alternans = parseCorpusAutSententia(r)
        }
    }

    redde finge SiSententia {
        locus: locus,
        condicio: condicio,
        consequens: consequens,
        alternans: alternans,
        cape: nihil
    } qua Sententia
}
