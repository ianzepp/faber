# Control Flow Statement Parsers
#
# Handles: si, dum, itera (ex/de/pro), in (conditionals and loops)
#
# GRAMMAR:
#   siStmt := 'si' expr blockStmt ('secus' 'si' expr blockStmt)* ('secus' blockStmt)?
#           | 'si' expr blockStmt 'cape' IDENT blockStmt
#   dumStmt := 'dum' expr blockStmt ('cape' IDENT blockStmt)?
#   iteraStmt := 'itera' ('ex'|'de'|'pro') expr ('fixum'|'varia') (IDENT | arrayPattern) blockStmt ('cape' IDENT blockStmt)?
#   inStmt := 'in' expr blockStmt
#
# LATIN VOCABULARY:
# - si = if
# - secus = else
# - sin = else if
# - dum = while
# - ex = from (iterate values from collection)
# - de = from (iterate keys from collection)
# - pro = for (iterate range)
# - in = into (mutation)
# - fixum = const binding
# - varia = mutable binding
# - cape = catch

importa ex "../resolvitor" privata Resolvitor
importa ex "../nucleus" privata Parser
importa ex "../../ast/positio" privata Locus
importa ex "../../ast/expressia" privata Expressia
importa ex "../../ast/sententia" privata Sententia
importa ex "../../ast/sententia" privata CapeClausula
importa ex "../../ast/sententia" privata IteratioGenus
importa ex "../../ast/sententia" privata IteratioVariabilis
importa ex "../../ast/lexema" privata SymbolumGenus
importa ex "../errores" privata ParserErrorCodice
importa ex "./massa" privata parseMassaSententia
importa ex "./varia" privata parseSeriesDestructura

# ============================================================================
# CONDITIONAL STATEMENTS
# ============================================================================

# Parse if statement
#
# GRAMMAR:
#   siStmt := 'si' expr blockStmt ('secus' 'si' expr blockStmt)* ('secus' blockStmt)?
#           | 'si' expr blockStmt 'cape' IDENT blockStmt
#
# Examples:
#   si x > 0 { scribe "positive" }
#   si x > 0 { ... } secus { ... }
#   si x > 0 { ... } sin x < 0 { ... } secus { ... }
#   si fetch() cape err { handle(err) }
@ publica
functio parseSiSententia(in Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'si'
    p.expectaVerbum("si", ParserErrorCodice.ExpectaturSi)

    # Parse condition
    fixum condicio = r.expressia()

    # Parse consequent body
    fixum consequens = parseCorpus(r)

    # Check for optional catch (si expr { } cape err { })
    varia cape = nihil qua si CapeClausula
    si p.probaVerbum("cape") {
        cape = parseCapeClausula(r)
    }

    # Check for else/else-if chain
    varia alternans = nihil qua si Sententia

    si p.probaVerbum("sin") {
        alternans = parseSinSententia(r)
    } sin p.probaVerbum("secus") {
        p.procede()
        # SYNTAXIS ALIENA: 'secus si' (should be 'sin')
        si p.probaVerbum("si") {
            p.renuncia(ParserErrorCodice.SyntaxisAlienaSecusSi)
            p.procede()  # si
            fixum cond = r.expressia()
            fixum cons = parseCorpus(r)
            # Continue parsing the else-if chain
            alternans = finge SiSententia {
                locus: p.locusActualis(),
                condicio: cond,
                consequens: cons,
                alternans: nihil,
                cape: nihil
            } qua Sententia
        } secus {
            alternans = parseCorpusAutSententia(r)
        }
    } sin p.probaVerbum("aliter") {
        # SYNTAXIS ALIENA: 'aliter' / 'aliter si' (false Latin for else/else-if)
        p.renuncia(ParserErrorCodice.SyntaxisAlienaAliter)
        p.procede()  # aliter
        # Check for 'aliter si' (else-if) vs 'aliter' (else)
        si p.probaVerbum("si") {
            p.procede()  # si
            fixum cond = r.expressia()
            alternans = parseCorpus(r)
        } secus {
            alternans = parseCorpusAutSententia(r)
        }
    }

    redde finge SiSententia {
        locus: locus,
        condicio: condicio,
        consequens: consequens,
        alternans: alternans,
        cape: cape
    } qua Sententia
}

# ============================================================================
# LOOP STATEMENTS
# ============================================================================

# Parse while statement
#
# GRAMMAR: dumStmt := 'dum' expr blockStmt ('cape' IDENT blockStmt)?
#
# Examples:
#   dum x > 0 { x = x - 1 }
#   dum iter.sequens() cape err { handle(err) }
@ publica
functio parseDumSententia(in Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'dum'
    p.expectaVerbum("dum", ParserErrorCodice.ExpectaturDum)

    # Parse condition
    fixum condicio = r.expressia()

    # Parse body
    fixum corpus = parseCorpus(r)

    # Optional catch
    varia cape = nihil qua si CapeClausula
    si p.probaVerbum("cape") {
        cape = parseCapeClausula(r)
    }

    redde finge DumSententia {
        locus: locus,
        condicio: condicio,
        corpus: corpus,
        cape: cape
    } qua Sententia
}

# Parse iteration loop (itera ex/itera de/itera pro)
#
# GRAMMAR: iteraStmt := 'itera' ('ex'|'de'|'pro') expr ('fixum'|'varia') (IDENT | arrayPattern) blockStmt ('cape' IDENT blockStmt)?
#
# Examples:
#   itera ex items fixum item { scribe item }
#   itera pro 0 ante 10 varia i { scribe i }
#   itera de obiectum fixum clavis { scribe clavis }
@ publica
functio parseIteraSententia(in Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'itera'
    p.expectaVerbum("itera", ParserErrorCodice.ExpectaturEx)

    # Determine species: ex (values), de (keys), or pro (ranges)
    varia species = IteratioGenus.Ex
    si p.probaVerbum("ex") {
        p.procede()
        species = IteratioGenus.Ex
    } sin p.probaVerbum("de") {
        p.procede()
        species = IteratioGenus.De
    } sin p.probaVerbum("pro") {
        p.procede()
        species = IteratioGenus.Pro
    } secus {
        p.renuncia(ParserErrorCodice.InvalidumExDeInitium, "expected 'ex', 'de', or 'pro' after 'itera'")
    }

    # Parse iterable expression
    fixum iterabile = r.expressia()

    # Validate species-expression match
    varia estAmbitus = falsum
    discerne iterabile {
        casu AmbitusExpressia { estAmbitus = verum }
        ceterum tacet
    }

    si species == IteratioGenus.Pro et non estAmbitus {
        p.renuncia(ParserErrorCodice.InvalidumExDeInitium, "'itera pro' requires a range expression (use .. or ante/usque)")
    } sin estAmbitus et species != IteratioGenus.Pro {
        p.renuncia(ParserErrorCodice.InvalidumExDeInitium, "range expressions require 'itera pro', not 'itera " + (species == IteratioGenus.Ex sic "ex" secus "de") + "'")
    }

    # Parse binding keyword: fixum (const) or varia (let)
    varia mutabilis = falsum
    si p.probaVerbum("varia") {
        mutabilis = verum
        p.procede()
    } secus {
        p.expectaVerbum("fixum", ParserErrorCodice.ExpectaturFixum)
    }

    # Parse variable name or array pattern
    varia variabilis = nihil qua si IteratioVariabilis
    si p.proba(SymbolumGenus.QuadratusSin) {
        fixum elementa = parseSeriesDestructura(r)
        variabilis = finge Series { elementa: elementa } qua IteratioVariabilis
    } secus {
        fixum nomenSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
        variabilis = finge Nomen { valor: nomenSym.valor } qua IteratioVariabilis
    }

    # Parse body
    fixum corpus = parseCorpus(r)

    # Optional catch
    varia cape = nihil qua si CapeClausula
    si p.probaVerbum("cape") {
        cape = parseCapeClausula(r)
    }

    redde finge IteratioSententia {
        locus: locus,
        species: species,
        variabilis: variabilis qua IteratioVariabilis,
        iterabile: iterabile,
        corpus: corpus,
        asynca: falsum,
        mutabilis: mutabilis,
        cape: cape
    } qua Sententia
}

# Parse for-of loop (DEPRECATED - now requires 'itera ex')
#
# GRAMMAR: exStmt := 'ex' expr ('fixum'|'varia') IDENT blockStmt
#
# This function now emits an error directing users to use 'itera ex' syntax
@ publica
functio parseExSententia(in Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Report deprecation error
    p.renuncia(ParserErrorCodice.SyntaxisAlienaExDe)

    # Skip 'ex' and attempt to parse the rest for better error recovery
    p.procede()

    # Parse iterable expression
    fixum iterabile = r.expressia()

    # Parse binding keyword: fixum (const) or varia (let)
    varia mutabilis = falsum
    si p.probaVerbum("varia") {
        mutabilis = verum
        p.procede()
    } sin p.probaVerbum("fixum") {
        p.procede()
    }

    # Parse variable name or array pattern
    varia variabilis = nihil qua si IteratioVariabilis
    si p.proba(SymbolumGenus.QuadratusSin) {
        fixum elementa = parseSeriesDestructura(r)
        variabilis = finge Series { elementa: elementa } qua IteratioVariabilis
    } sin p.proba(SymbolumGenus.Nomen) {
        fixum nomenSym = p.procede()
        variabilis = finge Nomen { valor: nomenSym.valor } qua IteratioVariabilis
    } secus {
        variabilis = finge Nomen { valor: "_" } qua IteratioVariabilis
    }

    # Parse body
    fixum corpus = parseCorpus(r)

    # Optional catch
    varia cape = nihil qua si CapeClausula
    si p.probaVerbum("cape") {
        cape = parseCapeClausula(r)
    }

    redde finge IteratioSententia {
        locus: locus,
        species: IteratioGenus.Ex,
        variabilis: variabilis qua IteratioVariabilis,
        iterabile: iterabile,
        corpus: corpus,
        asynca: falsum,
        mutabilis: mutabilis,
        cape: cape
    } qua Sententia
}

# Parse for-in loop (DEPRECATED - now requires 'itera de')
#
# GRAMMAR: deStmt := 'de' expr ('fixum'|'varia') IDENT blockStmt
#
# This function now emits an error directing users to use 'itera de' syntax
@ publica
functio parseDeSententia(in Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Report deprecation error
    p.renuncia(ParserErrorCodice.SyntaxisAlienaExDe)

    # Skip 'de' and attempt to parse the rest for better error recovery
    p.procede()

    # Parse iterable expression
    fixum iterabile = r.expressia()

    # Parse binding keyword: fixum (const) or varia (let)
    varia mutabilis = falsum
    si p.probaVerbum("varia") {
        mutabilis = verum
        p.procede()
    } sin p.probaVerbum("fixum") {
        p.procede()
    }

    # Parse variable name or array pattern
    varia variabilis = nihil qua si IteratioVariabilis
    si p.proba(SymbolumGenus.QuadratusSin) {
        fixum elementa = parseSeriesDestructura(r)
        variabilis = finge Series { elementa: elementa } qua IteratioVariabilis
    } sin p.proba(SymbolumGenus.Nomen) {
        fixum nomenSym = p.procede()
        variabilis = finge Nomen { valor: nomenSym.valor } qua IteratioVariabilis
    } secus {
        variabilis = finge Nomen { valor: "_" } qua IteratioVariabilis
    }

    # Parse body
    fixum corpus = parseCorpus(r)

    # Optional catch
    varia cape = nihil qua si CapeClausula
    si p.probaVerbum("cape") {
        cape = parseCapeClausula(r)
    }

    redde finge IteratioSententia {
        locus: locus,
        species: IteratioGenus.De,
        variabilis: variabilis qua IteratioVariabilis,
        iterabile: iterabile,
        corpus: corpus,
        asynca: falsum,
        mutabilis: mutabilis,
        cape: cape
    } qua Sententia
}

# ============================================================================
# HELPERS
# ============================================================================

# Parse catch clause
#
# GRAMMAR: capeClause := 'cape' IDENT blockStmt
#
# Example: cape err { handle(err) }
@ publica
functio parseCapeClausula(in Resolvitor r) -> CapeClausula {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    p.expectaVerbum("cape", ParserErrorCodice.ExpectaturCape)

    # Parse error binding name
    fixum paramSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
    fixum param = paramSym.valor

    # Parse catch body
    fixum corpus = parseMassaSententia(r)

    redde {
        locus: locus,
        param: param,
        corpus: corpus
    } novum CapeClausula
}

# Parse a statement body (block or inline form)
#
# GRAMMAR:
#   body := 'tacet' | 'reddit' expr | 'iacit' expr | 'moritor' expr | 'ergo' stmt | block
#
# Used after conditions where a delimiter (ergo) is required for bare statements.
@ publica
functio parseCorpus(in Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    si p.probaVerbum("tacet") {
        p.procede()
        redde finge TacetSententia { locus: locus } qua Sententia
    }

    si p.probaVerbum("reddit") {
        p.procede()
        fixum valor = r.expressia()
        redde finge ReddeSententia { locus: locus, valor: valor } qua Sententia
    }

    si p.probaVerbum("iacit") {
        p.procede()
        fixum argumentum = r.expressia()
        redde finge IaceSententia { locus: locus, fatale: falsum, argumentum: argumentum } qua Sententia
    }

    si p.probaVerbum("moritor") {
        p.procede()
        fixum argumentum = r.expressia()
        redde finge IaceSententia { locus: locus, fatale: verum, argumentum: argumentum } qua Sententia
    }

    si p.probaVerbum("ergo") {
        p.procede()

        # Reject compound statements after ergo
        si estCompositumVerbum(p) {
            p.renuncia(ParserErrorCodice.CompositumPostErgo, scriptum("got 'ยง'", p.specta(0).valor))
        }

        redde r.sententia()
    }

    redde parseMassaSententia(r) qua Sententia
}

# Parse a statement body requiring braces or 'ergo' for statements
#
# Used after secus/ceterum. Requires either:
#   - { block }
#   - ergo + simple statement (not compound)
#   - Shortcuts: tacet, reddit, iacit, moritor
@ publica
functio parseCorpusAutSententia(in Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    si p.probaVerbum("tacet") {
        p.procede()
        redde finge TacetSententia { locus: locus } qua Sententia
    }

    si p.probaVerbum("reddit") {
        p.procede()
        fixum valor = r.expressia()
        redde finge ReddeSententia { locus: locus, valor: valor } qua Sententia
    }

    si p.probaVerbum("iacit") {
        p.procede()
        fixum argumentum = r.expressia()
        redde finge IaceSententia { locus: locus, fatale: falsum, argumentum: argumentum } qua Sententia
    }

    si p.probaVerbum("moritor") {
        p.procede()
        fixum argumentum = r.expressia()
        redde finge IaceSententia { locus: locus, fatale: verum, argumentum: argumentum } qua Sententia
    }

    # Block
    si p.proba(SymbolumGenus.UncusSin) {
        redde parseMassaSententia(r) qua Sententia
    }

    # ergo + simple statement
    si p.probaVerbum("ergo") {
        p.procede()

        # Reject compound statements after ergo
        si estCompositumVerbum(p) {
            p.renuncia(ParserErrorCodice.CompositumPostErgo, scriptum("got 'ยง'", p.specta(0).valor))
        }

        redde r.sententia()
    }

    # Neither block nor ergo - error
    p.renuncia(ParserErrorCodice.ExpectaturUncusVelErgo, scriptum("got 'ยง'", p.specta(0).valor))
    redde finge TacetSententia { locus: locus } qua Sententia
}

# Check if current token is a compound statement keyword
functio estCompositumVerbum(in Parser p) -> bivalens {
    si p.probaVerbum("si") { redde verum }
    si p.probaVerbum("sin") { redde verum }
    si p.probaVerbum("dum") { redde verum }
    si p.probaVerbum("itera") { redde verum }
    si p.probaVerbum("elige") { redde verum }
    si p.probaVerbum("discerne") { redde verum }
    si p.probaVerbum("custodi") { redde verum }
    si p.probaVerbum("tempta") { redde verum }
    si p.probaVerbum("fac") { redde verum }
    si p.probaVerbum("cura") { redde verum }
    redde falsum
}

# Parse a "sin" (else-if) clause
@ publica
functio parseSinSententia(in Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    p.expectaVerbum("sin", ParserErrorCodice.ExpectaturSi)

    fixum condicio = r.expressia()
    fixum consequens = parseCorpus(r)

    varia alternans = nihil qua si Sententia
    si p.probaVerbum("sin") {
        alternans = parseSinSententia(r)
    } sin p.probaVerbum("secus") {
        p.procede()
        # SYNTAXIS ALIENA: 'secus si' (should be 'sin')
        si p.probaVerbum("si") {
            p.renuncia(ParserErrorCodice.SyntaxisAlienaSecusSi)
            p.procede()  # si
            fixum cond = r.expressia()
            fixum cons = parseCorpus(r)
            alternans = finge SiSententia {
                locus: p.locusActualis(),
                condicio: cond,
                consequens: cons,
                alternans: nihil,
                cape: nihil
            } qua Sententia
        } secus {
            alternans = parseCorpusAutSententia(r)
        }
    } sin p.probaVerbum("aliter") {
        # SYNTAXIS ALIENA: 'aliter' / 'aliter si' (false Latin for else/else-if)
        p.renuncia(ParserErrorCodice.SyntaxisAlienaAliter)
        p.procede()  # aliter
        # Check for 'aliter si' (else-if) vs 'aliter' (else)
        si p.probaVerbum("si") {
            p.procede()  # si
            fixum cond = r.expressia()
            alternans = parseCorpus(r)
        } secus {
            alternans = parseCorpusAutSententia(r)
        }
    }

    redde finge SiSententia {
        locus: locus,
        condicio: condicio,
        consequens: consequens,
        alternans: alternans,
        cape: nihil
    } qua Sententia
}
