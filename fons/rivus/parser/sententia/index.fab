# Statement Dispatcher
#
# Central dispatcher for parsing statements based on leading keyword.
# Handles comment attachment and error recovery.
#
# GRAMMAR:
#   statement := importDecl | varDecl | funcDecl | typeAliasDecl | ifStmt
#              | whileStmt | forStmt | returnStmt | throwStmt | tryStmt
#              | blockStmt | exprStmt | ...
#
# LATIN VOCABULARY:
# - sententia = statement (sentence/thought)
# - declara = declare
# - imperium = control (command)

§ ex "../resolvitor" importa Resolvitor
§ ex "../../ast/positio" importa Locus
§ ex "../../ast/expressia" importa Expressia
§ ex "../../ast/sententia" importa Sententia, ScribeGradus, MorphologiaDeclaratio, Visibilitas, ProbaModificator
§ ex "../../ast/lexema" importa SymbolumGenus, VerbumId
§ ex "../../ast/radix" importa NodusRadix
§ ex "../../ast/annotatio" importa Annotatio
§ ex "../errores" importa ParserErrorCodice
§ ex "./annotatio" importa parseAnnotationes, parseSectiones
§ ex "../../ast/radix" importa SectioAnnotatio

# Import statement parsers from submodules
§ ex "./actio" importa parseReddeSententia, parseRumpeSententia, parsePergeSententia, parseIaceSententia, parseScribeSententia
§ ex "./declara" importa parseFunctioDeclaratio, parseGenusDeclaratio, parsePactumDeclaratio, parseOrdoDeclaratio, parseDiscretioDeclaratio, parseTypusAliasDeclaratio, parseImportaSententia
§ ex "./error" importa parseTemptaSententia, parseFacSententia, parseAdfirmaSententia
§ ex "./imperium" importa parseSiSententia, parseDumSententia, parseExSententia, parseDeSententia
§ ex "./fluxus" importa parseEligeSententia, parseDiscerneSententia, parseCustodiSententia
§ ex "./initus" importa parseIncipitSententia, parseIncipietSententia, parseCuraSententia, parseAdSententia
§ ex "./massa" importa parseMassaSententia, parseExpressiaSententia
§ ex "./varia" importa parseVariaSententia, parseDestructuraSententia, parseNomenVelVerbum
§ ex "./proba" importa parseProbandumSententia, parseProbaSententia, parsePraeparaMassa

# Parse a statement
#
# Main dispatcher that routes to appropriate parser based on leading token.
# Collects and attaches leading/trailing comments.
@ publica
functio parseSententia(Resolvitor r) -> Sententia {
    fixum p = r.parser()

    # Capture any leading comments before the statement.
    p.colligeNotas()

    fixum stmt = parseSententiaSineNotis(r)

    # Attach leading/trailing comments (if any).
    fixum radix = stmt qua ignotum novum NodusRadix
    radix.notaePrae = p.consumeNotas()
    radix.notaePost = p.colligeNotamTrahentem(radix.locus.linea)

    redde stmt
}

functio parseSententiaSineNotis(Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum sym = p.specta(0)

    # Section annotation prefix (§) - may be build config or sectional import
    si sym.species === SymbolumGenus.Sectio {
        # Check for sectional import: § ex (STRING|IDENT) importa
        fixum nextSym = p.specta(1)
        si (nextSym.species === SymbolumGenus.Verbum) && (nextSym.verbumId === VerbumId.Ex) {
            fixum sourceSym = p.specta(2)
            si (sourceSym.species === SymbolumGenus.Nomen) || (sourceSym.species === SymbolumGenus.Textus) {
                fixum importaSym = p.specta(3)
                si (importaSym.species === SymbolumGenus.Verbum) && (importaSym.verbumId === VerbumId.Importa) {
                    p.procede() # consume §
                    redde parseImportaSententia(r)
                }
            }
        }
        # Otherwise it's file-level build configuration
        fixum sectiones = parseSectiones(r)
        # Accumulate on parser for later extraction by parseProgramma
        ex sectiones fixum s {
            p.sectiones.adde(s)
        }
        redde parseSententiaSineNotis(r)
    }

    # Annotation prefix (e.g. `@ futura`)
    si sym.species === SymbolumGenus.At {
        fixum annotationes = parseAnnotationes(r)

        fixum stmt = parseSententiaSineNotis(r)

        # Store all annotations on statements that support the annotationes field
        discerne stmt {
            casu FunctioDeclaratio ut f {
                f.annotationes = annotationes
            }
            casu IncipitSententia ut i {
                i.annotationes = annotationes
            }
            casu IncipietSententia ut i {
                i.annotationes = annotationes
            }
            casu _ { }
        }

        # Process individual annotation effects
        ex annotationes fixum a {
            # Check for visibility annotations
            varia visibilitas = nihil qua Visibilitas?
            si a.nomen inter ["publicum", "publica", "publicus"] {
                visibilitas = Visibilitas.Publica
            } sin a.nomen inter ["protectum", "protecta", "protectus"] {
                visibilitas = Visibilitas.Protecta
            } sin a.nomen inter ["privatum", "privata", "privatus"] {
                visibilitas = Visibilitas.Privata
            }

            discerne stmt {
                casu FunctioDeclaratio ut f {
                    si a.nomen == "futura" {
                        f.asynca = verum
                    }
                    si a.nomen == "cursor" {
                        f.generator = verum
                    }
                    si a.nomen == "radix" {
                        f.morphologia = { locus: a.locus, formae: a.argumenta } novum MorphologiaDeclaratio
                    }
                    si a.nomen == "externa" {
                        f.externa = verum
                    }
                    si nonnihil visibilitas {
                        f.visibilitas = visibilitas
                    }
                }
                casu VariaSententia ut v {
                    si a.nomen == "externa" {
                        v.externa = verum
                    }
                    si nonnihil visibilitas {
                        v.visibilitas = visibilitas
                    }
                }
                casu GenusDeclaratio ut g {
                    si a.nomen inter ["abstractum", "abstracta", "abstractus"] {
                        g.abstractum = verum
                    }
                    si nonnihil visibilitas {
                        g.visibilitas = visibilitas
                    }
                }
                casu PactumDeclaratio ut p {
                    si nonnihil visibilitas {
                        p.visibilitas = visibilitas
                    }
                }
                casu OrdoDeclaratio ut o {
                    si nonnihil visibilitas {
                        o.visibilitas = visibilitas
                    }
                }
                casu DiscretioDeclaratio ut d {
                    si nonnihil visibilitas {
                        d.visibilitas = visibilitas
                    }
                }
                casu TypusAliasDeclaratio ut t {
                    si nonnihil visibilitas {
                        t.visibilitas = visibilitas
                    }
                }
                casu ProbaSententia ut p {
                    # Test annotations
                    si a.nomen == "omitte" {
                        p.modificator = ProbaModificator.Omitte
                        si positivum a.argumenta.longitudo() {
                            p.ratioModificatoris = a.argumenta[0]
                        }
                    }
                    si a.nomen == "futurum" {
                        p.modificator = ProbaModificator.Futurum
                        si positivum a.argumenta.longitudo() {
                            p.ratioModificatoris = a.argumenta[0]
                        }
                    }
                    si a.nomen == "solum" {
                        p.solum = verum
                    }
                    si a.nomen == "tag" {
                        si nihil p.tags {
                            p.tags = [] innatum lista<textus>
                        }
                        si positivum a.argumenta.longitudo() {
                            (p.tags qua lista<textus>).adde(a.argumenta[0])
                        }
                    }
                    si a.nomen == "temporis" {
                        si positivum a.argumenta.longitudo() {
                            p.temporis = a.argumenta[0] numeratum
                        }
                    }
                    si a.nomen == "metior" {
                        p.metior = verum
                    }
                    si a.nomen == "repete" {
                        si positivum a.argumenta.longitudo() {
                            p.repete = a.argumenta[0] numeratum
                        }
                    }
                    si a.nomen == "fragilis" {
                        si positivum a.argumenta.longitudo() {
                            p.fragilis = a.argumenta[0] numeratum
                        }
                    }
                    si a.nomen == "requirit" {
                        si positivum a.argumenta.longitudo() {
                            p.requirit = a.argumenta[0]
                        }
                    }
                    si a.nomen == "solum_in" {
                        si positivum a.argumenta.longitudo() {
                            p.solumIn = a.argumenta[0]
                        }
                    }
                }
                casu ProbandumSententia ut s {
                    # Suite annotations
                    si a.nomen == "omitte" {
                        s.ompitur = verum
                        si positivum a.argumenta.longitudo() {
                            s.ratioOmissionis = a.argumenta[0]
                        }
                    }
                    si a.nomen == "solum" {
                        s.solum = verum
                    }
                    si a.nomen == "tag" {
                        si nihil s.tags {
                            s.tags = [] innatum lista<textus>
                        }
                        si positivum a.argumenta.longitudo() {
                            (s.tags qua lista<textus>).adde(a.argumenta[0])
                        }
                    }
                }
                casu _ { }
            }
        }

        redde stmt
    }

    # Block statement
    si sym.species === SymbolumGenus.UncusSin {
        redde parseMassaSententia(r) qua Sententia
    }

    # Keyword-based dispatch
    si sym.species === SymbolumGenus.Verbum {
        fixum verbumId = sym.verbumId

        # Variable declarations
        si verbumId inter [VerbumId.Varia, VerbumId.Fixum, VerbumId.Figendum, VerbumId.Variandum] {
            redde parseVariaSententia(r)
        }

        # Return statement
        si verbumId === VerbumId.Redde {
            redde parseReddeSententia(r)
        }

        # Break/continue
        si verbumId === VerbumId.Rumpe {
            redde parseRumpeSententia(r)
        }
        si verbumId === VerbumId.Perge {
            redde parsePergeSententia(r)
        }

        # Throw/panic (skip if followed by LPAREN - treat as function call)
        si verbumId === VerbumId.Iace et p.specta(1).species !== SymbolumGenus.ParensSin {
            redde parseIaceSententia(r, falsum)
        }
        si verbumId === VerbumId.Mori et p.specta(1).species !== SymbolumGenus.ParensSin {
            redde parseIaceSententia(r, verum)
        }

        # Output statements (skip if followed by LPAREN - treat as function call)
        si verbumId === VerbumId.Scribe et p.specta(1).species !== SymbolumGenus.ParensSin {
            redde parseScribeSententia(r, ScribeGradus.Scribe)
        }
        si verbumId === VerbumId.Vide et p.specta(1).species !== SymbolumGenus.ParensSin {
            redde parseScribeSententia(r, ScribeGradus.Vide)
        }
        si verbumId === VerbumId.Mone et p.specta(1).species !== SymbolumGenus.ParensSin {
            redde parseScribeSententia(r, ScribeGradus.Mone)
        }

        # Error handling
        si verbumId === VerbumId.Tempta {
            redde parseTemptaSententia(r)
        }
        si verbumId === VerbumId.Fac {
            redde parseFacSententia(r)
        }
        si verbumId === VerbumId.Adfirma {
            redde parseAdfirmaSententia(r)
        }

        # Control flow
        si verbumId === VerbumId.Si {
            redde parseSiSententia(r)
        }
        si verbumId === VerbumId.Dum {
            redde parseDumSententia(r)
        }
        # 'ex' for for-of loops and destructuring
        # NOTE: imports use § ex sectional syntax, not bare ex
        si verbumId === VerbumId.Ex {
            # Disambiguate: ex <expr> fixum/varia IDENT { } → loop
            #              ex <expr> fixum/varia IDENT, IDENT → destructure
            varia i = 1
            dum i < 32 et non p.estFinis() {
                fixum s = p.specta(i)
                si s.species === SymbolumGenus.Verbum {
                    si s.verbumId inter [VerbumId.Fixum, VerbumId.Varia, VerbumId.Figendum, VerbumId.Variandum] {
                        # Found binding keyword - check what follows: IDENT then { or ,?
                        fixum afterIdent = p.specta(i + 2)
                        si afterIdent.species === SymbolumGenus.UncusSin {
                            # Block follows -> for-of loop
                            rumpe
                        }
                        # No block -> destructure
                        redde parseDestructuraSententia(r)
                    }
                }
                i += 1
            }

            # For-of loop
            redde parseExSententia(r)
        }
        si verbumId === VerbumId.De {
            redde parseDeSententia(r)
        }

        # Declarations
        si verbumId === VerbumId.Functio {
            redde parseFunctioDeclaratio(r)
        }
        si verbumId === VerbumId.Genus {
            redde parseGenusDeclaratio(r, falsum)
        }
        si verbumId === VerbumId.Abstractus {
            # WHY: Allow abstract genus modifier before the declaration keyword.
            si p.specta(1).species == SymbolumGenus.Verbum et p.specta(1).verbumId == VerbumId.Genus {
                p.procede()
                redde parseGenusDeclaratio(r, verum)
            }
        }
        si verbumId === VerbumId.Pactum {
            redde parsePactumDeclaratio(r)
        }
        si verbumId === VerbumId.Ordo {
            redde parseOrdoDeclaratio(r)
        }
        si verbumId === VerbumId.Discretio {
            redde parseDiscretioDeclaratio(r)
        }
        si verbumId === VerbumId.Typus {
            redde parseTypusAliasDeclaratio(r)
        }

        # Pattern matching and flow control
        si verbumId === VerbumId.Elige {
            redde parseEligeSententia(r)
        }
        si verbumId === VerbumId.Discerne {
            redde parseDiscerneSententia(r)
        }
        si verbumId === VerbumId.Custodi {
            redde parseCustodiSententia(r)
        }

        # Entry points (skip if followed by LPAREN - treat as function call)
        si verbumId === VerbumId.Incipit et p.specta(1).species !== SymbolumGenus.ParensSin {
            redde parseIncipitSententia(r)
        }
        si verbumId === VerbumId.Incipiet et p.specta(1).species !== SymbolumGenus.ParensSin {
            redde parseIncipietSententia(r)
        }

        # Resource management and dispatch (skip if followed by LPAREN - treat as function call)
        si verbumId === VerbumId.Cura et p.specta(1).species !== SymbolumGenus.ParensSin {
            redde parseCuraSententia(r)
        }
        si verbumId === VerbumId.Ad {
            redde parseAdSententia(r)
        }

        # Testing
        si verbumId === VerbumId.Probandum {
            redde parseProbandumSententia(r)
        }
        si verbumId === VerbumId.Proba {
            redde parseProbaSententia(r)
        }
        si verbumId inter [VerbumId.Praepara, VerbumId.Praeparabit, VerbumId.Postpara, VerbumId.Postparabit] {
            # WHY: Allow hooks at top level for test files.
            redde parsePraeparaMassa(r)
        }
    }

    # Fall through to expression statement
    redde parseExpressiaSententia(r)
}
