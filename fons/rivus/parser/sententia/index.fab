# Statement Dispatcher
#
# Central dispatcher for parsing statements based on leading keyword.
# Handles comment attachment and error recovery.
#
# GRAMMAR:
#   statement := importDecl | varDecl | funcDecl | typeAliasDecl | ifStmt
#              | whileStmt | forStmt | returnStmt | throwStmt | tryStmt
#              | blockStmt | exprStmt | ...
#
# LATIN VOCABULARY:
# - sententia = statement (sentence/thought)
# - declara = declare
# - imperium = control (command)

importa ex "../resolvitor" privata Resolvitor
importa ex "../../ast/positio" privata Locus
importa ex "../../ast/expressia" privata Expressia
importa ex "../../ast/sententia" privata Sententia
importa ex "../../ast/sententia" privata ScribeGradus
importa ex "../../ast/sententia" privata MorphologiaDeclaratio
importa ex "../../ast/sententia" privata Visibilitas
importa ex "../../ast/sententia" privata ProbaModificator
importa ex "../../ast/lexema" privata SymbolumGenus
importa ex "../../ast/lexema" privata VerbumId
importa ex "../../ast/radix" privata NodusRadix
importa ex "../../ast/annotatio" privata Annotatio
importa ex "../errores" privata ParserErrorCodice
importa ex "./annotatio" privata parseAnnotationes
importa ex "./annotatio" privata parseSectiones
importa ex "../../ast/radix" privata SectioAnnotatio

# Import statement parsers from submodules
importa ex "./actio" privata parseReddeSententia
importa ex "./actio" privata parseRumpeSententia
importa ex "./actio" privata parsePergeSententia
importa ex "./actio" privata parseIaceSententia
importa ex "./actio" privata parseScribeSententia
importa ex "./declara" privata parseFunctioDeclaratio
importa ex "./declara" privata parseGenusDeclaratio
importa ex "./declara" privata parsePactumDeclaratio
importa ex "./declara" privata parseOrdoDeclaratio
importa ex "./declara" privata parseDiscretioDeclaratio
importa ex "./declara" privata parseTypusAliasDeclaratio
importa ex "./declara" privata parseImportaSententia
importa ex "./error" privata parseTemptaSententia
importa ex "./error" privata parseFacSententia
importa ex "./error" privata parseAdfirmaSententia
importa ex "./imperium" privata parseSiSententia
importa ex "./imperium" privata parseDumSententia
importa ex "./imperium" privata parseIteraSententia
importa ex "./imperium" privata parseExSententia
importa ex "./imperium" privata parseDeSententia
importa ex "./fluxus" privata parseEligeSententia
importa ex "./fluxus" privata parseDiscerneSententia
importa ex "./fluxus" privata parseCustodiSententia
importa ex "./initus" privata parseIncipitSententia
importa ex "./initus" privata parseIncipietSententia
importa ex "./initus" privata parseCuraSententia
importa ex "./initus" privata parseAdSententia
importa ex "./massa" privata parseMassaSententia
importa ex "./massa" privata parseExpressiaSententia
importa ex "./varia" privata parseVariaSententia
importa ex "./varia" privata parseDestructuraSententia
importa ex "./varia" privata parseNomenVelVerbum
importa ex "./proba" privata parseProbandumSententia
importa ex "./proba" privata parseProbaSententia
importa ex "./proba" privata parsePraeparaMassa

# Parse a statement
#
# Main dispatcher that routes to appropriate parser based on leading token.
# Collects and attaches leading/trailing comments.
@ publica
functio parseSententia(in Resolvitor r) -> Sententia {
    fixum p = r.parser()

    # Capture any leading comments before the statement.
    p.colligeNotas()

    fixum stmt = parseSententiaSineNotis(r)

    # Attach leading/trailing comments (if any).
    fixum radix = stmt qua ignotum novum NodusRadix
    radix.notaePrae = p.consumeNotas()
    radix.notaePost = p.colligeNotamTrahentem(radix.locus.linea)

    redde stmt
}

functio parseSententiaSineNotis(in Resolvitor r) -> Sententia {
    fixum p = r.parser()
    fixum sym = p.specta(0)

    # Section annotation prefix (§) - file-level build configuration only
    # NOTE: § import syntax is deprecated; use: importa ex "path" privata|publica T
    si sym.species === SymbolumGenus.Sectio {
        fixum nextSym = p.specta(1)

        # Deprecation error for old import syntax
        si (nextSym.species === SymbolumGenus.Verbum) && (nextSym.verbumId === VerbumId.Importa) {
            p.renuncia(ParserErrorCodice.ErrorGeneralis, "§ import syntax is deprecated; use: importa ex \"path\" privata|publica T")
        }
        si (nextSym.species === SymbolumGenus.Verbum) && (nextSym.verbumId === VerbumId.Ex) {
            fixum sourceSym = p.specta(2)
            si (sourceSym.species === SymbolumGenus.Nomen) || (sourceSym.species === SymbolumGenus.Textus) {
                fixum importaSym = p.specta(3)
                si (importaSym.species === SymbolumGenus.Verbum) && (importaSym.verbumId === VerbumId.Importa) {
                    p.renuncia(ParserErrorCodice.ErrorGeneralis, "§ ex ... importa syntax is deprecated; use: importa ex \"path\" privata|publica T")
                }
            }
        }

        # Otherwise it's file-level build configuration
        fixum sectiones = parseSectiones(r)
        # Accumulate on parser for later extraction by parseProgramma
        itera ex sectiones fixum s {
            p.sectiones.appende(s)
        }
        redde parseSententiaSineNotis(r)
    }

    # Annotation prefix (e.g. `@ futura`)
    si sym.species === SymbolumGenus.At {
        fixum annotationes = parseAnnotationes(r)

        fixum stmt = parseSententiaSineNotis(r)

        # Store all annotations on statements that support the annotationes field
        discerne stmt {
            casu FunctioDeclaratio ut f {
                f.annotationes = annotationes
            }
            casu IncipitSententia ut i {
                i.annotationes = annotationes
            }
            casu IncipietSententia ut i {
                i.annotationes = annotationes
            }
            casu _ tacet
        }

        # Process individual annotation effects
        itera ex annotationes fixum a {
            # Check for visibility annotations
            varia visibilitas = nihil qua si Visibilitas
            si a.nomen inter ["publicum", "publica", "publicus"] {
                visibilitas = Visibilitas.Publica
            } sin a.nomen inter ["protectum", "protecta", "protectus"] {
                visibilitas = Visibilitas.Protecta
            } sin a.nomen inter ["privatum", "privata", "privatus"] {
                visibilitas = Visibilitas.Privata
            }

            discerne stmt {
                casu FunctioDeclaratio ut f {
                    si a.nomen == "futura" {
                        f.asynca = verum
                    }
                    si a.nomen == "cursor" {
                        f.generator = verum
                    }
                    si a.nomen == "radix" {
                        f.morphologia = { locus: a.locus, formae: a.argumenta } novum MorphologiaDeclaratio
                    }
                    si a.nomen == "externa" {
                        f.externa = verum
                    }
                    si nonnihil visibilitas {
                        f.visibilitas = visibilitas
                    }
                }
                casu VariaSententia ut v {
                    si a.nomen == "externa" {
                        v.externa = verum
                    }
                    si nonnihil visibilitas {
                        v.visibilitas = visibilitas
                    }
                }
                casu GenusDeclaratio ut g {
                    si a.nomen inter ["abstractum", "abstracta", "abstractus"] {
                        g.abstractum = verum
                    }
                    si nonnihil visibilitas {
                        g.visibilitas = visibilitas
                    }
                }
                casu PactumDeclaratio ut p {
                    si nonnihil visibilitas {
                        p.visibilitas = visibilitas
                    }
                }
                casu OrdoDeclaratio ut o {
                    si nonnihil visibilitas {
                        o.visibilitas = visibilitas
                    }
                }
                casu DiscretioDeclaratio ut d {
                    si nonnihil visibilitas {
                        d.visibilitas = visibilitas
                    }
                }
                casu TypusAliasDeclaratio ut t {
                    si nonnihil visibilitas {
                        t.visibilitas = visibilitas
                    }
                }
                casu ProbaSententia ut p {
                    # Test annotations
                    si a.nomen == "omitte" {
                        p.modificator = ProbaModificator.Omitte
                        si positivum a.argumenta.longitudo() {
                            p.ratioModificatoris = a.argumenta[0]
                        }
                    }
                    si a.nomen == "futurum" {
                        p.modificator = ProbaModificator.Futurum
                        si positivum a.argumenta.longitudo() {
                            p.ratioModificatoris = a.argumenta[0]
                        }
                    }
                    si a.nomen == "solum" {
                        p.solum = verum
                    }
                    si a.nomen == "tag" {
                        si nihil p.tags {
                            p.tags = [] innatum lista<textus>
                        }
                        si positivum a.argumenta.longitudo() {
                            p.tags.appende(a.argumenta[0])
                        }
                    }
                    si a.nomen == "temporis" {
                        si positivum a.argumenta.longitudo() {
                            p.temporis = a.argumenta[0] numeratum
                        }
                    }
                    si a.nomen == "metior" {
                        p.metior = verum
                    }
                    si a.nomen == "repete" {
                        si positivum a.argumenta.longitudo() {
                            p.repete = a.argumenta[0] numeratum
                        }
                    }
                    si a.nomen == "fragilis" {
                        si positivum a.argumenta.longitudo() {
                            p.fragilis = a.argumenta[0] numeratum
                        }
                    }
                    si a.nomen == "requirit" {
                        si positivum a.argumenta.longitudo() {
                            p.requirit = a.argumenta[0]
                        }
                    }
                    si a.nomen == "solum_in" {
                        si positivum a.argumenta.longitudo() {
                            p.solumIn = a.argumenta[0]
                        }
                    }
                }
                casu ProbandumSententia ut s {
                    # Suite annotations
                    si a.nomen == "omitte" {
                        s.ompitur = verum
                        si positivum a.argumenta.longitudo() {
                            s.ratioOmissionis = a.argumenta[0]
                        }
                    }
                    si a.nomen == "solum" {
                        s.solum = verum
                    }
                    si a.nomen == "tag" {
                        si nihil s.tags {
                            s.tags = [] innatum lista<textus>
                        }
                        si positivum a.argumenta.longitudo() {
                            s.tags.appende(a.argumenta[0])
                        }
                    }
                }
                casu _ tacet
            }
        }

        redde stmt
    }

    # Block statement
    si sym.species === SymbolumGenus.UncusSin {
        redde parseMassaSententia(r) qua Sententia
    }

    # Keyword-based dispatch
    si sym.species === SymbolumGenus.Verbum {
        fixum verbumId = sym.verbumId

        # Variable declarations
        si verbumId inter [VerbumId.Varia, VerbumId.Fixum] {
            redde parseVariaSententia(r)
        }

        # Return statement
        si verbumId === VerbumId.Redde {
            redde parseReddeSententia(r)
        }

        # Break/continue
        si verbumId === VerbumId.Rumpe {
            redde parseRumpeSententia(r)
        }
        si verbumId === VerbumId.Perge {
            redde parsePergeSententia(r)
        }

        # Throw/panic (skip if followed by LPAREN - treat as function call)
        si verbumId === VerbumId.Iace et p.specta(1).species !== SymbolumGenus.ParensSin {
            redde parseIaceSententia(r, falsum)
        }
        si verbumId === VerbumId.Mori et p.specta(1).species !== SymbolumGenus.ParensSin {
            redde parseIaceSententia(r, verum)
        }

        # Output statements (skip if followed by LPAREN - treat as function call)
        si verbumId === VerbumId.Scribe et p.specta(1).species !== SymbolumGenus.ParensSin {
            redde parseScribeSententia(r, ScribeGradus.Scribe)
        }
        si verbumId === VerbumId.Vide et p.specta(1).species !== SymbolumGenus.ParensSin {
            redde parseScribeSententia(r, ScribeGradus.Vide)
        }
        si verbumId === VerbumId.Mone et p.specta(1).species !== SymbolumGenus.ParensSin {
            redde parseScribeSententia(r, ScribeGradus.Mone)
        }

        # Error handling
        si verbumId === VerbumId.Tempta {
            redde parseTemptaSententia(r)
        }
        si verbumId === VerbumId.Fac {
            redde parseFacSententia(r)
        }
        si verbumId === VerbumId.Adfirma {
            redde parseAdfirmaSententia(r)
        }

        # Control flow
        si verbumId === VerbumId.Si {
            redde parseSiSententia(r)
        }
        si verbumId === VerbumId.Dum {
            redde parseDumSententia(r)
        }
        # 'itera' for iteration loops (itera ex / itera de)
        si verbumId === VerbumId.Itera {
            redde parseIteraSententia(r)
        }
        # 'ex' for for-of loops and destructuring
        # NOTE: imports use § ex sectional syntax, not bare ex
        si verbumId === VerbumId.Ex {
            # Disambiguate: ex <expr> fixum/varia IDENT { } → loop
            #              ex <expr> fixum/varia IDENT, IDENT → destructure
            varia i = 1
            dum i < 32 et non p.estFinis() {
                fixum s = p.specta(i)
                si s.species === SymbolumGenus.Verbum {
                    si s.verbumId inter [VerbumId.Fixum, VerbumId.Varia] {
                        # Found binding keyword - check what follows: IDENT then { or ,?
                        fixum afterIdent = p.specta(i + 2)
                        si afterIdent.species === SymbolumGenus.UncusSin {
                            # Block follows -> for-of loop
                            rumpe
                        }
                        # No block -> destructure
                        redde parseDestructuraSententia(r)
                    }
                }
                i += 1
            }

            # For-of loop
            redde parseExSententia(r)
        }
        si verbumId === VerbumId.De {
            redde parseDeSententia(r)
        }

        # SYNTAXIS ALIENA: 'pro...de' loop (Python/JS style)
        # Faber uses 'ex collection fixum item { }' not 'pro item de collection { }'
        si verbumId === VerbumId.Pro {
            p.renuncia(ParserErrorCodice.SyntaxisAlienaProDe)
            # Skip tokens to attempt recovery (pro IDENT de EXPR { })
            p.procede()  # pro
            si p.proba(SymbolumGenus.Nomen) { p.procede() }  # item
            si p.probaVerbum("de") { p.procede() }  # de
            # Let expression parsing handle the rest, then look for block
            redde parseExpressiaSententia(r)
        }

        # SYNTAXIS ALIENA: 'aliter' / 'aliter si' (false Latin for else/else-if)
        # Faber uses 'secus' for else, 'sin' for else-if
        si verbumId === VerbumId.Aliter {
            p.renuncia(ParserErrorCodice.SyntaxisAlienaAliter)
            # Skip tokens to attempt recovery (aliter { } or aliter si EXPR { })
            p.procede()  # aliter
            si p.probaVerbum("si") { p.procede() }  # optional si
            # Let expression/block parsing handle the rest
            redde parseExpressiaSententia(r)
        }

        # SYNTAXIS ALIENA: 'exspecta' (Latin for await, but Faber uses cede)
        si verbumId === VerbumId.Exspecta {
            p.renuncia(ParserErrorCodice.SyntaxisAlienaExspecta)
            p.procede()  # exspecta
            # Let expression parsing handle the awaited value
            redde parseExpressiaSententia(r)
        }

        # Declarations
        si verbumId === VerbumId.Functio {
            redde parseFunctioDeclaratio(r)
        }
        si verbumId === VerbumId.Genus {
            redde parseGenusDeclaratio(r, falsum)
        }
        si verbumId === VerbumId.Abstractus {
            # WHY: Allow abstract genus modifier before the declaration keyword.
            si p.specta(1).species == SymbolumGenus.Verbum et p.specta(1).verbumId == VerbumId.Genus {
                p.procede()
                redde parseGenusDeclaratio(r, verum)
            }
        }
        si verbumId === VerbumId.Pactum {
            redde parsePactumDeclaratio(r)
        }
        si verbumId === VerbumId.Ordo {
            redde parseOrdoDeclaratio(r)
        }
        si verbumId === VerbumId.Discretio {
            redde parseDiscretioDeclaratio(r)
        }
        si verbumId === VerbumId.Typus {
            redde parseTypusAliasDeclaratio(r)
        }

        # Import declaration (new syntax: importa ex "path" privata|publica T)
        si verbumId === VerbumId.Importa {
            redde parseImportaSententia(r)
        }

        # Pattern matching and flow control
        si verbumId === VerbumId.Elige {
            redde parseEligeSententia(r)
        }
        si verbumId === VerbumId.Discerne {
            redde parseDiscerneSententia(r)
        }
        si verbumId === VerbumId.Custodi {
            redde parseCustodiSententia(r)
        }

        # Entry points (skip if followed by LPAREN - treat as function call)
        si verbumId === VerbumId.Incipit et p.specta(1).species !== SymbolumGenus.ParensSin {
            redde parseIncipitSententia(r)
        }
        si verbumId === VerbumId.Incipiet et p.specta(1).species !== SymbolumGenus.ParensSin {
            redde parseIncipietSententia(r)
        }

        # Resource management and dispatch (skip if followed by LPAREN - treat as function call)
        si verbumId === VerbumId.Cura et p.specta(1).species !== SymbolumGenus.ParensSin {
            redde parseCuraSententia(r)
        }
        si verbumId === VerbumId.Ad {
            redde parseAdSententia(r)
        }

        # Testing
        si verbumId === VerbumId.Probandum {
            redde parseProbandumSententia(r)
        }
        si verbumId === VerbumId.Proba {
            redde parseProbaSententia(r)
        }
        si verbumId inter [VerbumId.Praepara, VerbumId.Praeparabit, VerbumId.Postpara, VerbumId.Postparabit] {
            # WHY: Allow hooks at top level for test files.
            redde parsePraeparaMassa(r)
        }
    }

    # Fall through to expression statement
    redde parseExpressiaSententia(r)
}
