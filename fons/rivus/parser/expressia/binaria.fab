# Binary Expression Parsers
#
# Operators: assignment, ternary, logical, bitwise, comparison, shift, arithmetic.
# Uses precedence climbing with left-to-right associativity (except assignment/ternary).
#
# GRAMMAR (low to high precedence):
#   assignment := ternary (('=' | '+=' | '-=' | ...) assignment)?
#   ternary := or (('?' expr ':' | 'sic' expr 'secus') ternary)?
#   or := and (('||' | 'aut' | 'vel') and)*
#   and := bitwiseOr (('&&' | 'et') bitwiseOr)*
#   bitwiseOr := bitwiseXor ('|' bitwiseXor)*
#   bitwiseXor := bitwiseAnd ('^' bitwiseAnd)*
#   bitwiseAnd := equality ('&' equality)*
#   equality := comparison (('==' | '!=' | 'est') comparison)*
#   comparison := range (('<' | '>') range)*
#   range := additive (('..' | 'ante' | 'usque') additive)?
#   additive := multiplicative (('+' | '-') multiplicative)*
#   multiplicative := unary (('*' | '/' | '%') unary)*
#
# LATIN VOCABULARY:
# - assignatio = assignment
# - condicio = condition
# - aut = or (logical)
# - et = and (logical)
# - vel = bitwise or
# - apex = bitwise xor
# - translatio = shift

§ ex "../resolvitor" importa Resolvitor
§ ex "../../ast/positio" importa Locus
§ ex "../../ast/expressia" importa Expressia
§ ex "../../ast/typus" importa TypusAnnotatio
§ ex "../../ast/lexema" importa SymbolumGenus
§ ex "../errores" importa ParserErrorCodice
§ ex "./unaria" importa parseUnaria

functio estAssignabile(de Expressia expr) -> bivalens {
    discerne expr {
        casu Nomen ut n {
            redde verum
        }
        casu MembrumExpressia ut m {
            redde verum
        }
        casu _ tacet
    }

    redde falsum
}

# Parse assignment expression
#
# GRAMMAR: assignment := ternary (('=' | '+=' | '-=' | ...) assignment)?
#
# Assignment is right-associative: a = b = c parses as a = (b = c)
@ publica
functio parseAssignatio(in Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Parse left side (could be ternary or lower)
    varia sinister = parseCondicio(r)

    # Check for assignment operator
    si p.estAssignatioSignum(p.specta(0)) {
        fixum signum = p.procede().valor

        si non estAssignabile(sinister) {
            p.renuncia(ParserErrorCodice.InvalidumAssignatio, nihil)
        }

        # Right-associative: recurse into assignment
        fixum dexter = parseAssignatio(r)

        redde finge AssignatioExpressia {
            locus: locus,
            sinister: sinister,
            signum: signum,
            dexter: dexter
        } qua Expressia
    }

    redde sinister
}

# Parse ternary conditional expression
#
# GRAMMAR: ternary := or (('sic' expr 'secus' | '?' expr ':') ternary)?
#
# Latin: condicio sic consequens secus alternans
# JS:    condicio ? consequens : alternans
@ publica
functio parseCondicio(in Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Parse condition
    varia condicio = parseAut(r)

    # Check for ternary operator (sic/secus or ?/:)
    si p.congruetVerbum("sic") {
        fixum consequens = r.expressia()
        p.expectaVerbum("secus", ParserErrorCodice.ExpectaturSecus)
        fixum alternans = parseCondicio(r)

        redde finge CondicioExpressia {
            locus: locus,
            condicio: condicio,
            consequens: consequens,
            alternans: alternans
        } qua Expressia
    }

    # SYNTAXIS ALIENA: '? :' ternary (C/JS style)
    # Faber uses 'sic/secus': x sic y secus z
    si p.congruet(SymbolumGenus.Rogatio) {
        p.renuncia(ParserErrorCodice.SyntaxisAlienaTernaria)
        fixum consequens = r.expressia()
        p.expecta(SymbolumGenus.Colon, ParserErrorCodice.ExpectaturColon)
        fixum alternans = parseCondicio(r)

        redde finge CondicioExpressia {
            locus: locus,
            condicio: condicio,
            consequens: consequens,
            alternans: alternans
        } qua Expressia
    }

    redde condicio
}

# Parse logical OR expression
#
# GRAMMAR: or := and (('||' | 'aut' | '??') and)*
@ publica
functio parseAut(in Resolvitor r) -> Expressia {
    fixum p = r.parser()
    varia sinister = parseEt(r)

    dum p.congruet(SymbolumGenus.VelVel) aut p.congruetVerbum("aut") aut p.congruet(SymbolumGenus.RogatioBis) aut p.congruetVerbum("vel") {
        fixum operatorSym = p.praevius()
        fixum locus = operatorSym.locus
        varia signum = operatorSym.valor

        # SYNTAXIS ALIENA: '??' (JavaScript nullish coalescing)
        # Faber uses 'vel' for nullish coalescing
        si operatorSym.species == SymbolumGenus.RogatioBis {
            p.renuncia(ParserErrorCodice.SyntaxisAlienaRogatioBis)
            signum = "vel"  # Normalize to vel for codegen
        }

        fixum dexter = parseEt(r)

        sinister = finge BinariaExpressia {
            locus: locus,
            sinister: sinister,
            signum: signum,
            dexter: dexter
        } qua Expressia
    }

    redde sinister
}

# Parse logical AND expression
#
# GRAMMAR: and := bitwiseOr (('&&' | 'et') bitwiseOr)*
@ publica
functio parseEt(in Resolvitor r) -> Expressia {
    fixum p = r.parser()
    varia sinister = parseBitVel(r)

    dum p.congruet(SymbolumGenus.EtEt) aut p.congruetVerbum("et") {
        fixum operatorSym = p.praevius()
        fixum locus = operatorSym.locus
        fixum signum = operatorSym.valor
        fixum dexter = parseBitVel(r)

        sinister = finge BinariaExpressia {
            locus: locus,
            sinister: sinister,
            signum: signum,
            dexter: dexter
        } qua Expressia
    }

    redde sinister
}

# Parse bitwise OR expression
#
# GRAMMAR: bitwiseOr := bitwiseXor ('|' bitwiseXor)*
@ publica
functio parseBitVel(in Resolvitor r) -> Expressia {
    fixum p = r.parser()
    varia sinister = parseBitApex(r)

    dum p.congruet(SymbolumGenus.Vel) {
        fixum operatorSym = p.praevius()
        fixum locus = operatorSym.locus
        fixum signum = operatorSym.valor
        fixum dexter = parseBitApex(r)

        sinister = finge BinariaExpressia {
            locus: locus,
            sinister: sinister,
            signum: signum,
            dexter: dexter
        } qua Expressia
    }

    redde sinister
}

# Parse bitwise XOR expression
#
# GRAMMAR: bitwiseXor := bitwiseAnd ('^' bitwiseAnd)*
@ publica
functio parseBitApex(in Resolvitor r) -> Expressia {
    fixum p = r.parser()
    varia sinister = parseBitEt(r)

    dum p.congruet(SymbolumGenus.Apex) {
        fixum operatorSym = p.praevius()
        fixum locus = operatorSym.locus
        fixum signum = operatorSym.valor
        fixum dexter = parseBitEt(r)

        sinister = finge BinariaExpressia {
            locus: locus,
            sinister: sinister,
            signum: signum,
            dexter: dexter
        } qua Expressia
    }

    redde sinister
}

# Parse bitwise AND expression
#
# GRAMMAR: bitwiseAnd := equality ('&' equality)*
@ publica
functio parseBitEt(in Resolvitor r) -> Expressia {
    fixum p = r.parser()
    varia sinister = parseAequale(r)

    dum p.congruet(SymbolumGenus.Et) {
        fixum operatorSym = p.praevius()
        fixum locus = operatorSym.locus
        fixum signum = operatorSym.valor
        fixum dexter = parseAequale(r)

        sinister = finge BinariaExpressia {
            locus: locus,
            sinister: sinister,
            signum: signum,
            dexter: dexter
        } qua Expressia
    }

    redde sinister
}

# Parse equality expression
#
# GRAMMAR: equality := comparison (('==' | '!=' | '===' | '!==' | 'est') comparison)*
@ publica
functio parseAequale(in Resolvitor r) -> Expressia {
    fixum p = r.parser()
    varia sinister = parseComparatio(r)

    dum p.congruet(SymbolumGenus.AequumBis) aut p.congruet(SymbolumGenus.NonAequum) aut p.congruet(SymbolumGenus.AequumTer) aut p.congruet(SymbolumGenus.NonAequumBis) {
        fixum operatorSym = p.praevius()
        fixum locus = operatorSym.locus
        fixum signum = operatorSym.valor
        fixum dexter = parseComparatio(r)

        sinister = finge BinariaExpressia {
            locus: locus,
            sinister: sinister,
            signum: signum,
            dexter: dexter
        } qua Expressia
    }

    # Handle 'non est' type check
    si p.probaVerbum("non") et p.specta(1).species == SymbolumGenus.Verbum et p.specta(1).verbum == "est" {
        p.procede()
        p.procede()
        fixum locus = p.praevius().locus
        fixum scopus = r.adnotatio()
        redde finge UnariaExpressia {
            locus: locus,
            signum: "!",
            # WHY: Inline to keep contextual typing for Expressia union.
            argumentum: finge EstExpressia {
                locus: locus,
                expressia: sinister,
                scopus: scopus
            } qua Expressia
        } qua Expressia
    }

    # Handle 'est' type check
    si p.congruetVerbum("est") {
        fixum locus = p.praevius().locus
        fixum scopus = r.adnotatio()

        redde finge EstExpressia {
            locus: locus,
            expressia: sinister,
            scopus: scopus
        } qua Expressia
    }

    redde sinister
}

# Parse comparison expression
#
# GRAMMAR: comparison := range (('<' | '>' | '<=' | '>=') range)*
@ publica
functio parseComparatio(in Resolvitor r) -> Expressia {
    fixum p = r.parser()
    varia sinister = parseAmbitus(r)

    dum p.congruet(SymbolumGenus.Minor) aut p.congruet(SymbolumGenus.Maior) aut p.congruet(SymbolumGenus.MinorAequum) aut p.congruet(SymbolumGenus.MaiorAequum) aut p.congruetVerbum("intra") aut p.congruetVerbum("inter") {
        fixum operatorSym = p.praevius()
        fixum locus = operatorSym.locus
        fixum signum = operatorSym.valor
        fixum dexter = parseAmbitus(r)

        sinister = finge BinariaExpressia {
            locus: locus,
            sinister: sinister,
            signum: signum,
            dexter: dexter
        } qua Expressia
    }

    redde sinister
}


# Parse range expression
#
# GRAMMAR: range := additive (('..' | 'ante' | 'usque') additive ('per' additive)?)?
@ publica
functio parseAmbitus(in Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()
    varia initium = parseAdditio(r)

    varia inclusivum = falsum
    varia habetAmbitum = falsum

    si p.congruet(SymbolumGenus.PunctumBis) {
        habetAmbitum = verum
        inclusivum = falsum
    } sin p.probaVerbum("ante") {
        p.procede()
        habetAmbitum = verum
        inclusivum = falsum
    } sin p.probaVerbum("usque") {
        p.procede()
        habetAmbitum = verum
        inclusivum = verum
    }

    si habetAmbitum {
        fixum finis = parseAdditio(r)
        varia gradus = nihil qua si Expressia

        si p.probaVerbum("per") {
            p.procede()
            gradus = parseAdditio(r)
        }

        redde finge AmbitusExpressia {
            locus: locus,
            initium: initium,
            finis: finis,
            gradus: gradus,
            inclusivum: inclusivum
        } qua Expressia
    }

    redde initium
}

# Parse additive expression
#
# GRAMMAR: additive := multiplicative (('+' | '-') multiplicative)*
@ publica
functio parseAdditio(in Resolvitor r) -> Expressia {
    fixum p = r.parser()
    varia sinister = parseMultiplicatio(r)

    dum p.congruet(SymbolumGenus.Plus) aut p.congruet(SymbolumGenus.Minus) {
        fixum operatorSym = p.praevius()
        fixum locus = operatorSym.locus
        fixum signum = operatorSym.valor
        fixum dexter = parseMultiplicatio(r)

        sinister = finge BinariaExpressia {
            locus: locus,
            sinister: sinister,
            signum: signum,
            dexter: dexter
        } qua Expressia
    }

    redde sinister
}

# Parse multiplicative expression
#
# GRAMMAR: multiplicative := unary (('*' | '/' | '%') unary)*
@ publica
functio parseMultiplicatio(in Resolvitor r) -> Expressia {
    fixum p = r.parser()
    varia sinister = parseUnaria(r)

    dum p.congruet(SymbolumGenus.Stella) aut p.congruet(SymbolumGenus.Virgula) aut p.congruet(SymbolumGenus.Centum) {
        fixum operatorSym = p.praevius()
        fixum locus = operatorSym.locus
        fixum signum = operatorSym.valor
        fixum dexter = parseUnaria(r)

        sinister = finge BinariaExpressia {
            locus: locus,
            sinister: sinister,
            signum: signum,
            dexter: dexter
        } qua Expressia
    }

    redde sinister
}
