# Primary Expression Parsers
#
# Terminals and grouping: literals, identifiers, parenthesized expressions,
# arrays, objects, lambdas, and special forms.
#
# GRAMMAR:
#   primary := IDENTIFIER | NUMBER | STRING | TEMPLATE_STRING
#            | 'ego' | 'verum' | 'falsum' | 'nihil'
#            | '(' expression ')' | arrayLiteral | objectLiteral
#            | lambdaExpression | fingeExpression | scriptumExpression
#            | legeExpression | regexExpression | abExpression
#
# WHY: Primary expressions are the leaves of the expression tree.
#      Everything else builds on top of these terminals.
#
# LATIN VOCABULARY:
# - primaria = primary
# - littera = literal
# - nomen = identifier/name
# - ego = self/this
# - verum/falsum = true/false
# - nihil = null
# - series = array
# - obiectum = object
# - scriptum = formatted string
# - lege = read (stdin)
# - sed = regex (but/except)
# - ab = from (collection DSL)

§ ex "../resolvitor" importa Resolvitor
§ ex "../../ast/positio" importa Locus
§ ex "../../ast/expressia" importa Expressia, LitteraGenus, ObiectumProprietas, ClausuraParametrum, ClausuraCorpus
§ ex "../../ast/expressia" importa AbFiltrum, CatenaGradus
§ ex "../../ast/typus" importa TypusAnnotatio
§ ex "../../ast/lexema" importa SymbolumGenus
§ ex "../../ast/sententia" importa Sententia
§ ex "../errores" importa ParserErrorCodice

# ============================================================================
# PRIMARY DISPATCHER
# ============================================================================

# Parse primary expression
#
# Handles terminals: literals, identifiers, ego, grouped expressions.
# Routes to specialized parsers for compound forms (arrays, objects, lambdas).
@ publica
functio parsePrimaria(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum sym = p.specta(0)
    fixum locus = sym.locus

    # Numeric literal
    si sym.species == SymbolumGenus.Numerus {
        p.procede()
        redde finge Littera {
            locus: locus,
            species: LitteraGenus.Numerus,
            crudus: sym.valor
        } qua Expressia
    }

    # Float literal
    si sym.species == SymbolumGenus.Fractus {
        p.procede()
        redde finge Littera {
            locus: locus,
            species: LitteraGenus.Fractus,
            crudus: sym.valor
        } qua Expressia
    }

    # String literal
    si sym.species == SymbolumGenus.Textus {
        p.procede()
        redde finge Littera {
            locus: locus,
            species: LitteraGenus.Textus,
            crudus: sym.valor
        } qua Expressia
    }

    # Template literal
    si sym.species == SymbolumGenus.Exemplar {
        p.procede()
        redde finge Littera {
            locus: locus,
            species: LitteraGenus.Exemplar,
            crudus: sym.valor
        } qua Expressia
    }

    # Boolean: verum
    si sym.species == SymbolumGenus.Verum {
        p.procede()
        redde finge Littera {
            locus: locus,
            species: LitteraGenus.Verum,
            crudus: sym.valor
        } qua Expressia
    }

    # Boolean: falsum
    si sym.species == SymbolumGenus.Falsum {
        p.procede()
        redde finge Littera {
            locus: locus,
            species: LitteraGenus.Falsum,
            crudus: sym.valor
        } qua Expressia
    }

    # Null: nihil
    si sym.species == SymbolumGenus.Nihil {
        p.procede()
        redde finge Littera {
            locus: locus,
            species: LitteraGenus.Nihil,
            crudus: sym.valor
        } qua Expressia
    }

    # Ab expression (collection filtering DSL)
    si p.probaVerbum("ab") {
        redde parseAbExpressia(r)
    }

    # Identifier
    si sym.species == SymbolumGenus.Nomen {
        p.procede()
        redde finge Nomen {
            locus: locus,
            valor: sym.valor
        } qua Expressia
    }

    # Self reference: ego
    si p.probaVerbum("ego") {
        p.procede()
        redde finge EgoExpressia {
            locus: locus
        } qua Expressia
    }

    # Grouped expression: ( expr )
    si sym.species == SymbolumGenus.ParensSin {
        p.procede()
        fixum expr = r.expressia()
        p.expecta(SymbolumGenus.ParensDex, ParserErrorCodice.ExpectaturParensDex)
        redde expr
    }

    # Array literal: [ ... ]
    si sym.species == SymbolumGenus.QuadratusSin {
        redde parseSeriesExpressia(r)
    }

    # Object literal: { ... }
    si sym.species == SymbolumGenus.UncusSin {
        redde parseObiectumExpressia(r)
    }

    # Clausura: clausura x: expr
    si p.probaVerbum("clausura") {
        redde parseClausuraExpressia(r)
    }

    # Discretio construction: finge Variant { ... } qua Type
    si p.probaVerbum("finge") {
        redde parseFingeExpressia(r)
    }

    # Praefixum (compile-time) expression
    si p.probaVerbum("praefixum") {
        redde parsePraefixumExpressia(r)
    }

    # Scriptum (format string)
    si p.probaVerbum("scriptum") {
        redde parseScriptumExpressia(r)
    }

    # Lege (stdin read)
    si p.probaVerbum("lege") {
        redde parseLegeExpressia(r)
    }

    # Regex literal: sed "(?flags)pattern"
    si p.probaVerbum("sed") {
        redde parseRegexExpressia(r)
    }

    # Keyword identifiers (allow keywords as names in expression position)
    si sym.species == SymbolumGenus.Verbum {
        p.procede()
        redde finge Nomen {
            locus: locus,
            valor: sym.valor
        } qua Expressia
    }

    # Fallback: report error and return placeholder
    p.renuncia(ParserErrorCodice.ExpectaturExpressia, scriptum("got '§'", sym.valor))
    si non p.estFinis() {
        p.procede()
    }
    redde finge Nomen {
        locus: locus,
        valor: ""
    } qua Expressia
}

# ============================================================================
# COLLECTION DSL (ab expression)
# ============================================================================

# Parse ab expression (collection filtering DSL)
#
# GRAMMAR:
#   abExpr := 'ab' expression filter? (',' transform)*
#   filter := ['non'] ('ubi' expression | IDENT)
#   transform := ('prima' | 'ultima' | 'summa') expression?
@ publica
functio parseAbExpressia(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    p.expectaVerbum("ab", ParserErrorCodice.ExpectaturExpressia)

    fixum fons = r.expressia()

    varia negata = falsum
    si p.probaVerbum("non") {
        negata = verum
        p.procede()
    }

    varia filtrum = nihil qua AbFiltrum?

    functio estCatenaVerbumSym(symbolum) -> bivalens {
        si symbolum.species !== SymbolumGenus.Verbum {
            redde falsum
        }
        si symbolum.verbum inter ["prima", "ultima", "summa"] {
            redde verum
        }
        redde falsum
    }

    si non p.proba(SymbolumGenus.Coma) {
        si p.probaVerbum("ubi") {
            p.procede()
            fixum condicio = r.expressia()
            filtrum = {
                locus: locus,
                habetUbi: verum,
                condicio: condicio
            } novum AbFiltrum
        } sin (p.proba(SymbolumGenus.Nomen) aut p.proba(SymbolumGenus.Verbum)) {
            fixum prox = p.specta(0)
            si non estCatenaVerbumSym(prox) et non p.probaVerbum("clausura") {
                fixum nomenSym = p.procede()
                filtrum = {
                    locus: nomenSym.locus,
                    habetUbi: falsum,
                    condicio: finge Nomen {
                        locus: nomenSym.locus,
                        valor: nomenSym.valor
                    } qua Expressia
                } novum AbFiltrum
            }
        }
    }

    varia gradus = nihil qua lista<CatenaGradus>?
    si p.congruet(SymbolumGenus.Coma) aut estCatenaVerbumSym(p.specta(0)) {
        gradus = parseCatenaGradus(r)
    }

    redde finge AbExpressia {
        locus: locus,
        fons: fons,
        negata: negata,
        filtrum: filtrum,
        gradus: gradus
    } qua Expressia
}

@ publica
functio parseCatenaGradus(Resolvitor r) -> lista<CatenaGradus> {
    fixum p = r.parser()
    varia gradus = [] innatum lista<CatenaGradus>

    functio estCatenaVerbumSym(symbolum) -> bivalens {
        si symbolum.species !== SymbolumGenus.Verbum {
            redde falsum
        }
        si symbolum.verbum inter ["prima", "ultima", "summa", "ordina", "collige", "grupa", "maximum", "minimum", "medium", "numera"] {
            redde verum
        }
        redde falsum
    }

    dum estCatenaVerbumSym(p.specta(0)) {
        fixum verbSym = p.procede()
        fixum verbum = verbSym.verbum qua textus
        fixum locus = verbSym.locus

        varia argumentum = nihil qua Expressia?
        varia proprietas = nihil qua Expressia?
        varia directio = nihil qua textus?

        elige verbum {
            casu "prima" {
                argumentum = r.expressia()
            }
            casu "ultima" {
                argumentum = r.expressia()
            }
            casu "summa" {
                # summa optionally takes property: summa pretium
                si p.specta(0).species == SymbolumGenus.Nomen et non estCatenaVerbumSym(p.specta(0)) {
                    proprietas = r.expressia()
                }
            }
            casu "ordina" {
                # ordina per property [ascendens|descendens]
                p.expectaVerbum("per", ParserErrorCodice.ExpectaturNomen)
                proprietas = r.expressia()
                si p.congruetVerbum("ascendens") {
                    directio = "ascendens"
                } sin p.congruetVerbum("descendens") {
                    directio = "descendens"
                }
            }
            casu "collige" {
                proprietas = r.expressia()
            }
            casu "grupa" {
                p.expectaVerbum("per", ParserErrorCodice.ExpectaturNomen)
                proprietas = r.expressia()
            }
            casu "maximum" { }
            casu "minimum" { }
            casu "medium" { }
            casu "numera" { }
        }

        gradus.adde({
            locus: locus,
            verbum: verbum,
            argumentum: argumentum,
            proprietas: proprietas,
            directio: directio
        } novum CatenaGradus)

        si non p.congruet(SymbolumGenus.Coma) {
            rumpe
        }
    }

    redde gradus
}

# ============================================================================
# ARRAY AND OBJECT LITERALS
# ============================================================================

# Parse array literal
#
# GRAMMAR: arrayLiteral := '[' (expression (',' expression)*)? ']'
#
# Example: [1, 2, 3], [sparge items, 4, 5]
@ publica
functio parseSeriesExpressia(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    p.expecta(SymbolumGenus.QuadratusSin, ParserErrorCodice.ExpectaturQuadratusSin)

    varia elementa = [] innatum lista<Expressia>

    si non p.proba(SymbolumGenus.QuadratusDex) {
        elementa.adde(parseElementumSeries(r))

        dum p.congruet(SymbolumGenus.Coma) {
            # Allow trailing comma
            si p.proba(SymbolumGenus.QuadratusDex) {
                rumpe
            }
            elementa.adde(parseElementumSeries(r))
        }
    }

    p.expecta(SymbolumGenus.QuadratusDex, ParserErrorCodice.ExpectaturQuadratusDex)

    redde finge SeriesExpressia {
        locus: locus,
        elementa: elementa
    } qua Expressia
}

# Parse a single array element (supports sparge)
@ publica
functio parseElementumSeries(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    si p.probaVerbum("sparge") {
        # WHY: Spread elements lower to DispersioElementum for codegen
        p.procede()
        fixum argumentum = r.expressia()
        redde finge DispersioElementum {
            locus: locus,
            argumentum: argumentum
        } qua Expressia
    }

    redde r.expressia()
}

# Parse a single object property
#
# GRAMMAR:
#   property := 'sparge' expression           # spread
#             | '[' expr ']' ':' expression   # computed key
#             | STRING ':' expression         # string key
#             | IDENTIFIER ':' expression     # identifier key with value
#             | IDENTIFIER                    # shorthand { name } = { name: name }
@ publica
functio parseObiectumProprietas(Resolvitor r) -> ObiectumProprietas {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Spread: sparge expr
    si p.probaVerbum("sparge") {
        p.procede()
        fixum argumentum = r.expressia()

        # WHY: We wrap spread in ObiectumProprietas with special marker
        #      by using the spread expression as both key and value
        redde {
            locus: locus,
            clavis: argumentum,
            valor: argumentum,
            brevitas: falsum,
            computatum: falsum,
            dispersum: verum
        } novum ObiectumProprietas
    }

    # Parse the key
    varia clavis = nihil qua Expressia?
    varia computatum = falsum

    # Computed property: [expr]
    si p.congruet(SymbolumGenus.QuadratusSin) {
        clavis = r.expressia()
        p.expecta(SymbolumGenus.QuadratusDex, ParserErrorCodice.ExpectaturQuadratusDex)
        computatum = verum
    }
    # String key: "name"
    sin p.proba(SymbolumGenus.Textus) {
        fixum strSym = p.procede()
        clavis = finge Littera {
            locus: strSym.locus,
            species: LitteraGenus.Textus,
            crudus: strSym.valor
        } qua Expressia
    }
    # Identifier key: name
    secus {
        fixum nomenSym = p.expectaNomenAutVerbum(ParserErrorCodice.ExpectaturNomen)
        clavis = finge Nomen {
            locus: nomenSym.locus,
            valor: nomenSym.valor
        } qua Expressia
    }

    # Value follows colon, otherwise shorthand
    si p.congruet(SymbolumGenus.Colon) {
        fixum valor = r.expressia()

        redde {
            locus: locus,
            clavis: clavis,
            valor: valor,
            brevitas: falsum,
            computatum: computatum,
            dispersum: falsum
        } novum ObiectumProprietas
    }

    # Shorthand: { name } means { name: name }
    redde {
        locus: locus,
        clavis: clavis,
        valor: clavis,
        brevitas: verum,
        computatum: falsum,
        dispersum: falsum
    } novum ObiectumProprietas
}

# Parse object literal
#
# GRAMMAR: objectLiteral := '{' (property (',' property)*)? '}'
#
# Examples:
#   {}
#   { name: "Alice", age: 30 }
#   { name }                      # shorthand
#   { [key]: value }              # computed
#   { sparge base, extra: 1 }    # spread
@ publica
functio parseObiectumExpressia(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    p.expecta(SymbolumGenus.UncusSin, ParserErrorCodice.ExpectaturUncusSin)

    varia proprietates = [] innatum lista<ObiectumProprietas>

    si non p.proba(SymbolumGenus.UncusDex) {
        fac {
            proprietates.adde(parseObiectumProprietas(r))
        } dum p.congruet(SymbolumGenus.Coma) et non p.proba(SymbolumGenus.UncusDex)
    }

    p.expecta(SymbolumGenus.UncusDex, ParserErrorCodice.ExpectaturUncusDex)

    redde finge ObiectumExpressia {
        locus: locus,
        proprietates: proprietates
    } qua Expressia
}

# ============================================================================
# LAMBDA EXPRESSIONS
# ============================================================================

# Parse lambda expression
#
# GRAMMAR:
#   lambdaExpr := 'pro' params? ('->' type)? (':' expression | blockStmt)
#   params := IDENTIFIER (',' IDENTIFIER)*
#
# Examples:
#   pro: 42                       # zero params
#   clausura x: x * 2             # single param
#   clausura x, y: x + y          # multiple params
#   clausura x -> numerus: x * 2  # with return type
#
# Note: Block form uses MassaSententia as corpus for later codegen.
@ publica
functio parseClausuraExpressia(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    # Consume 'clausura'
    p.expectaVerbum("clausura", ParserErrorCodice.ExpectaturClausura)

    varia parametra = [] innatum lista<ClausuraParametrum>

    # Check for immediate : or -> (zero-param clausura)
    si non p.proba(SymbolumGenus.Colon) et non p.proba(SymbolumGenus.Sagitta) {
        # Parse parameters until we hit : or ->
        fac {
            fixum paramLocus = p.locusActualis()
            fixum nomenSym = p.expectaNomenAutVerbum(ParserErrorCodice.ExpectaturNomen)

            parametra.adde({
                locus: paramLocus,
                nomen: nomenSym.valor,
                typus: nihil
            } novum ClausuraParametrum)
        } dum p.congruet(SymbolumGenus.Coma)
    }

    # Optional return type: -> Type
    varia typusReditus = nihil qua TypusAnnotatio?
    si p.congruet(SymbolumGenus.Sagitta) {
        typusReditus = r.adnotatio()
    }

    # Body: ':' expression or blockStmt
    varia corpus = nihil qua ClausuraCorpus?
    si p.congruet(SymbolumGenus.Colon) {
        corpus = finge Expr { valor: r.expressia() } qua ClausuraCorpus
    } sin p.proba(SymbolumGenus.UncusSin) {
        corpus = finge Massa { valor: r.massa() } qua ClausuraCorpus
    } secus {
        p.expecta(SymbolumGenus.Colon, ParserErrorCodice.ExpectaturColon)
        corpus = finge Expr { valor: r.expressia() } qua ClausuraCorpus
    }

    redde finge ClausuraExpressia {
        locus: locus,
        parametra: parametra,
        corpus: corpus,
        typusReditus: typusReditus
    } qua Expressia
}

# Parse finge (discretio construction) expression
#
# GRAMMAR:
#   fingeExpr := 'finge' IDENTIFIER ('{' fields? '}')? ('qua' typeAnnotation)?
#   field := IDENTIFIER (':' expression)?
@ publica
functio parseFingeExpressia(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    p.expectaVerbum("finge", ParserErrorCodice.ExpectaturExpressia)

    fixum variansSym = p.expecta(SymbolumGenus.Nomen, ParserErrorCodice.ExpectaturNomen)
    fixum variansNomen = variansSym.valor

    varia campi = [] innatum lista<ObiectumProprietas>

    si p.congruet(SymbolumGenus.UncusSin) {
        si non p.proba(SymbolumGenus.UncusDex) {
            fac {
                fixum campusLocus = p.locusActualis()

                fixum nomenSym = p.expectaNomenAutVerbum(ParserErrorCodice.ExpectaturNomen)
                # WHY: Keep Nomen as Expressia to avoid TS literal widening.
                fixum Expressia clavis = finge Nomen {
                    locus: nomenSym.locus,
                    valor: nomenSym.valor
                } qua Expressia

                # WHY: Preserve Expressia union type when assigning later expressions.
                varia Expressia valor = clavis
                varia brevitas = verum

                si p.congruet(SymbolumGenus.Colon) {
                    valor = r.expressia()
                    brevitas = falsum
                }

                campi.adde({
                    locus: campusLocus,
                    clavis: clavis,
                    valor: valor,
                    brevitas: brevitas,
                    computatum: falsum,
                    dispersum: falsum
                } novum ObiectumProprietas)
            } dum p.congruet(SymbolumGenus.Coma)
        }

        p.expecta(SymbolumGenus.UncusDex, ParserErrorCodice.ExpectaturUncusDex)
    }

    varia scopus = nihil qua TypusAnnotatio?
    si p.congruetVerbum("qua") {
        scopus = r.adnotatio()
    }

    redde finge FingeExpressia {
        locus: locus,
        variansNomen: variansNomen,
        campi: campi,
        scopus: scopus
    } qua Expressia
}

# ============================================================================
# COMPILE-TIME AND SPECIAL EXPRESSIONS
# ============================================================================

# Parse praefixum expression (compile-time evaluation)
#
# GRAMMAR: praefixum (blockStmt | '(' expression ')')
#
# Example: praefixum(VERSION), praefixum { computeConstant() }
@ publica
functio parsePraefixumExpressia(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    p.expectaVerbum("praefixum", ParserErrorCodice.ExpectaturExpressia)

    varia corpus = nihil qua ClausuraCorpus?

    si p.proba(SymbolumGenus.UncusSin) {
        # WHY: Block form is allowed in grammar, but AST expects an expression.
        fixum massa = r.massa()
        corpus = finge Massa { valor: massa } qua ClausuraCorpus
    } sin p.congruet(SymbolumGenus.ParensSin) {
        fixum expr = r.expressia()
        p.expecta(SymbolumGenus.ParensDex, ParserErrorCodice.ExpectaturParensDex)
        corpus = finge Expr { valor: expr } qua ClausuraCorpus
    } secus {
        p.renuncia(ParserErrorCodice.ExpectaturUncusVelParens, scriptum("got '§'", p.specta(0).valor))
        corpus = finge Expr {
            valor: finge Littera {
                locus: locus,
                species: LitteraGenus.Nihil,
                crudus: "nihil"
            } qua Expressia
        } qua ClausuraCorpus
    }

    redde finge PraefixumExpressia {
        locus: locus,
        corpus: corpus
    } qua Expressia
}

# Extract an expression from a block, preferring trailing redde/expr
@ publica
functio exMassaExpressia(Sententia massa, Locus locus) -> Expressia {
    # WHY: Blocks are statements; we salvage the last expression when present.
    discerne massa {
        casu MassaSententia ut m {
            si m.corpus.longitudo() > 0 {
                fixum ult = m.corpus[m.corpus.longitudo() - 1]
                discerne ult {
                    casu ReddeSententia ut r {
                        si nonnihil r.valor {
                            redde r.valor
                        }
                    }
                    casu ExpressiaSententia ut e {
                        redde e.expressia
                    }
                    casu _ { }
                }
            }
        }
        casu _ { }
    }

    redde finge Littera {
        locus: locus,
        species: LitteraGenus.Nihil,
        crudus: "nihil"
    } qua Expressia
}

# Parse scriptum expression (format string)
#
# GRAMMAR: scriptum '(' STRING (',' expression)* ')'
#
# Example: scriptum("Hello, §!", name)
@ publica
functio parseScriptumExpressia(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    p.expectaVerbum("scriptum", ParserErrorCodice.ExpectaturExpressia)
    p.expecta(SymbolumGenus.ParensSin, ParserErrorCodice.ExpectaturParensSin)

    fixum exemplarSym = p.expecta(SymbolumGenus.Textus, ParserErrorCodice.ExpectaturTextus)
    fixum exemplar = exemplarSym.valor

    varia argumenta = [] innatum lista<Expressia>
    dum p.congruet(SymbolumGenus.Coma) {
        argumenta.adde(r.expressia())
    }

    p.expecta(SymbolumGenus.ParensDex, ParserErrorCodice.ExpectaturParensDex)

    redde finge ScriptumExpressia {
        locus: locus,
        exemplar: exemplar,
        argumenta: argumenta
    } qua Expressia
}

# Parse lege expression (stdin read)
#
# GRAMMAR: lege ('lineam')?
#
# Example: lege (all stdin), lege lineam (one line)
@ publica
functio parseLegeExpressia(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    p.expectaVerbum("lege", ParserErrorCodice.ExpectaturExpressia)

    varia modus = "all" qua textus
    si p.probaVerbum("lineam") {
        p.procede()
        modus = "line"
    }

    redde finge LegeExpressia {
        locus: locus,
        modus: modus
    } qua Expressia
}

# Parse regex literal
#
# GRAMMAR: sed STRING
#
# Flags use inline syntax: sed "(?i)pattern" for case-insensitive, etc.
# This avoids ambiguity with the next statement when flags are separate tokens.
#
# Example: sed "\\d+", sed "(?i)[a-z]+"
@ publica
functio parseRegexExpressia(Resolvitor r) -> Expressia {
    fixum p = r.parser()
    fixum locus = p.locusActualis()

    p.expectaVerbum("sed", ParserErrorCodice.ExpectaturExpressia)

    fixum patternSym = p.expecta(SymbolumGenus.Textus, ParserErrorCodice.ExpectaturTextusPostSed)

    redde finge LitteraRegex {
        locus: locus,
        forma: patternSym.valor,
        vexilla: ""
    } qua Expressia
}
