# ═══════════════════════════════════════════════════════════════════════════════
# AUXILIUM - Shared CLI utilities
# ═══════════════════════════════════════════════════════════════════════════════
#
# Common helpers for rivus CLI commands: input handling, display names,
# path manipulation, and error formatting.
#
# ═══════════════════════════════════════════════════════════════════════════════

§ ex "../../norma/hal/solum" importa solum
§ ex "../../norma/hal/consolum" importa consolum

§ ex "../lexor/index" importa lexare
§ ex "../parser/index" importa resolvere
§ ex "../ast/radix" importa SectioAnnotatio

# ═══════════════════════════════════════════════════════════════════════════════
# INPUT HANDLING
# ═══════════════════════════════════════════════════════════════════════════════

# Read source from file or stdin (when inputFile is "-")
@ publica
@ futura
functio hauriSource(textus inputFile) -> textus {
    si inputFile == "-" {
        varia lista<textus> lines = [] innatum lista<textus>
        varia textus line = consolum.hauriLineam()
        dum nonnihil line {
            lines.push(line)
            line = consolum.hauriLineam()
        }
        redde lines.join("\n")
    }
    redde cede solum.lege(inputFile)
}

# Human-readable name for error messages
@ publica
functio nomenOstende(textus inputFile) -> textus {
    redde inputFile == "-" sic "<stdin>" secus inputFile
}

# ═══════════════════════════════════════════════════════════════════════════════
# PATH UTILITIES
# ═══════════════════════════════════════════════════════════════════════════════

# Replace file extension (e.g., ".fab" -> ".ts")
@ publica
functio mutaExtensionem(textus via, textus novaExtensio) -> textus {
    fixum ultimusPunctum = via.lastIndexOf(".")
    si ultimusPunctum == -1 {
        redde scriptum("§§", via, novaExtensio)
    }
    redde scriptum("§§", via.slice(0, ultimusPunctum), novaExtensio)
}

# Compute relative path between two absolute paths
@ publica
functio viaRelativa(textus fons, textus destinatio) -> textus {
    fixum partes_fons = fons.split("/")
    fixum partes_dest = destinatio.split("/")

    # Find common prefix length
    varia numerus communis = 0
    dum communis < partes_fons.length et communis < partes_dest.length et partes_fons[communis] == partes_dest[communis] {
        communis = communis + 1
    }

    varia lista<textus> resultatum = [] innatum lista<textus>

    # Add ".." for each remaining segment in source path
    varia numerus i = 0
    dum i < partes_fons.length - communis {
        resultatum.push("..")
        i = i + 1
    }

    # Add remaining segments from target path
    varia numerus j = 0
    dum j < partes_dest.length - communis {
        resultatum.push(partes_dest[communis + j])
        j = j + 1
    }

    redde resultatum.join("/")
}

# ═══════════════════════════════════════════════════════════════════════════════
# VALIDATION
# ═══════════════════════════════════════════════════════════════════════════════

# Check if input file exists (returns false for stdin)
@ publica
functio validaInput(textus inputFile) -> bivalens {
    si inputFile == "-" {
        redde verum
    }
    redde solum.exstat(inputFile)
}

# ═══════════════════════════════════════════════════════════════════════════════
# MANIFEST LOADING
# ═══════════════════════════════════════════════════════════════════════════════

# Load sectiones from a manifest file (faber.fab)
# Returns nihil if no manifest path provided
# Throws on file not found or parse errors
@ publica
@ futura
functio loadManifestSectiones(textus? manifestPath) -> lista<SectioAnnotatio>? {
    si nihil manifestPath { redde nihil }

    si non solum.exstat(manifestPath) {
        iace novum Error(scriptum("Manifest not found: §", manifestPath))
    }

    figendum content = solum.lege(manifestPath)

    fixum lexResult = lexare(content)
    si positivum lexResult.errores.longitudo() {
        fixum msg = lexResult.errores[0].textus
        iace novum Error(scriptum("Manifest lexor error: §", msg))
    }

    fixum parseResult = resolvere(lexResult.symbola)
    si positivum parseResult.errores.longitudo() {
        fixum msg = parseResult.errores[0].nuntius
        iace novum Error(scriptum("Manifest parser error: §", msg))
    }

    si nihil parseResult.programma {
        iace novum Error("Failed to parse manifest")
    }

    redde parseResult.programma.sectiones
}

# ═══════════════════════════════════════════════════════════════════════════════
# TESTS
# ═══════════════════════════════════════════════════════════════════════════════

probandum "auxilium" {
    probandum "nomenOstende" {
        proba "returns <stdin> for dash" {
            adfirma nomenOstende("-") == "<stdin>"
        }
        proba "returns filename as-is" {
            adfirma nomenOstende("foo.fab") == "foo.fab"
        }
    }

    probandum "mutaExtensionem" {
        proba "replaces .fab with .ts" {
            adfirma mutaExtensionem("foo.fab", ".ts") == "foo.ts"
        }
        proba "handles paths with directories" {
            adfirma mutaExtensionem("src/lib/utils.fab", ".ts") == "src/lib/utils.ts"
        }
        proba "appends extension when none exists" {
            adfirma mutaExtensionem("README", ".md") == "README.md"
        }
    }

    probandum "viaRelativa" {
        proba "same directory" {
            adfirma viaRelativa("/a/b", "/a/c") == "../c"
        }
        proba "nested deeper" {
            adfirma viaRelativa("/a/b", "/a/b/c/d") == "c/d"
        }
        proba "sibling directories" {
            adfirma viaRelativa("/a/b/c", "/a/d/e") == "../../d/e"
        }
    }
}
