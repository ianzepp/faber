# ═══════════════════════════════════════════════════════════════════════════════
# TEST - Compile and run Faber tests with standalone harness
# ═══════════════════════════════════════════════════════════════════════════════
#
# Compiles .fab files with test harness generation and executes them.
# Tests use `probandum` and `proba` blocks with annotation-based configuration.
#
# Usage:
#   rivus test hello.fab                 # run tests in file
#   rivus test hello.fab --tag slow      # run only tests tagged "slow"
#   rivus test hello.fab --exclude slow  # exclude tests tagged "slow"
#   rivus test hello.fab --dry-run       # compile only, don't execute
#   rivus test hello.fab --json          # JSON error output
#
# Annotations supported on `proba` blocks:
#   @ omitte "reason"     - Skip test
#   @ futurum "reason"    - Mark as todo
#   @ solum               - Only run this test
#   @ tag "name"          - Tag for filtering
#   @ temporis 5000       - Timeout in ms
#   @ metior              - Benchmark mode
#   @ repete 100          - Repeat N times
#   @ fragilis 3          - Retry N times
#   @ requirit "ENV_VAR"  - Skip if env missing
#   @ solum_in "darwin"   - Platform filter
#
# ═══════════════════════════════════════════════════════════════════════════════

§ ex "../../lexor/index" importa lexare
§ ex "../../parser/index" importa resolvere
§ ex "../../semantic/index" importa analyze
§ ex "../../codegen/index" importa generateWithTests
§ ex "../../ast/radix" importa Programma

§ ex "../../../norma/hal/solum" importa solum
§ ex "../../../norma/hal/consolum" importa consolum
§ ex "../../../norma/hal/json" importa json
§ ex "../../../norma/hal/processus" importa processus

§ ex "../auxilium" importa hauriSource, nomenOstende, validaInput

# ═══════════════════════════════════════════════════════════════════════════════
# TEST COMMAND
# ═══════════════════════════════════════════════════════════════════════════════

@ publica
@ futura
functio testCommand(
    textus input,
    si textus target,
    si textus tag,
    si textus exclude,
    si textus stdinFilename,
    si bivalens jsonOutput,
    si bivalens dryRun,
    si bivalens solo
) -> numerus {
    fixum targetLang = target vel "ts"
    fixum displayName = stdinFilename vel nomenOstende(input)

    # Only TypeScript target supported for now
    si targetLang != "ts" {
        si jsonOutput {
            consolum.fundeLineam(json.solve({ error: "Test runner only supports TypeScript target" }))
        } secus {
            mone "Test runner only supports TypeScript target"
        }
        redde 1
    }

    # Validate input exists
    custodi {
        si non validaInput(input) {
            si jsonOutput {
                consolum.fundeLineam(json.solve({ error: scriptum("File not found: §", input) }))
            } secus {
                mone "File not found: §", input
            }
            redde 1
        }
    }

    figendum source = hauriSource(input)

    # Collect errors for potential JSON output
    varia lista<tabula<textus, ignotum>> errores = [] innatum lista<tabula<textus, ignotum>>

    # Lexical analysis
    fixum lexResult = lexare(source)

    si positivum lexResult.errores.longitudo() {
        si jsonOutput {
            ex lexResult.errores pro err {
                errores.push({
                    phase: "lexor",
                    file: displayName,
                    line: err.locus.linea,
                    column: err.locus.columna,
                    message: err.textus
                } innatum tabula<textus, ignotum>)
            }
            consolum.fundeLineam(json.solve({ errors: errores }))
        } secus {
            mone "Lexor errors:"
            ex lexResult.errores pro err {
                mone "  §:§:§ - §", displayName, err.locus.linea, err.locus.columna, err.textus
            }
        }
        redde 1
    }

    # Parsing
    fixum parseResult = resolvere(lexResult.symbola)

    si positivum parseResult.errores.longitudo() {
        si jsonOutput {
            ex parseResult.errores pro err {
                errores.push({
                    phase: "parser",
                    file: displayName,
                    line: err.locus.linea,
                    column: err.locus.columna,
                    message: err.nuntius
                } innatum tabula<textus, ignotum>)
            }
            consolum.fundeLineam(json.solve({ errors: errores }))
        } secus {
            mone "Parser errors:"
            ex parseResult.errores pro err {
                mone "  §:§:§ - §", displayName, err.locus.linea, err.locus.columna, err.nuntius
            }
        }
        redde 1
    }

    si nihil parseResult.programma {
        si jsonOutput {
            consolum.fundeLineam(json.solve({ error: "Failed to parse program" }))
        } secus {
            mone "Failed to parse program"
        }
        redde 1
    }

    # Semantic analysis
    fixum viaIngressus = input != "-" sic solum.absolve(input) secus nihil
    fixum semResult = analyze(parseResult.programma qua Programma, viaIngressus)

    si positivum semResult.errores.longitudo() {
        si jsonOutput {
            ex semResult.errores pro err {
                errores.push({
                    phase: "semantic",
                    file: displayName,
                    line: err.locus.linea,
                    column: err.locus.columna,
                    message: err.nuntius
                } innatum tabula<textus, ignotum>)
            }
            consolum.fundeLineam(json.solve({ errors: errores }))
        } secus {
            mone "Semantic errors:"
            ex semResult.errores pro err {
                mone "  §:§:§ - §", displayName, err.locus.linea, err.locus.columna, err.nuntius
            }
        }
        redde 1
    }

    # Code generation with test harness
    fixum generated = generateWithTests((parseResult.programma qua Programma).corpus, targetLang)

    # Dry run stops here
    si dryRun {
        si jsonOutput {
            consolum.fundeLineam(json.solve({ success: verum, file: displayName, code: generated }))
        } secus {
            scribe "§: Compiled (dry run)", displayName
            consolum.fundeTextum(generated)
        }
        redde 0
    }

    # Write to temp file and execute
    fixum tempFile = scriptum("/tmp/faber-test-§.ts", processus.pid())

    tempta {
        cede solum.scribe(tempFile, generated)

        # Build bun command with options
        varia args = [tempFile] innatum lista<textus>

        # Execute with Bun
        fixum proc = processus.spawn("bun", args, {
            stdout: "inherit",
            stderr: "inherit"
        })

        figendum exitCode = proc.exited

        # Cleanup temp file
        cede solum.dele(tempFile)

        si exitCode != 0 {
            redde exitCode qua numerus
        }

        redde 0
    } cape err {
        mone "Test execution error: §", err
        # Try to cleanup
        tempta {
            cede solum.dele(tempFile)
        } cape _ {
            # Ignore cleanup errors
        }
        redde 1
    }
}
