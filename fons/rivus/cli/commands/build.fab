# ═══════════════════════════════════════════════════════════════════════════════
# BUILD - Compile entry point and all dependencies to output directory
# ═══════════════════════════════════════════════════════════════════════════════
#
# Compiles a Faber source file and all its local imports, preserving
# the directory structure in the output.
#
# Usage:
#   rivus build main.fab -o dist/        # build to dist/
#   rivus build main.fab                 # build to ./dist (default)
#
# Output structure mirrors source:
#   src/main.fab           -> dist/src/main.ts
#   src/lib/utils.fab      -> dist/src/lib/utils.ts
#
# ═══════════════════════════════════════════════════════════════════════════════

ex "../../lexor/index" importa lexare
ex "../../parser/index" importa resolvere
ex "../../semantic/index" importa analyze
ex "../../semantic/nucleus" importa SemanticResultatum
ex "../../codegen/index" importa generate
ex "../../ast/radix" importa Programma

ex "../../../norma/hal/solum" importa solum
ex "../../../norma/hal/processus" importa processus

ex "../auxilium" importa mutaExtensionem, viaRelativa

# ═══════════════════════════════════════════════════════════════════════════════
# TYPES
# ═══════════════════════════════════════════════════════════════════════════════

genus CompileResultatum {
    @ publica
    Programma programma
    @ publica
    SemanticResultatum semResult
}

# ═══════════════════════════════════════════════════════════════════════════════
# COMPILATION
# ═══════════════════════════════════════════════════════════════════════════════

@ futura
functio compileFile(textus filePath, textus displayName) -> CompileResultatum? {
    fixum source = cede solum.lege(filePath)

    # Lexical analysis
    fixum lexResult = lexare(source)

    si positivum lexResult.errores.longitudo() {
        mone "Lexor errors:"
        ex lexResult.errores pro err {
            mone scriptum("  §:§:§ - §", displayName, err.locus.linea, err.locus.columna, err.textus)
        }
        redde nihil
    }

    # Parsing
    fixum parseResult = resolvere(lexResult.symbola)

    si positivum parseResult.errores.longitudo() {
        mone "Parser errors:"
        ex parseResult.errores pro err {
            mone scriptum("  §:§:§ - §", displayName, err.locus.linea, err.locus.columna, err.nuntius)
        }
        redde nihil
    }

    si nihil parseResult.programma {
        mone scriptum("Failed to parse: §", displayName)
        redde nihil
    }

    # Semantic analysis
    fixum semResult = analyze(parseResult.programma qua Programma, filePath)

    si positivum semResult.errores.longitudo() {
        mone "Semantic errors:"
        ex semResult.errores pro err {
            mone scriptum("  §:§:§ - §", displayName, err.locus.linea, err.locus.columna, err.nuntius)
        }
        redde nihil
    }

    redde novum CompileResultatum {
        programma: parseResult.programma qua Programma,
        semResult: semResult
    }
}

# ═══════════════════════════════════════════════════════════════════════════════
# BUILD COMMAND
# ═══════════════════════════════════════════════════════════════════════════════

@ publica
@ futura
functio buildCommand(
    textus input,
    si textus target,
    si textus output
) -> numerus {
    fixum targetLang = target vel "ts"
    fixum outputDir = output vel "./dist"
    fixum projectRoot = processus.cwd()

    # Resolve and validate entry path
    fixum entryPath = solum.absolve(input)

    custodi {
        si non solum.exstat(entryPath) {
            mone scriptum("File not found: §", input)
            redde 1
        }
    }

    # Compile entry file
    fixum entryResult = cede compileFile(entryPath, input)

    si nihil entryResult {
        redde 1
    }

    # Create output directory
    cede solum.creaDir(outputDir)

    # Calculate output path for entry file
    fixum entryRelPath = viaRelativa(projectRoot, entryPath)
    fixum targetExt = targetLang == "go" sic ".go" secus ".ts"
    fixum entryOutPath = solum.iunge([outputDir, mutaExtensionem(entryRelPath, targetExt)])

    # Ensure output subdirectory exists
    cede solum.creaDir(solum.dir(entryOutPath))

    # Generate and write entry file
    fixum entryOutput = generate(entryResult.programma.corpus, targetLang)
    cede solum.scribe(entryOutPath, entryOutput)
    scribe scriptum("  § -> §", input, entryOutPath)

    # Process dependencies from semantic analysis
    varia numerus fileCount = 1
    varia bivalens hadErrors = falsum

    si entryResult.semResult.resolvedModules {
        ex entryResult.semResult.resolvedModules fixum [depPath, depProgram] {
            # Semantic analysis for dependency
            fixum depAnalysis = analyze(depProgram, depPath)

            si positivum depAnalysis.errores.longitudo() {
                mone "Semantic errors:"
                ex depAnalysis.errores pro err {
                    mone scriptum("  §:§:§ - §", depPath, err.locus.linea, err.locus.columna, err.nuntius)
                }
                hadErrors = verum
                perge
            }

            # Calculate output path
            fixum depRelPath = viaRelativa(projectRoot, depPath)
            fixum depOutPath = solum.iunge([outputDir, mutaExtensionem(depRelPath, targetExt)])

            # Ensure subdirectory exists
            cede solum.creaDir(solum.dir(depOutPath))

            # Generate and write
            fixum depOutput = generate(depProgram.corpus, targetLang)
            cede solum.scribe(depOutPath, depOutput)
            scribe scriptum("  § -> §", depRelPath, depOutPath)

            fileCount = fileCount + 1
        }
    }

    # Check if any dependencies failed
    si hadErrors {
        redde 1
    }

    scribe ""
    scribe scriptum("Build complete: § file(s) written to §", fileCount, outputDir)

    redde 0
}
