# ═══════════════════════════════════════════════════════════════════════════════
# BUILD - Compile entry point and all dependencies to output directory
# ═══════════════════════════════════════════════════════════════════════════════
#
# Compiles a Faber source file and all its local imports, preserving
# the directory structure in the output.
#
# Usage:
#   rivus build main.fab -o dist/        # build to dist/
#   rivus build main.fab                  # build to ./dist (default)
#
# Output structure mirrors source:
#   src/main.fab           -> dist/src/main.ts
#   src/lib/utils.fab      -> dist/src/lib/utils.ts
#
# ═══════════════════════════════════════════════════════════════════════════════

ex "../../lexor/index" importa lexare
ex "../../parser/index" importa resolvere
ex "../../semantic/index" importa analyze
ex "../../semantic/nucleus" importa SemanticResultatum
ex "../../codegen/index" importa generate
ex "../../ast/radix" importa Programma

ex "../../../norma/hal/solum" importa solum
ex "../../../norma/hal/processus" importa processus

# ═══════════════════════════════════════════════════════════════════════════════
# PATH UTILITIES
# ═══════════════════════════════════════════════════════════════════════════════

functio replaceExtension(textus path, textus newExt) -> textus {
    fixum lastDot = path.lastIndexOf(".")
    si lastDot == -1 {
        redde path + newExt
    }
    redde path.slice(0, lastDot) + newExt
}

functio relativePath(textus from, textus to) -> textus {
    # Simple relative path calculation
    # Assumes both paths are absolute
    fixum fromParts = from.split("/")
    fixum toParts = to.split("/")

    # Find common prefix
    varia numerus common = 0
    dum common < fromParts.length et common < toParts.length et fromParts[common] == toParts[common] {
        common = common + 1
    }

    # Build relative path
    varia lista<textus> result = [] innatum lista<textus>

    # Add ".." for each remaining part in 'from'
    ex numerum(fromParts.length - common) pro i {
        result.push("..")
    }

    # Add remaining parts from 'to'
    ex numerum(toParts.length - common) pro i {
        result.push(toParts[common + i])
    }

    redde result.join("/")
}

# ═══════════════════════════════════════════════════════════════════════════════
# COMPILATION
# ═══════════════════════════════════════════════════════════════════════════════

genus CompileResultatum {
    Programma programma
    SemanticResultatum semResult
}

@ futura
functio compileFile(textus filePath, textus displayName) -> CompileResultatum? {
    fixum source = cede solum.lege(filePath)

    # Lexical analysis
    fixum lexResult = lexare(source)

    si lexResult.errores.longitudo() > 0 {
        mone "Lexor errors:"
        ex lexResult.errores pro err {
            mone scriptum("  §:§:§ - §", displayName, err.locus.linea, err.locus.columna, err.textus)
        }
        redde nihil
    }

    # Parsing
    fixum parseResult = resolvere(lexResult.symbola)

    si positivum parseResult.errores.longitudo() {
        mone "Parser errors:"
        ex parseResult.errores pro err {
            mone scriptum("  §:§:§ - §", displayName, err.locus.linea, err.locus.columna, err.nuntius)
        }
        redde nihil
    }

    si nihil parseResult.programma {
        mone scriptum("Failed to parse: §", displayName)
        redde nihil
    }

    # Semantic analysis
    fixum semResult = analyze(parseResult.programma qua Programma, filePath)

    si positivum semResult.errores.longitudo() {
        mone "Semantic errors:"
        ex semResult.errores pro err {
            mone scriptum("  §:§:§ - §", displayName, err.locus.linea, err.locus.columna, err.nuntius)
        }
        redde nihil
    }

    redde novum CompileResultatum {
        programma: parseResult.programma qua Programma,
        semResult: semResult
    }
}

# ═══════════════════════════════════════════════════════════════════════════════
# BUILD COMMAND
# ═══════════════════════════════════════════════════════════════════════════════

@ publica
@ futura
functio buildCommand(
    textus input,
    si textus target,
    si textus output
) -> numerus {
    fixum targetLang = target vel "ts"
    fixum outputDir = output vel "./dist"
    fixum projectRoot = processus.cwd()

    # Resolve entry path
    fixum entryPath = solum.absolve(input)

    si non solum.exstat(entryPath) {
        mone scriptum("File not found: §", input)
        redde 1
    }

    # Compile entry file
    fixum entryResult = cede compileFile(entryPath, input)

    si nihil entryResult {
        redde 1
    }

    # Create output directory
    cede solum.creaDir(outputDir)

    # Calculate output path for entry file
    fixum entryRelPath = relativePath(projectRoot, entryPath)
    fixum targetExt = targetLang == "go" sic ".go" secus ".ts"
    fixum entryOutPath = solum.iunge([outputDir, replaceExtension(entryRelPath, targetExt)])

    # Ensure output subdirectory exists
    cede solum.creaDir(solum.dir(entryOutPath))

    # Generate and write entry file
    fixum entryOutput = generate(entryResult.programma.corpus, targetLang)
    cede solum.scribe(entryOutPath, entryOutput)
    scribe scriptum("  § -> §", input, entryOutPath)

    # Process dependencies from semantic analysis
    varia numerus fileCount = 1

    si entryResult.semResult.resolvedModules {
        ex entryResult.semResult.resolvedModules pro depPath, depProgram {
            # Compile dependency
            fixum depAnalysis = analyze(depProgram, depPath)

            si depAnalysis.errores.longitudo() > 0 {
                mone "Semantic errors:"
                ex depAnalysis.errores pro err {
                    mone scriptum("  §:§:§ - §", depPath, err.locus.linea, err.locus.columna, err.nuntius)
                }
                redde 1
            }

            # Calculate output path
            fixum depRelPath = relativePath(projectRoot, depPath)
            fixum depOutPath = solum.iunge([outputDir, replaceExtension(depRelPath, targetExt)])

            # Ensure subdirectory exists
            cede solum.creaDir(solum.dir(depOutPath))

            # Generate and write
            fixum depOutput = generate(depProgram.corpus, targetLang)
            cede solum.scribe(depOutPath, depOutput)
            scribe scriptum("  § -> §", depRelPath, depOutPath)

            fileCount = fileCount + 1
        }
    }

    scribe ""
    scribe scriptum("Build complete: § file(s) written to §", fileCount, outputDir)

    redde 0
}
