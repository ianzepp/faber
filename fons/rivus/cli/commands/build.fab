# ═══════════════════════════════════════════════════════════════════════════════
# BUILD - Compile entry point and all dependencies to output directory
# ═══════════════════════════════════════════════════════════════════════════════
#
# Compiles a Faber source file and all its local imports, preserving
# the directory structure in the output.
#
# Usage:
#   rivus build main.fab -o dist/        # build to dist/
#   rivus build main.fab                 # build to ./dist (default)
#   rivus build main.fab --dry-run       # check without writing
#   rivus build main.fab --list-files    # show files that would be compiled
#   rivus build main.fab --json          # errors as JSON
#
# Output structure mirrors source:
#   src/main.fab           -> dist/src/main.ts
#   src/lib/utils.fab      -> dist/src/lib/utils.ts
#
# ═══════════════════════════════════════════════════════════════════════════════

§ ex "../../lexor/index" importa lexare
§ ex "../../parser/index" importa resolvere
§ ex "../../semantic/index" importa analyze
§ ex "../../semantic/nucleus" importa SemanticResultatum
§ ex "../../codegen/index" importa generate, generateWithStripping
§ ex "../../ast/radix" importa Programma, SectioAnnotatio

§ ex "../../../norma/hal/solum" importa solum
§ ex "../../../norma/hal/processus" importa processus
§ ex "../../../norma/hal/consolum" importa consolum
§ ex "../../../norma/hal/json" importa json

§ ex "../auxilium" importa mutaExtensionem, viaRelativa, loadManifestSectiones

# ═══════════════════════════════════════════════════════════════════════════════
# TYPES
# ═══════════════════════════════════════════════════════════════════════════════

genus CompileResultatum {
    @ publica
    Programma programma
    @ publica
    SemanticResultatum semResult
}

# ═══════════════════════════════════════════════════════════════════════════════
# COMPILATION
# ═══════════════════════════════════════════════════════════════════════════════

@ futura
functio compileFile(
    textus filePath,
    textus displayName,
    de lista<tabula<textus, ignotum>> errores,
    si bivalens jsonOutput,
    si lista<SectioAnnotatio>? manifestSectiones
) -> CompileResultatum? {
    figendum source = solum.lege(filePath)

    # Lexical analysis
    fixum lexResult = lexare(source)

    si positivum lexResult.errores.longitudo() {
        si jsonOutput {
            ex lexResult.errores pro err {
                errores.push({
                    phase: "lexor",
                    file: displayName,
                    line: err.locus.linea,
                    column: err.locus.columna,
                    message: err.textus
                } innatum tabula<textus, ignotum>)
            }
        }
        secus {
            mone "Lexor errors:"
            ex lexResult.errores pro err {
                mone "  §:§:§ - §", displayName, err.locus.linea, err.locus.columna, err.textus
            }
        }
        redde nihil
    }

    # Parsing
    fixum parseResult = resolvere(lexResult.symbola)

    si positivum parseResult.errores.longitudo() {
        si jsonOutput {
            ex parseResult.errores pro err {
                errores.push({
                    phase: "parser",
                    file: displayName,
                    line: err.locus.linea,
                    column: err.locus.columna,
                    message: err.nuntius
                } innatum tabula<textus, ignotum>)
            }
        }
        secus {
            mone "Parser errors:"
            ex parseResult.errores pro err {
                mone "  §:§:§ - §", displayName, err.locus.linea, err.locus.columna, err.nuntius
            }
        }
        redde nihil
    }

    si nihil parseResult.programma {
        si jsonOutput {
            errores.push({
                phase: "parser",
                file: displayName,
                message: "Failed to parse"
            } innatum tabula<textus, ignotum>)
        }
        secus {
            mone "Failed to parse: §", displayName
        }
        redde nihil
    }

    # Semantic analysis
    fixum semResult = analyze(parseResult.programma qua Programma, filePath, manifestSectiones)

    si positivum semResult.errores.longitudo() {
        si jsonOutput {
            ex semResult.errores pro err {
                errores.push({
                    phase: "semantic",
                    file: displayName,
                    line: err.locus.linea,
                    column: err.locus.columna,
                    message: err.nuntius
                } innatum tabula<textus, ignotum>)
            }
        }
        secus {
            mone "Semantic errors:"
            ex semResult.errores pro err {
                mone "  §:§:§ - §", displayName, err.locus.linea, err.locus.columna, err.nuntius
            }
        }
        redde nihil
    }

    redde novum CompileResultatum {
        programma: parseResult.programma qua Programma,
        semResult: semResult
    }
}

# ═══════════════════════════════════════════════════════════════════════════════
# BUILD COMMAND
# ═══════════════════════════════════════════════════════════════════════════════

@ publica
@ futura
functio buildCommand(
    textus input,
    si textus target,
    si textus output,
    si textus include,
    si textus manifest,
    si bivalens jsonOutput,
    si bivalens dryRun,
    si bivalens listFiles,
    si bivalens stripComments
) -> numerus {
    fixum targetLang = target vel "ts"
    fixum outputDir = output vel "./dist"
    fixum projectRoot = processus.cwd()

    # Collect errors for JSON output
    varia lista<tabula<textus, ignotum>> errores = [] innatum lista<tabula<textus, ignotum>>

    # Resolve and validate entry path
    fixum entryPath = solum.absolve(input)

    custodi {
        si non solum.exstat(entryPath) {
            si jsonOutput {
                consolum.fundeLineam(json.solve({ error: scriptum("File not found: §", input) }))
            }
            secus {
                mone "File not found: §", input
            }
            redde 1
        }
    }

    # Load manifest sectiones if provided
    figendum manifestSectiones = loadManifestSectiones(manifest)

    # Compile entry file
    figendum entryResult = compileFile(entryPath, input, errores, jsonOutput, manifestSectiones)

    si nihil entryResult {
        si jsonOutput {
            consolum.fundeLineam(json.solve({ errors: errores }))
        }
        redde 1
    }

    # Calculate output path for entry file
    fixum entryRelPath = viaRelativa(projectRoot, entryPath)
    fixum targetExt = targetLang == "go" sic ".go" secus ".ts"
    fixum entryOutPath = solum.iunge([outputDir, mutaExtensionem(entryRelPath, targetExt)])

    # Collect all files for --list-files
    varia lista<tabula<textus, textus>> filesToWrite = [] innatum lista<tabula<textus, textus>>

    # Generate entry file
    fixum entryOutput = stripComments sic generateWithStripping(entryResult.programma.corpus, targetLang, falsum, verum) secus generate(entryResult.programma.corpus, targetLang)
    filesToWrite.push({ source: input, target: entryOutPath } innatum tabula<textus, textus>)

    # Process dependencies from semantic analysis
    varia bivalens hadErrors = falsum

    si entryResult.semResult.resolvedModules {
        ex entryResult.semResult.resolvedModules fixum [depPath, depProgram] {
            # Semantic analysis for dependency
            fixum depAnalysis = analyze(depProgram, depPath, manifestSectiones)

            si positivum depAnalysis.errores.longitudo() {
                si jsonOutput {
                    ex depAnalysis.errores pro err {
                        errores.push({
                            phase: "semantic",
                            file: depPath,
                            line: err.locus.linea,
                            column: err.locus.columna,
                            message: err.nuntius
                        } innatum tabula<textus, ignotum>)
                    }
                }
                secus {
                    mone "Semantic errors:"
                    ex depAnalysis.errores pro err {
                        mone "  §:§:§ - §", depPath, err.locus.linea, err.locus.columna, err.nuntius
                    }
                }
                hadErrors = verum
                perge
            }

            # Calculate output path
            fixum depRelPath = viaRelativa(projectRoot, depPath)
            fixum depOutPath = solum.iunge([outputDir, mutaExtensionem(depRelPath, targetExt)])

            # Generate
            fixum depOutput = stripComments sic generateWithStripping(depProgram.corpus, targetLang, falsum, verum) secus generate(depProgram.corpus, targetLang)
            filesToWrite.push({ source: depRelPath, target: depOutPath } innatum tabula<textus, textus>)
        }
    }

    # Check for errors before writing
    si hadErrors {
        si jsonOutput {
            consolum.fundeLineam(json.solve({ errors: errores }))
        }
        redde 1
    }

    # List files mode
    si listFiles {
        si jsonOutput {
            consolum.fundeLineam(json.solve({ files: filesToWrite }))
        }
        secus {
            ex filesToWrite pro file {
                scribe "§ -> §", file["source"], file["target"]
            }
        }
        redde 0
    }

    # Dry run stops here
    si dryRun {
        si jsonOutput {
            consolum.fundeLineam(json.solve({ success: verum, fileCount: filesToWrite.length }))
        }
        secus {
            scribe "Would compile § file(s) to §", filesToWrite.length, outputDir
        }
        redde 0
    }

    # Create output directory and write files
    cede solum.creaDir(outputDir)

    varia numerus fileCount = 0
    ex filesToWrite pro file {
        cede solum.creaDir(solum.dir(file["target"]))

        # Re-generate (we could cache this, but keeping it simple)
        si fileCount == 0 {
            cede solum.scribe(file["target"], entryOutput)
        }
        secus {
            # For dependencies, regenerate from the resolved modules
            # This is a simplification - in practice we'd cache the generated output
            fixum depProgram = entryResult.semResult.resolvedModules![solum.absolve(file["source"])]
            si nonnihil depProgram {
                fixum depOutput = stripComments sic generateWithStripping(depProgram.corpus, targetLang, falsum, verum) secus generate(depProgram.corpus, targetLang)
                cede solum.scribe(file["target"], depOutput)
            }
        }

        si non jsonOutput {
            scribe "  § -> §", file["source"], file["target"]
        }
        fileCount = fileCount + 1
    }

    si jsonOutput {
        consolum.fundeLineam(json.solve({ success: verum, fileCount: fileCount, outputDir: outputDir }))
    }
    secus {
        scribe ""
        scribe "Build complete: § file(s) written to §", fileCount, outputDir
    }

    redde 0
}
