# ═══════════════════════════════════════════════════════════════════════════════
# CHECK - Validate Faber source without code generation
# ═══════════════════════════════════════════════════════════════════════════════
#
# Runs full analysis pipeline (lex + parse + semantic) without codegen.
# Fast validation for editors, CI, and pre-commit hooks.
#
# Usage:
#   rivus check hello.fab                # validate single file
#   rivus check -                        # validate from stdin
#
# ═══════════════════════════════════════════════════════════════════════════════

ex "../../lexor/index" importa lexare
ex "../../parser/index" importa resolvere
ex "../../semantic/index" importa analyze
ex "../../ast/radix" importa Programma

ex "../../../norma/hal/solum" importa solum

ex "../auxilium" importa hauriSource, nomenOstende, validaInput

# ═══════════════════════════════════════════════════════════════════════════════
# CHECK COMMAND
# ═══════════════════════════════════════════════════════════════════════════════

@ publica
@ futura
functio checkCommand(textus input) -> numerus {
    fixum displayName = nomenOstende(input)

    # Validate input exists
    custodi {
        si non validaInput(input) {
            mone scriptum("File not found: §", input)
            redde 1
        }
    }

    fixum source = cede hauriSource(input)

    varia numerus errorCount = 0

    # Lexical analysis
    fixum lexResult = lexare(source)
    errorCount = errorCount + lexResult.errores.longitudo()

    si positivum lexResult.errores.longitudo() {
        mone "Lexor errors:"
        ex lexResult.errores pro err {
            mone scriptum("  §:§:§ - §", displayName, err.locus.linea, err.locus.columna, err.textus)
        }
    }

    # Parsing (continue even with lex errors to report all issues)
    fixum parseResult = resolvere(lexResult.symbola)
    errorCount = errorCount + parseResult.errores.longitudo()

    si positivum parseResult.errores.longitudo() {
        mone "Parser errors:"
        ex parseResult.errores pro err {
            mone scriptum("  §:§:§ - §", displayName, err.locus.linea, err.locus.columna, err.nuntius)
        }
    }

    # Semantic analysis (only if we have a valid AST)
    si nonnihil parseResult.programma {
        fixum viaIngressus = input != "-" sic solum.absolve(input) secus nihil
        fixum semResult = analyze(parseResult.programma qua Programma, viaIngressus)
        errorCount = errorCount + semResult.errores.longitudo()

        si positivum semResult.errores.longitudo() {
            mone "Semantic errors:"
            ex semResult.errores pro err {
                mone scriptum("  §:§:§ - §", displayName, err.locus.linea, err.locus.columna, err.nuntius)
            }
        }
    }

    # Summary
    si positivum errorCount {
        scribe scriptum("§: § error(s)", displayName, errorCount)
        redde 1
    }

    scribe scriptum("§: No errors", displayName)
    redde 0
}
