# ═══════════════════════════════════════════════════════════════════════════════
# FETCH - Download and cache GitHub dependencies
# ═══════════════════════════════════════════════════════════════════════════════
#
# Reads § dependentia annotations from a manifest and fetches GitHub dependencies
# to the local cache (~/.cache/faber/).
#
# Usage:
#   rivus fetch --manifest faber.fab           # fetch all github deps
#   rivus fetch --manifest faber.fab --force   # re-fetch even if cached
#
# ═══════════════════════════════════════════════════════════════════════════════

§ ex "../../semantic/dependentia" importa extractDependentiae, Dependentia, pangeGithubFontem, GithubReferentia, estCacheatum, viaCachei
§ ex "../../ast/radix" importa SectioAnnotatio
§ ex "../fetch/github" importa resolveReferentiam, deferTarball
§ ex "../fetch/cache" importa extraheInCacheum

§ ex "../../../norma/hal/solum" importa solum
§ ex "../../../norma/hal/json" importa json
§ ex "../../../norma/hal/consolum" importa consolum

§ ex "../auxilium" importa loadManifestSectiones

# ═══════════════════════════════════════════════════════════════════════════════
# FETCH COMMAND
# ═══════════════════════════════════════════════════════════════════════════════

@ publica
@ futura
functio mandatumArcessere(
    si textus manifest,
    si bivalens force,
    si bivalens jsonOutput
) -> numerus {
    # Require manifest
    si nihil manifest {
        si jsonOutput {
            consolum.fundeLineam(json.solve({ error: "No manifest specified. Use --manifest faber.fab" }))
        } secus {
            mone "No manifest specified. Use --manifest faber.fab"
        }
        redde 1
    }

    # Check manifest exists
    si non solum.exstat(manifest) {
        si jsonOutput {
            consolum.fundeLineam(json.solve({ error: scriptum("Manifest not found: §", manifest) }))
        } secus {
            mone "Manifest not found: §", manifest
        }
        redde 1
    }

    # Load manifest sectiones
    varia lista<SectioAnnotatio>? manifestSectiones = nihil
    tempta {
        figendum lectum = loadManifestSectiones(manifest)
        manifestSectiones = lectum
    } cape err {
        si jsonOutput {
            consolum.fundeLineam(json.solve({ error: scriptum("Failed to load manifest: §", err) }))
        } secus {
            mone "Failed to load manifest: §", err
        }
        redde 1
    }

    # Extract dependencies
    fixum dependentiae = extractDependentiae(manifestSectiones)

    # Collect github dependencies
    varia lista<tabula<textus, textus>> arcessenda = [] innatum lista<tabula<textus, textus>>

    de dependentiae pro alias {
        fixum dep = dependentiae[alias] qua Dependentia

        # Skip if no github source
        si nihil dep.github { perge }

        fixum resolutum = pangeGithubFontem(dep.github qua textus)
        si nihil resolutum { perge }

        arcessenda.push({
            alias: alias,
            dominus: resolutum.dominus,
            repo: resolutum.repo,
            ref: resolutum.ref,
            via: dep.via vel ""
        } innatum tabula<textus, textus>)
    }

    si arcessenda.longitudo() == 0 {
        si jsonOutput {
            consolum.fundeLineam(json.solve({ message: "No GitHub dependencies to fetch" }))
        } secus {
            scribe "No GitHub dependencies to fetch"
        }
        redde 0
    }

    # Fetch each dependency
    varia numerus arcessita = 0
    varia numerus praetermissa = 0
    varia numerus defecta = 0
    varia lista<tabula<textus, textus>> resultata = [] innatum lista<tabula<textus, textus>>

    ex arcessenda pro dep {
        fixum alias = dep["alias"]
        fixum dominus = dep["dominus"]
        fixum repo = dep["repo"]
        fixum ref = dep["ref"]

        si non jsonOutput {
            scribe "Fetching §... (§/§#§)", alias, dominus, repo, ref
        }

        # Resolve ref to commit SHA
        fixum ghRef = novum GithubReferentia { dominus: dominus, repo: repo, ref: ref }
        figendum sha = resolveReferentiam(ghRef)

        si nihil sha {
            si jsonOutput {
                resultata.push({
                    alias: alias,
                    status: "failed",
                    error: "Failed to resolve ref"
                } innatum tabula<textus, textus>)
            } secus {
                mone "  Failed to resolve ref §/§#§", dominus, repo, ref
            }
            defecta = defecta + 1
            perge
        }

        # Check if already cached (skip if not --force)
        si estCacheatum(dominus, repo, sha qua textus) et non force {
            si jsonOutput {
                resultata.push({
                    alias: alias,
                    status: "skipped",
                    sha: sha qua textus,
                    reason: "already cached"
                } innatum tabula<textus, textus>)
            } secus {
                scribe "  Skipped (already cached at §)", sha
            }
            praetermissa = praetermissa + 1
            perge
        }

        # Download tarball
        si non jsonOutput {
            scribe "  Downloading §...", sha
        }

        figendum tarball = deferTarball(dominus, repo, sha qua textus)

        si nihil tarball {
            si jsonOutput {
                resultata.push({
                    alias: alias,
                    status: "failed",
                    sha: sha qua textus,
                    error: "Failed to download tarball"
                } innatum tabula<textus, textus>)
            } secus {
                mone "  Failed to download tarball"
            }
            defecta = defecta + 1
            perge
        }

        # Extract to cache
        si non jsonOutput {
            scribe "  Extracting to cache..."
        }

        tempta {
            cede extraheInCacheum(tarball qua textus, dominus, repo, sha qua textus)
        } cape err {
            si jsonOutput {
                resultata.push({
                    alias: alias,
                    status: "failed",
                    sha: sha qua textus,
                    error: scriptum("Failed to extract: §", err)
                } innatum tabula<textus, textus>)
            } secus {
                mone "  Failed to extract: §", err
            }
            defecta = defecta + 1
            perge
        }

        # Clean up tarball
        tempta {
            cede solum.dele(tarball qua textus)
        } cape err {
            # Ignore cleanup errors
        }

        si jsonOutput {
            resultata.push({
                alias: alias,
                status: "fetched",
                sha: sha qua textus,
                path: viaCachei(dominus, repo, sha qua textus)
            } innatum tabula<textus, textus>)
        } secus {
            scribe "  Cached at §", viaCachei(dominus, repo, sha qua textus)
        }

        arcessita = arcessita + 1
    }

    # Summary
    si jsonOutput {
        consolum.fundeLineam(json.solve({
            fetched: arcessita,
            skipped: praetermissa,
            failed: defecta,
            results: resultata
        }))
    } secus {
        scribe ""
        scribe "Fetch complete: § fetched, § skipped, § failed", arcessita, praetermissa, defecta
    }

    redde defecta > 0 sic 1 secus 0
}
