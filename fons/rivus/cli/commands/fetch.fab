# ═══════════════════════════════════════════════════════════════════════════════
# FETCH - Download and cache GitHub dependencies
# ═══════════════════════════════════════════════════════════════════════════════
#
# Reads § dependentia annotations from a manifest and fetches GitHub dependencies
# to the local cache (~/.cache/faber/).
#
# Usage:
#   rivus fetch --manifest faber.fab           # fetch all github deps
#   rivus fetch --manifest faber.fab --force   # re-fetch even if cached
#
# ═══════════════════════════════════════════════════════════════════════════════

§ ex "../../semantic/dependentia" importa extractDependentiae, Dependentia, parseGithubSource, GithubRef, isCached, cachePath
§ ex "../../ast/radix" importa SectioAnnotatio
§ ex "../fetch/github" importa resolveRef, downloadTarball
§ ex "../fetch/cache" importa extractToCache

§ ex "../../../norma/hal/solum" importa solum
§ ex "../../../norma/hal/json" importa json
§ ex "../../../norma/hal/consolum" importa consolum

§ ex "../auxilium" importa loadManifestSectiones

# ═══════════════════════════════════════════════════════════════════════════════
# FETCH COMMAND
# ═══════════════════════════════════════════════════════════════════════════════

@ publica
@ futura
functio fetchCommand(
    si textus manifest,
    si bivalens force,
    si bivalens jsonOutput
) -> numerus {
    # Require manifest
    si nihil manifest {
        si jsonOutput {
            consolum.fundeLineam(json.solve({ error: "No manifest specified. Use --manifest faber.fab" }))
        } secus {
            mone "No manifest specified. Use --manifest faber.fab"
        }
        redde 1
    }

    # Check manifest exists
    si non solum.exstat(manifest) {
        si jsonOutput {
            consolum.fundeLineam(json.solve({ error: scriptum("Manifest not found: §", manifest) }))
        } secus {
            mone "Manifest not found: §", manifest
        }
        redde 1
    }

    # Load manifest sectiones
    varia lista<SectioAnnotatio>? manifestSectiones = nihil
    tempta {
        figendum loaded = loadManifestSectiones(manifest)
        manifestSectiones = loaded
    } cape err {
        si jsonOutput {
            consolum.fundeLineam(json.solve({ error: scriptum("Failed to load manifest: §", err) }))
        } secus {
            mone "Failed to load manifest: §", err
        }
        redde 1
    }

    # Extract dependencies
    fixum dependentiae = extractDependentiae(manifestSectiones)

    # Collect github dependencies
    varia lista<tabula<textus, textus>> toFetch = [] innatum lista<tabula<textus, textus>>

    de dependentiae pro alias {
        fixum dep = dependentiae[alias] qua Dependentia

        # Skip if no github source
        si nihil dep.github { perge }

        fixum parsed = parseGithubSource(dep.github qua textus)
        si nihil parsed { perge }

        toFetch.push({
            alias: alias,
            owner: parsed.owner,
            repo: parsed.repo,
            ref: parsed.ref,
            via: dep.via vel ""
        } innatum tabula<textus, textus>)
    }

    si toFetch.longitudo() == 0 {
        si jsonOutput {
            consolum.fundeLineam(json.solve({ message: "No GitHub dependencies to fetch" }))
        } secus {
            scribe "No GitHub dependencies to fetch"
        }
        redde 0
    }

    # Fetch each dependency
    varia numerus fetched = 0
    varia numerus skipped = 0
    varia numerus failed = 0
    varia lista<tabula<textus, textus>> results = [] innatum lista<tabula<textus, textus>>

    ex toFetch pro dep {
        fixum alias = dep["alias"]
        fixum owner = dep["owner"]
        fixum repo = dep["repo"]
        fixum ref = dep["ref"]

        si non jsonOutput {
            scribe "Fetching §... (§/§#§)", alias, owner, repo, ref
        }

        # Resolve ref to commit SHA
        fixum ghRef = novum GithubRef { owner: owner, repo: repo, ref: ref }
        figendum sha = resolveRef(ghRef)

        si nihil sha {
            si jsonOutput {
                results.push({
                    alias: alias,
                    status: "failed",
                    error: "Failed to resolve ref"
                } innatum tabula<textus, textus>)
            } secus {
                mone "  Failed to resolve ref §/§#§", owner, repo, ref
            }
            failed = failed + 1
            perge
        }

        # Check if already cached (skip if not --force)
        si isCached(owner, repo, sha qua textus) et non force {
            si jsonOutput {
                results.push({
                    alias: alias,
                    status: "skipped",
                    sha: sha qua textus,
                    reason: "already cached"
                } innatum tabula<textus, textus>)
            } secus {
                scribe "  Skipped (already cached at §)", sha
            }
            skipped = skipped + 1
            perge
        }

        # Download tarball
        si non jsonOutput {
            scribe "  Downloading §...", sha
        }

        figendum tarball = downloadTarball(owner, repo, sha qua textus)

        si nihil tarball {
            si jsonOutput {
                results.push({
                    alias: alias,
                    status: "failed",
                    sha: sha qua textus,
                    error: "Failed to download tarball"
                } innatum tabula<textus, textus>)
            } secus {
                mone "  Failed to download tarball"
            }
            failed = failed + 1
            perge
        }

        # Extract to cache
        si non jsonOutput {
            scribe "  Extracting to cache..."
        }

        tempta {
            cede extractToCache(tarball qua textus, owner, repo, sha qua textus)
        } cape err {
            si jsonOutput {
                results.push({
                    alias: alias,
                    status: "failed",
                    sha: sha qua textus,
                    error: scriptum("Failed to extract: §", err)
                } innatum tabula<textus, textus>)
            } secus {
                mone "  Failed to extract: §", err
            }
            failed = failed + 1
            perge
        }

        # Clean up tarball
        tempta {
            cede solum.dele(tarball qua textus)
        } cape err {
            # Ignore cleanup errors
        }

        si jsonOutput {
            results.push({
                alias: alias,
                status: "fetched",
                sha: sha qua textus,
                path: cachePath(owner, repo, sha qua textus)
            } innatum tabula<textus, textus>)
        } secus {
            scribe "  Cached at §", cachePath(owner, repo, sha qua textus)
        }

        fetched = fetched + 1
    }

    # Summary
    si jsonOutput {
        consolum.fundeLineam(json.solve({
            fetched: fetched,
            skipped: skipped,
            failed: failed,
            results: results
        }))
    } secus {
        scribe ""
        scribe "Fetch complete: § fetched, § skipped, § failed", fetched, skipped, failed
    }

    redde failed > 0 sic 1 secus 0
}
