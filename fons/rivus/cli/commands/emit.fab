# ═══════════════════════════════════════════════════════════════════════════════
# EMIT - Compile single Faber source file to target language
# ═══════════════════════════════════════════════════════════════════════════════
#
# Full compilation pipeline: lex -> parse -> semantic -> codegen
# Outputs to stdout or file.
#
# Usage:
#   rivus emit hello.fab                 # emit to stdout (default: ts)
#   rivus emit hello.fab -t go           # emit as Go
#   rivus emit hello.fab -o hello.ts     # emit to file
#   rivus emit -                         # emit from stdin
#
# ═══════════════════════════════════════════════════════════════════════════════

ex "../../lexor/index" importa lexare
ex "../../parser/index" importa resolvere
ex "../../semantic/index" importa analyze
ex "../../codegen/index" importa generate
ex "../../ast/radix" importa Programma

ex "../../../norma/hal/solum" importa solum
ex "../../../norma/hal/consolum" importa consolum

ex "../auxilium" importa hauriSource, nomenOstende, validaInput

# ═══════════════════════════════════════════════════════════════════════════════
# EMIT COMMAND
# ═══════════════════════════════════════════════════════════════════════════════

@ publica
@ futura
functio emitCommand(
    textus input,
    si textus target,
    si textus output
) -> numerus {
    fixum targetLang = target vel "ts"
    fixum displayName = nomenOstende(input)

    # Validate input exists
    custodi {
        si non validaInput(input) {
            mone scriptum("File not found: §", input)
            redde 1
        }
    }

    fixum source = cede hauriSource(input)

    # Lexical analysis
    fixum lexResult = lexare(source)

    si positivum lexResult.errores.longitudo() {
        mone "Lexor errors:"
        ex lexResult.errores pro err {
            mone scriptum("  §:§:§ - §", displayName, err.locus.linea, err.locus.columna, err.textus)
        }
        redde 1
    }

    # Parsing
    fixum parseResult = resolvere(lexResult.symbola)

    si positivum parseResult.errores.longitudo() {
        mone "Parser errors:"
        ex parseResult.errores pro err {
            mone scriptum("  §:§:§ - §", displayName, err.locus.linea, err.locus.columna, err.nuntius)
        }
        redde 1
    }

    si nihil parseResult.programma {
        mone "Failed to parse program"
        redde 1
    }

    # Semantic analysis
    fixum viaIngressus = input != "-" sic solum.absolve(input) secus nihil
    fixum semResult = analyze(parseResult.programma qua Programma, viaIngressus)

    si positivum semResult.errores.longitudo() {
        mone "Semantic errors:"
        ex semResult.errores pro err {
            mone scriptum("  §:§:§ - §", displayName, err.locus.linea, err.locus.columna, err.nuntius)
        }
        redde 1
    }

    # Code generation
    fixum generated = generate((parseResult.programma qua Programma).corpus, targetLang)

    # Output
    si output {
        cede solum.scribe(output, generated)
        mone scriptum("Compiled: § -> §", displayName, output)
    }
    secus {
        consolum.fundeTextum(generated)
    }

    redde 0
}
