# ═══════════════════════════════════════════════════════════════════════════════
# EMIT - Compile single Faber source file to target language
# ═══════════════════════════════════════════════════════════════════════════════
#
# Full compilation pipeline: lex -> parse -> semantic -> codegen
# Outputs to stdout or file.
#
# Usage:
#   rivus emit hello.fab                 # emit to stdout (default: ts)
#   rivus emit hello.fab -t go           # emit as Go
#   rivus emit hello.fab -o hello.ts     # emit to file
#   rivus emit -                         # emit from stdin
#   rivus emit - --stdin-filename=foo.fab  # stdin with filename for errors
#   rivus emit hello.fab --dry-run       # check without emitting
#   rivus emit hello.fab --json          # errors as JSON
#
# ═══════════════════════════════════════════════════════════════════════════════

§ ex "../../lexor/index" importa lexare
§ ex "../../parser/index" importa resolvere
§ ex "../../semantic/index" importa analyze
§ ex "../../codegen/index" importa generate, generateStripTests
§ ex "../../ast/radix" importa Programma

§ ex "../../../norma/hal/solum" importa solum
§ ex "../../../norma/hal/consolum" importa consolum
§ ex "../../../norma/hal/json" importa json

§ ex "../auxilium" importa hauriSource, nomenOstende, validaInput

# ═══════════════════════════════════════════════════════════════════════════════
# EMIT COMMAND
# ═══════════════════════════════════════════════════════════════════════════════

@ publica
@ futura
functio emitCommand(
    textus input,
    si textus target,
    si textus output,
    si textus include,
    si textus stdinFilename,
    si bivalens jsonOutput,
    si bivalens dryRun,
    si bivalens stripTests
) -> numerus {
    fixum targetLang = target vel "ts"
    fixum displayName = stdinFilename vel nomenOstende(input)

    # Validate input exists
    custodi {
        si non validaInput(input) {
            si jsonOutput {
                consolum.fundeLineam(json.solve({ error: scriptum("File not found: §", input) }))
            }
            secus {
                mone "File not found: §", input
            }
            redde 1
        }
    }

    figendum source = hauriSource(input)

    # Collect errors for potential JSON output
    varia lista<tabula<textus, ignotum>> errores = [] innatum lista<tabula<textus, ignotum>>

    # Lexical analysis
    fixum lexResult = lexare(source)

    si positivum lexResult.errores.longitudo() {
        si jsonOutput {
            ex lexResult.errores pro err {
                errores.push({
                    phase: "lexor",
                    file: displayName,
                    line: err.locus.linea,
                    column: err.locus.columna,
                    message: err.textus
                } innatum tabula<textus, ignotum>)
            }
        }
        secus {
            mone "Lexor errors:"
            ex lexResult.errores pro err {
                mone "  §:§:§ - §", displayName, err.locus.linea, err.locus.columna, err.textus
            }
        }
        si jsonOutput {
            consolum.fundeLineam(json.solve({ errors: errores }))
        }
        redde 1
    }

    # Parsing
    fixum parseResult = resolvere(lexResult.symbola)

    si positivum parseResult.errores.longitudo() {
        si jsonOutput {
            ex parseResult.errores pro err {
                errores.push({
                    phase: "parser",
                    file: displayName,
                    line: err.locus.linea,
                    column: err.locus.columna,
                    message: err.nuntius
                } innatum tabula<textus, ignotum>)
            }
        }
        secus {
            mone "Parser errors:"
            ex parseResult.errores pro err {
                mone "  §:§:§ - §", displayName, err.locus.linea, err.locus.columna, err.nuntius
            }
        }
        si jsonOutput {
            consolum.fundeLineam(json.solve({ errors: errores }))
        }
        redde 1
    }

    si nihil parseResult.programma {
        si jsonOutput {
            consolum.fundeLineam(json.solve({ error: "Failed to parse program" }))
        }
        secus {
            mone "Failed to parse program"
        }
        redde 1
    }

    # Semantic analysis
    fixum viaIngressus = input != "-" sic solum.absolve(input) secus nihil
    fixum semResult = analyze(parseResult.programma qua Programma, viaIngressus)

    si positivum semResult.errores.longitudo() {
        si jsonOutput {
            ex semResult.errores pro err {
                errores.push({
                    phase: "semantic",
                    file: displayName,
                    line: err.locus.linea,
                    column: err.locus.columna,
                    message: err.nuntius
                } innatum tabula<textus, ignotum>)
            }
            consolum.fundeLineam(json.solve({ errors: errores }))
        }
        secus {
            mone "Semantic errors:"
            ex semResult.errores pro err {
                mone "  §:§:§ - §", displayName, err.locus.linea, err.locus.columna, err.nuntius
            }
        }
        redde 1
    }

    # Dry run stops here
    si dryRun {
        si jsonOutput {
            consolum.fundeLineam(json.solve({ success: verum, file: displayName }))
        }
        secus {
            scribe "§: OK", displayName
        }
        redde 0
    }

    # Code generation
    varia generated = ""
    si stripTests {
        generated = generateStripTests((parseResult.programma qua Programma).corpus, targetLang)
    } secus {
        generated = generate((parseResult.programma qua Programma).corpus, targetLang)
    }

    # Output
    si output {
        cede solum.scribe(output, generated)
        si non jsonOutput {
            mone "Compiled: § -> §", displayName, output
        }
    }
    secus {
        consolum.fundeTextum(generated)
    }

    redde 0
}
