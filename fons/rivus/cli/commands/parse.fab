# ═══════════════════════════════════════════════════════════════════════════════
# PARSE - Lex and parse Faber source, dump AST
# ═══════════════════════════════════════════════════════════════════════════════
#
# Runs lexer and parser only, outputs AST as JSON.
# Useful for tooling, debugging, and compiler development.
#
# Usage:
#   rivus parse hello.fab                # dump AST to stdout
#   rivus parse hello.fab -o ast.json    # dump to file
#   rivus parse -                        # parse from stdin
#
# ═══════════════════════════════════════════════════════════════════════════════

ex "../../lexor/index" importa lexare
ex "../../parser/index" importa resolvere
ex "../../ast/radix" importa Programma

ex "../../../norma/hal/solum" importa solum
ex "../../../norma/hal/consolum" importa consolum
ex "../../../norma/hal/json" importa json

# ═══════════════════════════════════════════════════════════════════════════════
# INPUT HANDLING
# ═══════════════════════════════════════════════════════════════════════════════

@ futura
functio readSource(textus inputFile) -> textus {
    si inputFile == "-" {
        varia lista<textus> lines = [] innatum lista<textus>
        varia textus line = consolum.hauriLineam()
        dum line != nihil {
            lines.push(line)
            line = consolum.hauriLineam()
        }
        redde lines.join("\n")
    }
    redde cede solum.lege(inputFile)
}

functio getDisplayName(textus inputFile) -> textus {
    redde inputFile == "-" sic "<stdin>" secus inputFile
}

# ═══════════════════════════════════════════════════════════════════════════════
# PARSE COMMAND
# ═══════════════════════════════════════════════════════════════════════════════

@ publica
@ futura
functio parseCommand(
    textus input,
    si textus output
) -> numerus {
    fixum displayName = getDisplayName(input)

    # Read source
    fixum source = cede readSource(input)

    # Lexical analysis
    fixum lexResult = lexare(source)

    si lexResult.errores.longitudo() > 0 {
        mone "Lexor errors:"
        ex lexResult.errores pro err {
            mone scriptum("  §:§:§ - §", displayName, err.locus.linea, err.locus.columna, err.textus)
        }
        redde 1
    }

    # Parsing
    fixum parseResult = resolvere(lexResult.symbola)

    si parseResult.errores.longitudo() > 0 {
        mone "Parser errors:"
        ex parseResult.errores pro err {
            mone scriptum("  §:§:§ - §", displayName, err.locus.linea, err.locus.columna, err.nuntius)
        }
        redde 1
    }

    si parseResult.programma est nihil {
        mone "Failed to parse program"
        redde 1
    }

    # Dump AST as JSON
    fixum astJson = json.solvePulchre(parseResult.programma, 2)

    si output {
        cede solum.scribe(output, astJson)
        mone scriptum("AST written to §", output)
    }
    secus {
        consolum.fundeLineam(astJson)
    }

    redde 0
}
