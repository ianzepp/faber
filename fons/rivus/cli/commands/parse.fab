# ═══════════════════════════════════════════════════════════════════════════════
# PARSE - Lex and parse Faber source, dump AST
# ═══════════════════════════════════════════════════════════════════════════════
#
# Runs lexer and parser only, outputs AST as JSON.
# Useful for tooling, debugging, and compiler development.
#
# Usage:
#   rivus parse hello.fab                # dump AST to stdout
#   rivus parse hello.fab -o ast.json    # dump to file
#   rivus parse -                        # parse from stdin
#   rivus parse - --stdin-filename=foo.fab  # stdin with filename for errors
#   rivus parse hello.fab --compact      # minified JSON output
#
# ═══════════════════════════════════════════════════════════════════════════════

ex "../../lexor/index" importa lexare
ex "../../parser/index" importa resolvere

ex "../../../norma/hal/solum" importa solum
ex "../../../norma/hal/consolum" importa consolum
ex "../../../norma/hal/json" importa json

ex "../auxilium" importa hauriSource, nomenOstende, validaInput

# ═══════════════════════════════════════════════════════════════════════════════
# PARSE COMMAND
# ═══════════════════════════════════════════════════════════════════════════════

@ publica
@ futura
functio parseCommand(
    textus input,
    si textus output,
    si textus stdinFilename,
    si bivalens compact
) -> numerus {
    fixum displayName = stdinFilename vel nomenOstende(input)

    # Validate input exists
    custodi {
        si non validaInput(input) {
            mone scriptum("File not found: §", input)
            redde 1
        }
    }

    fixum source = cede hauriSource(input)

    # Lexical analysis
    fixum lexResult = lexare(source)

    si positivum lexResult.errores.longitudo() {
        mone "Lexor errors:"
        ex lexResult.errores pro err {
            mone scriptum("  §:§:§ - §", displayName, err.locus.linea, err.locus.columna, err.textus)
        }
        redde 1
    }

    # Parsing
    fixum parseResult = resolvere(lexResult.symbola)

    si positivum parseResult.errores.longitudo() {
        mone "Parser errors:"
        ex parseResult.errores pro err {
            mone scriptum("  §:§:§ - §", displayName, err.locus.linea, err.locus.columna, err.nuntius)
        }
        redde 1
    }

    si nihil parseResult.programma {
        mone "Failed to parse program"
        redde 1
    }

    # Output AST as JSON
    fixum astJson = compact sic json.solve(parseResult.programma) secus json.solvePulchre(parseResult.programma, 2)

    si output {
        cede solum.scribe(output, astJson)
        mone scriptum("AST written to §", output)
    }
    secus {
        consolum.fundeLineam(astJson)
    }

    redde 0
}
