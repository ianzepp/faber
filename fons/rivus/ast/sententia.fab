# Statement AST - All statement types as a unified discretio
#
# WHY: Single file defines all statement variants for pattern matching.
#      Parsers construct variants with `finge VariantName { ... } qua Sententia`.

importa ex "./positio" privata Locus
importa ex "./typus" privata TypusAnnotatio
importa ex "./expressia" privata Expressia
importa ex "./annotatio" privata Annotatio

# ============================================================================
# SUPPORTING ENUMS
# ============================================================================

# Variable declaration kind
@ publica
ordo VariaGenus {
    Varia       # mutable: let
    Fixum       # immutable: const
    Figendum    # immutable async: const x = await ...
    Variandum   # mutable async: let x = await ...
}

# Visibility level for members
@ publica
ordo Visibilitas {
    Publica       # public (default)
    Protecta      # protected
    Privata       # private
}

# Return type verb
@ publica
ordo ReddeVerbum {
    Sagitta       # -> (arrow)
    Fit           # sync single
    Fiet          # async single
    Fiunt         # sync generator
    Fient         # async generator
}

# Output level for scribe/vide/mone
@ publica
ordo ScribeGradus {
    Scribe     # console.log
    Vide       # console.debug
    Mone       # console.warn
}

# Iteration kind
@ publica
ordo IteratioGenus {
    Ex      # iterate values (for...of)
    De      # iterate keys (for...in)
    Pro     # iterate range (for i = 0; i < n; i++)
}

# Curator kind for cura statements
@ publica
ordo CuratorGenus {
    Arena      # arena allocator
    Pagina     # page allocator
}

# Ad binding verb
@ publica
ordo AdVerbumVinculandi {
    Fit        # sync single
    Fiet       # async single
    Fiunt      # sync plural
    Fient      # async plural
}

# Praepara/postpara timing
@ publica
ordo PraeparaTempus {
    Praepara    # before (setup)
    Postpara    # after (teardown)
}

# Proba modifier
@ publica
ordo ProbaModificator {
    Omitte     # skip
    Futurum    # todo
}

# ============================================================================
# SUPPORTING GENUS TYPES
# ============================================================================

# Import specifier with optional alias
# Example: scribe, scribe ut s
@ publica
genus ImportaSpecificator {
    Locus locus
    textus importatum         # imported name
    textus locale             # local binding name
    bivalens residuum         # true for ceteri (rest)
}

# Array destructuring element
# Example: a, ceteri rest, _
@ publica
genus SeriesDestructuraElementum {
    Locus locus
    si textus nomen             # binding name (nil for omitted)
    bivalens residuum         # true for ceteri (rest)
    bivalens omissum          # true for placeholder _
}

# Loop variable binding (simple identifier or array pattern)
# Example: item, [key, value]
@ publica
discretio IteratioVariabilis {
    Nomen { textus valor }
    Series { lista<SeriesDestructuraElementum> elementa }
}

# Function parameter
# Example: textus nomen, de lista<T> items, ceteri args
@ publica
genus Parametrum {
    Locus locus
    textus nomen
    si textus alias             # ut alias
    si TypusAnnotatio typus
    si Expressia praedefinitum  # vel default
    si textus praepositio       # de, in, ex
    bivalens optionalis       # si (optional parameter)
    bivalens residuum         # ceteri (rest)
}

# Morphologia annotation metadata
@ publica
genus MorphologiaDeclaratio {
    Locus locus
    lista<textus> formae
}

# Compile-time type parameter
# Example: prae typus T
@ publica
genus TypusParametrum {
    Locus locus
    textus nomen
}

# Function modifier (post-parameter)
@ publica
discretio FunctioModificator {
    CurataModificator {
        Locus locus
        textus nomen
    }
    ErrataModificator {
        Locus locus
        textus nomen
    }
    ExitusModificator {
        Locus locus
        textus nomen    # Exit code variable name (e.g., "code")
    }
    ImmutataModificator {
        Locus locus
    }
    IacitModificator {
        Locus locus
    }
    OptionesModificator {
        Locus locus
        textus nomen    # Bundle variable name (e.g., "opts")
    }
}

# Field declaration within genus
# Example: textus nomen, privatus numerus aetas: 0
@ publica
genus CampusDeclaratio {
    Locus locus
    textus nomen
    TypusAnnotatio typus
    si Expressia valor          # default value
    Visibilitas visibilitas
    bivalens staticum         # generis (static)
}

# Pactum method signature (interface method)
@ publica
genus PactumMethodus {
    Locus locus
    textus nomen
    lista<Parametrum> parametra
    si TypusAnnotatio typusReditus
    bivalens asynca
    bivalens generator
    lista<FunctioModificator> modificatores
    si MorphologiaDeclaratio morphologia
}

# Ordo (enum) member
# Example: Rubrum, Actum = 1, Septentrio = "north"
@ publica
genus OrdoMembrum {
    Locus locus
    textus nomen
    si textus valor             # optional explicit value
}

# Variant field in discretio
# Example: numerus x, textus key
@ publica
genus VariansCampus {
    Locus locus
    textus nomen
    TypusAnnotatio typus
}

# Variant declaration within discretio
# Example: Click { numerus x, numerus y }, Quit
@ publica
genus VariansDeclaratio {
    Locus locus
    textus nomen
    lista<VariansCampus> campi   # empty for unit variants
}

# Elige (switch) case
@ publica
genus EligeCasus {
    Locus locus
    Expressia condicio
    Sententia consequens         # MassaSententia
}

# Single pattern in a variant case (matches one discriminant)
# Example: Primitivum ut p, Click pro x, y, _, Quit
@ publica
genus VariansExemplar {
    Locus locus
    textus variansNomen          # variant tag or "_" for wildcard
    bivalens estWildcard         # true for _ patterns
    si textus alias                # 'ut' binds entire variant
    lista<textus> vincula        # field bindings from 'pro'
}

# Variant case for discerne (pattern matching)
# Example: casu Click pro x, y { ... }
# Example: casu Primitivum ut l, Primitivum ut r { ... }  (multi-discriminant)
@ publica
genus VariansCasus {
    Locus locus
    lista<VariansExemplar> exemplaria  # patterns (one per discriminant)
    Sententia consequens               # MassaSententia
}

# Guard clause
# Example: si nihil x { redde nihil }
@ publica
genus CustodiClausula {
    Locus locus
    Expressia condicio
    Sententia consequens         # MassaSententia
}

# Catch clause
# Example: cape err { handleError(err) }
@ publica
genus CapeClausula {
    Locus locus
    textus param
    Sententia corpus             # MassaSententia
}

# Ad binding clause
# Example: fit textus pro content
@ publica
genus AdVinculum {
    Locus locus
    AdVerbumVinculandi verbum
    si TypusAnnotatio typus
    textus nomen
    si textus alias
}

# ============================================================================
# SENTENTIA DISCRETIO
# ============================================================================

# OPTIONAL FIELDS
# - Semantically optional: valid syntax can omit the value (e.g., redde, default casus).
# - Structurally optional: only present for some grammatical forms (e.g., incipit ergo).
# WHY: We encode both with `?`; each field documents which case applies.

# All statement types as a tagged union
#
# Each variant contains its fields directly. Use `finge` to construct:
#   finge MassaSententia { locus: loc, corpus: stmts } qua Sententia
#   finge VariaSententia { ... } qua Sententia
@ publica
discretio Sententia {
    # -------------------------------------------------------------------------
    # Block
    # -------------------------------------------------------------------------

    # Block of statements (sequence in braces)
    MassaSententia {
        Locus locus
        lista<Sententia> corpus
    }

    # -------------------------------------------------------------------------
    # Variable Declarations
    # -------------------------------------------------------------------------

    # Variable declaration
    # Examples: varia x = 5, fixum nomen = "Marcus"
    # @ externa marks external declarations (no initializer required)
    VariaSententia {
        Locus locus
        VariaGenus species
        textus nomen
        si TypusAnnotatio typus      # WHY: optional type annotation
        si Expressia valor           # WHY: optional initializer
        bivalens externa        # @ externa annotation
        si Visibilitas visibilitas  # @ publica annotation for module-level export
    }

    # Import declaration (single import per statement)
    # Example: importa ex "path" privata T
    # Example: importa ex "path" publica T ut alias
    # Example: importa ex "path" privata * ut namespace
    ImportaSententia {
        Locus locus
        textus fons              # source path/module
        si textus importatum       # original name (nil for wildcard *)
        textus locale            # local binding name
        bivalens totum           # true for wildcard *
        bivalens publica         # true for re-export (publica), false for private import
    }

    # Destructure declaration
    # Example: ex persona fixum nomen, aetas
    DestructuraSententia {
        Locus locus
        Expressia fons           # source expression
        VariaGenus species
        lista<ImportaSpecificator> specificatores
    }

    # Array destructure declaration
    # Example: fixum [a, b, c] = coords
    SeriesDestructuraSententia {
        Locus locus
        VariaGenus species
        lista<SeriesDestructuraElementum> elementa
        Expressia fons
    }

    # -------------------------------------------------------------------------
    # Function Declaration
    # -------------------------------------------------------------------------

    # Function declaration
    # Example: functio salve(textus nomen) -> textus { ... }
    # Example: functio alloc(textus s) curata alloc -> T { ... }
    # @ externa marks external declarations (no body required)
    FunctioDeclaratio {
        Locus locus
        textus nomen
        lista<TypusParametrum> generaParametra    # generic parameters (empty if none)
        lista<Parametrum> parametra
        si TypusAnnotatio typusReditus            # WHY: optional return type annotation
        si MassaSententia corpus   # WHY: optional for @ externa declarations
        bivalens asynca
        bivalens generator
        bivalens abstracta
        bivalens structor       # WHY: "constructor" is a JS reserved word
        bivalens externa        # @ externa annotation
        si Visibilitas visibilitas
        si ReddeVerbum reddeVerbum
        si MorphologiaDeclaratio morphologia      # WHY: optional method morphology
        lista<FunctioModificator> modificatores   # modifiers list (empty if none)
        lista<Annotatio> annotationes             # CLI annotations (empty if none)
    }

    # -------------------------------------------------------------------------
    # Type Declarations
    # -------------------------------------------------------------------------

    # Genus (struct/class) declaration
    # Example: genus Persona { textus nomen }
    GenusDeclaratio {
        Locus locus
        textus nomen
        lista<textus> generaParametra  # generic parameters (empty if none)
        si textus extendit         # WHY: optional sub Parent
        lista<textus> implet       # implet Interface list (empty if none)
        bivalens abstractum
        lista<CampusDeclaratio> campi
        si FunctioDeclaratio structor   # WHY: optional constructor
        lista<FunctioDeclaratio> methodi
        si MorphologiaDeclaratio morphologia      # WHY: optional genus morphology
        si Visibilitas visibilitas  # @ publica annotation for module-level export
    }

    # Pactum (interface) declaration
    # Example: pactum Iterabilis { functio sequens() -> si T }
    PactumDeclaratio {
        Locus locus
        textus nomen
        lista<textus> generaParametra  # generic parameters (empty if none)
        lista<PactumMethodus> methodi
        si Visibilitas visibilitas  # @ publica annotation for module-level export
    }

    # Type alias declaration
    # Example: typus ID = textus
    TypusAliasDeclaratio {
        Locus locus
        textus nomen
        TypusAnnotatio typus
        si textus scopusNomen      # WHY: optional typeof scope
        si Visibilitas visibilitas  # @ publica annotation for module-level export
    }

    # Ordo (enum) declaration
    # Example: ordo Color { Rubrum, Viridis, Caeruleum }
    OrdoDeclaratio {
        Locus locus
        textus nomen
        lista<OrdoMembrum> membra
        si Visibilitas visibilitas  # @ publica annotation for module-level export
    }

    # Discretio (tagged union) declaration
    # Example: discretio Event { Click { numerus x }, Quit }
    DiscretioDeclaratio {
        Locus locus
        textus nomen
        lista<textus> generaParametra  # generic parameters (empty if none)
        lista<VariansDeclaratio> variantes
        si Visibilitas visibilitas  # @ publica annotation for module-level export
    }

    # -------------------------------------------------------------------------
    # Control Flow
    # -------------------------------------------------------------------------

    # Conditional statement
    # Example: si x > 0 { ... } secus { ... }
    SiSententia {
        Locus locus
        Expressia condicio
        Sententia consequens     # MassaSententia
        si Sententia alternans     # MassaSententia or SiSententia
        si CapeClausula cape
    }

    # While loop
    # Example: dum x > 0 { ... }
    DumSententia {
        Locus locus
        Expressia condicio
        Sententia corpus         # MassaSententia
        si CapeClausula cape
    }

    # For loop (iteration)
    # Example: ex items fixum item { ... }
    # Example: ex map fixum [key, value] { ... }
    IteratioSententia {
        Locus locus
        IteratioGenus species
        IteratioVariabilis variabilis
        Expressia iterabile
        Sententia corpus         # MassaSententia
        bivalens asynca
        bivalens mutabilis       # varia = mutable, fixum = immutable
        si CapeClausula cape
    }

    # Switch statement
    # Example: elige status { si "pending" { ... } }
    EligeSententia {
        Locus locus
        Expressia discriminans
        lista<EligeCasus> casus
        si MassaSententia praedefinitum # WHY: optional default casus
        si CapeClausula cape
    }

    # Pattern matching statement
    # Example: discerne event { casu Click pro x, y { ... } }
    # Example: discerne a, b { casu X ut x, Y ut y { ... } }  (multi-discriminant)
    DiscerneSententia {
        Locus locus
        lista<Expressia> discriminantes   # one or more expressions to match against
        bivalens exhaustiva              # opt-in exhaustiveness ("discerne omnia")
        lista<VariansCasus> casus
    }

    # Guard statement
    # Example: custodi { si nihil x { redde nihil } }
    CustodiSententia {
        Locus locus
        lista<CustodiClausula> clausulae
    }

    # -------------------------------------------------------------------------
    # Error Handling
    # -------------------------------------------------------------------------

    # Try-catch-finally
    # Example: tempta { ... } cape err { ... } demum { ... }
    TemptaSententia {
        Locus locus
        Sententia corpus         # MassaSententia
        si CapeClausula cape
        si MassaSententia demum    # WHY: optional finally block
    }

    # Throw statement
    # Example: iace "error", mori "fatal"
    IaceSententia {
        Locus locus
        bivalens fatale          # mori vs iace
        Expressia argumentum
    }

    # Explicit scope block (or do-while)
    # Example: fac { ... } or fac { ... } dum condition
    FacSententia {
        Locus locus
        Sententia corpus         # MassaSententia
        si CapeClausula cape
        si Expressia condicio      # WHY: optional do-while condition
    }

    # Assert statement
    # Example: adfirma x > 0, "x must be positive"
    AdfirmaSententia {
        Locus locus
        Expressia condicio
        si Expressia nuntius       # WHY: optional message
    }

    # -------------------------------------------------------------------------
    # Actions
    # -------------------------------------------------------------------------

    # Print statement
    # Example: scribe "hello", vide value, mone "warning"
    ScribeSententia {
        Locus locus
        ScribeGradus gradus
        lista<Expressia> argumenta
    }

    # Return statement
    # Example: redde 42, redde
    ReddeSententia {
        Locus locus
        si Expressia valor         # WHY: optional redde value
    }

    # Break statement
    # Example: rumpe
    RumpeSententia {
        Locus locus
    }

    # Continue statement
    # Example: perge
    PergeSententia {
        Locus locus
    }

    # No-op statement (explicit empty block)
    # Example: si debug tacet secus { ... }
    TacetSententia {
        Locus locus
    }

    # Expression statement (expression used as statement)
    ExpressiaSententia {
        Locus locus
        Expressia expressia
    }

    # Entry point (sync)
    # Example: incipit { scribe "Hello" }
    # Example: incipit argumenta args { ... }
    IncipitSententia {
        Locus locus
        si MassaSententia corpus   # WHY: optional incipit body
        si Sententia ergo          # WHY: optional incipit ergo clause
        lista<Annotatio> annotationes     # CLI annotations (empty if none)
        si textus argumenta        # WHY: binding name for collected @ optio/@ operandus
    }

    # Entry point (async)
    # Example: incipiet { cede fetch() }
    # Example: incipiet argumenta args { ... }
    IncipietSententia {
        Locus locus
        si MassaSententia corpus   # WHY: optional incipiet body
        si Sententia ergo          # WHY: optional incipiet ergo clause
        lista<Annotatio> annotationes     # CLI annotations (empty if none)
        si textus argumenta        # WHY: binding name for collected @ optio/@ operandus
    }

    # Resource management statement
    # Example: cura arena fixum mem { ... }
    CuraSententia {
        Locus locus
        si CuratorGenus curatorSpecies # WHY: optional when `res` provides curator
        si Expressia res           # WHY: optional for bare curator form
        textus vinculum          # binding name
        si TypusAnnotatio typus
        bivalens asynca
        bivalens mutabilis       # varia = mutable, fixum = immutable
        Sententia corpus         # MassaSententia
        si CapeClausula cape
    }

    # Dispatch statement
    # Example: ad "fasciculus:lege" ("file.txt") -> textus pro content { ... }
    AdSententia {
        Locus locus
        textus scopus            # target string
        lista<Expressia> argumenta
        si AdVinculum vinculum
        si MassaSententia corpus   # WHY: optional handler body
        si CapeClausula cape
    }

    # -------------------------------------------------------------------------
    # Tests
    # -------------------------------------------------------------------------

    # Test suite
    # Example: probandum "Tokenizer" { proba "..." { } }
    #
    # Suite-level annotations:
    #   @ omitte "reason"     - Skip entire suite
    #   @ solum               - Only run this suite
    #   @ tag "name"          - Tag for filtering
    ProbandumSententia {
        Locus locus
        textus nomen
        si bivalens ompitur            # @ omitte - skip entire suite
        si textus ratioOmissionis      # reason for skip
        si bivalens solum              # @ solum - only run this suite
        lista<textus> tags             # @ tag - filtering tags (empty if none)
        lista<Sententia> corpus      # PraeparaMassa, ProbandumSententia, ProbaSententia
    }

    # Test case
    # Example: proba "parses integers" { adfirma ... }
    #
    # Annotations control test execution:
    #   @ omitte "reason"     - Skip test with reason
    #   @ futurum "reason"    - Mark as todo/pending
    #   @ solum               - Only run this test (exclusive)
    #   @ tag "name"          - Tag for filtering (can repeat)
    #   @ temporis 5000       - Timeout in milliseconds
    #   @ metior              - Benchmark mode
    #   @ repete 100          - Repeat test N times
    #   @ fragilis 3          - Retry flaky test N times
    #   @ requirit "ENV_VAR"  - Skip if env var missing
    #   @ solum_in "darwin"   - Only run on platform
    ProbaSententia {
        Locus locus
        textus nomen
        si ProbaModificator modificator
        si textus ratioModificatoris   # reason for skip/todo
        si bivalens solum              # @ solum - only run this test
        lista<textus> tags             # @ tag - filtering tags (empty if none)
        si numerus temporis            # @ temporis - timeout in ms
        si bivalens metior             # @ metior - benchmark mode
        si numerus repete              # @ repete - repeat count
        si numerus fragilis            # @ fragilis - retry count
        si textus requirit             # @ requirit - required env var
        si textus solumIn              # @ solum_in - platform filter
        Sententia corpus             # MassaSententia
    }

    # Test setup/teardown block
    # Example: praepara { lexer = init() }
    PraeparaMassa {
        Locus locus
        PraeparaTempus tempus
        bivalens asynca
        bivalens omnia
        Sententia corpus         # MassaSententia
    }
}
