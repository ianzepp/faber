# Statement AST - All statement types as a unified discretio
#
# WHY: Single file defines all statement variants for pattern matching.
#      Parsers construct variants with `finge VariantName { ... } qua Sententia`.

ยง ex "./positio" importa Locus
ยง ex "./typus" importa TypusAnnotatio
ยง ex "./expressia" importa Expressia

# ============================================================================
# SUPPORTING ENUMS
# ============================================================================

# Variable declaration kind
@ publicum
ordo VariaGenus {
    Varia       # mutable: let
    Fixum       # immutable: const
    Figendum    # immutable async: const x = await ...
    Variandum   # mutable async: let x = await ...
}

# Visibility level for members
@ publicum
ordo Visibilitas {
    Publica       # public (default)
    Protecta      # protected
    Privata       # private
}

# Return type verb
@ publicum
ordo ReddeVerbum {
    Sagitta       # -> (arrow)
    Fit           # sync single
    Fiet          # async single
    Fiunt         # sync generator
    Fient         # async generator
}

# Output level for scribe/vide/mone
@ publicum
ordo ScribeGradus {
    Scribe     # console.log
    Vide       # console.debug
    Mone       # console.warn
}

# Iteration kind
@ publicum
ordo IteratioGenus {
    Ex      # iterate values (for...of)
    De      # iterate keys (for...in)
}

# Curator kind for cura statements
@ publicum
ordo CuratorGenus {
    Arena      # arena allocator
    Pagina     # page allocator
}

# Ad binding verb
@ publicum
ordo AdVerbumVinculandi {
    Fit        # sync single
    Fiet       # async single
    Fiunt      # sync plural
    Fient      # async plural
}

# Praepara/postpara timing
@ publicum
ordo PraeparaTempus {
    Praepara    # before (setup)
    Postpara    # after (teardown)
}

# Proba modifier
@ publicum
ordo ProbaModificator {
    Omitte     # skip
    Futurum    # todo
}

# ============================================================================
# SUPPORTING GENUS TYPES
# ============================================================================

# Import specifier with optional alias
# Example: scribe, scribe ut s
@ publicum
genus ImportaSpecificator {
    Locus locus
    textus importatum         # imported name
    textus locale             # local binding name
    bivalens residuum         # true for ceteri (rest)
}

# Array destructuring element
# Example: a, ceteri rest, _
@ publicum
genus SeriesDestructuraElementum {
    Locus locus
    textus? nomen             # binding name (nil for omitted)
    bivalens residuum         # true for ceteri (rest)
    bivalens omissum          # true for placeholder _
}

# Function parameter
# Example: textus nomen, de lista<T> items, ceteri args
@ publicum
genus Parametrum {
    Locus locus
    textus nomen
    textus? alias             # ut alias
    TypusAnnotatio? typus
    Expressia? praedefinitum  # vel default
    textus? praepositio       # de, in, ex
    bivalens optionalis       # si (optional parameter)
    bivalens residuum         # ceteri (rest)
}

# Morphologia annotation metadata
@ publicum
genus MorphologiaDeclaratio {
    Locus locus
    lista<textus> formae
}

# Compile-time type parameter
# Example: prae typus T
@ publicum
genus TypusParametrum {
    Locus locus
    textus nomen
}

# Function modifier (post-parameter)
@ publicum
discretio FunctioModificator {
    CurataModificator {
        Locus locus
        textus nomen
    }
    ErrataModificator {
        Locus locus
        textus nomen
    }
    ImmutataModificator {
        Locus locus
    }
    IacitModificator {
        Locus locus
    }
}

# Field declaration within genus
# Example: textus nomen, privatus numerus aetas: 0
@ publicum
genus CampusDeclaratio {
    Locus locus
    textus nomen
    TypusAnnotatio typus
    Expressia? valor          # default value
    Visibilitas visibilitas
    bivalens staticum         # generis (static)
}

# Pactum method signature (interface method)
@ publicum
genus PactumMethodus {
    Locus locus
    textus nomen
    lista<Parametrum> parametra
    TypusAnnotatio? typusReditus
    bivalens asynca
    bivalens generator
    lista<FunctioModificator>? modificatores
    MorphologiaDeclaratio? morphologia
}

# Ordo (enum) member
# Example: Rubrum, Actum = 1, Septentrio = "north"
@ publicum
genus OrdoMembrum {
    Locus locus
    textus nomen
    textus? valor             # optional explicit value
}

# Variant field in discretio
# Example: numerus x, textus key
@ publicum
genus VariansCampus {
    Locus locus
    textus nomen
    TypusAnnotatio typus
}

# Variant declaration within discretio
# Example: Click { numerus x, numerus y }, Quit
@ publicum
genus VariansDeclaratio {
    Locus locus
    textus nomen
    lista<VariansCampus> campi   # empty for unit variants
}

# Elige (switch) case
@ publicum
genus EligeCasus {
    Locus locus
    Expressia condicio
    Sententia consequens         # MassaSententia
}

# Single pattern in a variant case (matches one discriminant)
# Example: Primitivum ut p, Click pro x, y, _, Quit
@ publicum
genus VariansExemplar {
    Locus locus
    textus variansNomen          # variant tag or "_" for wildcard
    bivalens estWildcard         # true for _ patterns
    textus? alias                # 'ut' binds entire variant
    lista<textus> vincula        # field bindings from 'pro'
}

# Variant case for discerne (pattern matching)
# Example: casu Click pro x, y { ... }
# Example: casu Primitivum ut l, Primitivum ut r { ... }  (multi-discriminant)
@ publicum
genus VariansCasus {
    Locus locus
    lista<VariansExemplar> exemplaria  # patterns (one per discriminant)
    Sententia consequens               # MassaSententia
}

# Guard clause
# Example: si nihil x { redde nihil }
@ publicum
genus CustodiClausula {
    Locus locus
    Expressia condicio
    Sententia consequens         # MassaSententia
}

# Catch clause
# Example: cape err { handleError(err) }
@ publicum
genus CapeClausula {
    Locus locus
    textus param
    Sententia corpus             # MassaSententia
}

# Ad binding clause
# Example: fit textus pro content
@ publicum
genus AdVinculum {
    Locus locus
    AdVerbumVinculandi verbum
    TypusAnnotatio? typus
    textus nomen
    textus? alias
}

# ============================================================================
# SENTENTIA DISCRETIO
# ============================================================================

# OPTIONAL FIELDS
# - Semantically optional: valid syntax can omit the value (e.g., redde, default casus).
# - Structurally optional: only present for some grammatical forms (e.g., incipit ergo).
# WHY: We encode both with `?`; each field documents which case applies.

# All statement types as a tagged union
#
# Each variant contains its fields directly. Use `finge` to construct:
#   finge MassaSententia { locus: loc, corpus: stmts } qua Sententia
#   finge VariaSententia { ... } qua Sententia
@ publicum
discretio Sententia {
    # -------------------------------------------------------------------------
    # Block
    # -------------------------------------------------------------------------

    # Block of statements (sequence in braces)
    MassaSententia {
        Locus locus
        lista<Sententia> corpus
    }

    # -------------------------------------------------------------------------
    # Variable Declarations
    # -------------------------------------------------------------------------

    # Variable declaration
    # Examples: varia x = 5, fixum nomen = "Marcus"
    # @ externa marks external declarations (no initializer required)
    VariaSententia {
        Locus locus
        VariaGenus species
        textus nomen
        TypusAnnotatio? typus      # WHY: optional type annotation
        Expressia? valor           # WHY: optional initializer
        bivalens externa        # @ externa annotation
        Visibilitas? visibilitas  # @ publica annotation for module-level export
    }

    # Import declaration
    # Example: ex norma importa scribe, lege
    ImportaSententia {
        Locus locus
        textus fons              # source path/module
        lista<ImportaSpecificator> specificatores
        bivalens totum           # true for wildcard *
        textus? totumAlias       # WHY: optional alias for * ut name
    }

    # Destructure declaration
    # Example: ex persona fixum nomen, aetas
    DestructuraSententia {
        Locus locus
        Expressia fons           # source expression
        VariaGenus species
        lista<ImportaSpecificator> specificatores
    }

    # Array destructure declaration
    # Example: fixum [a, b, c] = coords
    SeriesDestructuraSententia {
        Locus locus
        VariaGenus species
        lista<SeriesDestructuraElementum> elementa
        Expressia fons
    }

    # -------------------------------------------------------------------------
    # Function Declaration
    # -------------------------------------------------------------------------

    # Function declaration
    # Example: functio salve(textus nomen) -> textus { ... }
    # Example: functio alloc(textus s) curata alloc -> T { ... }
    # @ externa marks external declarations (no body required)
    FunctioDeclaratio {
        Locus locus
        textus nomen
        lista<TypusParametrum>? generaParametra # WHY: optional generics
        lista<Parametrum> parametra
        TypusAnnotatio? typusReditus            # WHY: optional return type annotation
        MassaSententia? corpus   # WHY: optional for @ externa declarations
        bivalens asynca
        bivalens generator
        bivalens abstracta
        bivalens structor       # WHY: "constructor" is a JS reserved word
        bivalens externa        # @ externa annotation
        Visibilitas? visibilitas
        ReddeVerbum? reddeVerbum
        MorphologiaDeclaratio? morphologia      # WHY: optional method morphology
        lista<FunctioModificator>? modificatores # WHY: optional modifiers list
    }

    # -------------------------------------------------------------------------
    # Type Declarations
    # -------------------------------------------------------------------------

    # Genus (struct/class) declaration
    # Example: genus Persona { textus nomen }
    GenusDeclaratio {
        Locus locus
        textus nomen
        lista<textus>? generaParametra # WHY: optional generics
        textus? extendit         # WHY: optional sub Parent
        lista<textus>? implet    # WHY: optional implet Interface list
        bivalens abstractum
        lista<CampusDeclaratio> campi
        FunctioDeclaratio? structor   # WHY: optional constructor
        lista<FunctioDeclaratio> methodi
        MorphologiaDeclaratio? morphologia      # WHY: optional genus morphology
        Visibilitas? visibilitas  # @ publica annotation for module-level export
    }

    # Pactum (interface) declaration
    # Example: pactum Iterabilis { functio sequens() -> T? }
    PactumDeclaratio {
        Locus locus
        textus nomen
        lista<textus>? generaParametra # WHY: optional generics
        lista<PactumMethodus> methodi
        Visibilitas? visibilitas  # @ publica annotation for module-level export
    }

    # Type alias declaration
    # Example: typus ID = textus
    TypusAliasDeclaratio {
        Locus locus
        textus nomen
        TypusAnnotatio typus
        textus? scopusNomen      # WHY: optional typeof scope
        Visibilitas? visibilitas  # @ publica annotation for module-level export
    }

    # Ordo (enum) declaration
    # Example: ordo Color { Rubrum, Viridis, Caeruleum }
    OrdoDeclaratio {
        Locus locus
        textus nomen
        lista<OrdoMembrum> membra
        Visibilitas? visibilitas  # @ publica annotation for module-level export
    }

    # Discretio (tagged union) declaration
    # Example: discretio Event { Click { numerus x }, Quit }
    DiscretioDeclaratio {
        Locus locus
        textus nomen
        lista<textus>? generaParametra # WHY: optional generics
        lista<VariansDeclaratio> variantes
        Visibilitas? visibilitas  # @ publica annotation for module-level export
    }

    # -------------------------------------------------------------------------
    # Control Flow
    # -------------------------------------------------------------------------

    # Conditional statement
    # Example: si x > 0 { ... } secus { ... }
    SiSententia {
        Locus locus
        Expressia condicio
        Sententia consequens     # MassaSententia
        Sententia? alternans     # MassaSententia or SiSententia
        CapeClausula? cape
    }

    # While loop
    # Example: dum x > 0 { ... }
    DumSententia {
        Locus locus
        Expressia condicio
        Sententia corpus         # MassaSententia
        CapeClausula? cape
    }

    # For loop (iteration)
    # Example: ex items pro item { ... }
    IteratioSententia {
        Locus locus
        IteratioGenus species
        textus variabilis
        Expressia iterabile
        Sententia corpus         # MassaSententia
        bivalens asynca
        CapeClausula? cape
    }

    # Switch statement
    # Example: elige status { si "pending" { ... } }
    EligeSententia {
        Locus locus
        Expressia discriminans
        lista<EligeCasus> casus
        MassaSententia? praedefinitum # WHY: optional default casus
        CapeClausula? cape
    }

    # Pattern matching statement
    # Example: discerne event { casu Click pro x, y { ... } }
    # Example: discerne a, b { casu X ut x, Y ut y { ... } }  (multi-discriminant)
    DiscerneSententia {
        Locus locus
        lista<Expressia> discriminantes   # one or more expressions to match against
        bivalens exhaustiva              # opt-in exhaustiveness ("discerne omnia")
        lista<VariansCasus> casus
    }

    # Guard statement
    # Example: custodi { si nihil x { redde nihil } }
    CustodiSententia {
        Locus locus
        lista<CustodiClausula> clausulae
    }

    # -------------------------------------------------------------------------
    # Error Handling
    # -------------------------------------------------------------------------

    # Try-catch-finally
    # Example: tempta { ... } cape err { ... } demum { ... }
    TemptaSententia {
        Locus locus
        Sententia corpus         # MassaSententia
        CapeClausula? cape
        MassaSententia? demum    # WHY: optional finally block
    }

    # Throw statement
    # Example: iace "error", mori "fatal"
    IaceSententia {
        Locus locus
        bivalens fatale          # mori vs iace
        Expressia argumentum
    }

    # Explicit scope block (or do-while)
    # Example: fac { ... } or fac { ... } dum condition
    FacSententia {
        Locus locus
        Sententia corpus         # MassaSententia
        CapeClausula? cape
        Expressia? condicio      # WHY: optional do-while condition
    }

    # Assert statement
    # Example: adfirma x > 0, "x must be positive"
    AdfirmaSententia {
        Locus locus
        Expressia condicio
        Expressia? nuntius       # WHY: optional message
    }

    # -------------------------------------------------------------------------
    # Actions
    # -------------------------------------------------------------------------

    # Print statement
    # Example: scribe "hello", vide value, mone "warning"
    ScribeSententia {
        Locus locus
        ScribeGradus gradus
        lista<Expressia> argumenta
    }

    # Return statement
    # Example: redde 42, redde
    ReddeSententia {
        Locus locus
        Expressia? valor         # WHY: optional redde value
    }

    # Break statement
    # Example: rumpe
    RumpeSententia {
        Locus locus
    }

    # Continue statement
    # Example: perge
    PergeSententia {
        Locus locus
    }

    # No-op statement (explicit empty block)
    # Example: si debug tacet secus { ... }
    TacetSententia {
        Locus locus
    }

    # Expression statement (expression used as statement)
    ExpressiaSententia {
        Locus locus
        Expressia expressia
    }

    # Entry point (sync)
    # Example: incipit { scribe "Hello" }
    IncipitSententia {
        Locus locus
        MassaSententia? corpus   # WHY: optional incipit body
        Sententia? ergo          # WHY: optional incipit ergo clause
    }

    # Entry point (async)
    # Example: incipiet { cede fetch() }
    IncipietSententia {
        Locus locus
        MassaSententia? corpus   # WHY: optional incipiet body
        Sententia? ergo          # WHY: optional incipiet ergo clause
    }

    # Resource management statement
    # Example: cura arena fit mem { ... }
    CuraSententia {
        Locus locus
        CuratorGenus? curatorSpecies # WHY: optional when `res` provides curator
        Expressia? res           # WHY: optional for bare curator form
        textus vinculum          # binding name
        TypusAnnotatio? typus
        bivalens asynca
        Sententia corpus         # MassaSententia
        CapeClausula? cape
    }

    # Dispatch statement
    # Example: ad "fasciculus:lege" ("file.txt") -> textus pro content { ... }
    AdSententia {
        Locus locus
        textus scopus            # target string
        lista<Expressia> argumenta
        AdVinculum? vinculum
        MassaSententia? corpus   # WHY: optional handler body
        CapeClausula? cape
    }

    # -------------------------------------------------------------------------
    # Tests
    # -------------------------------------------------------------------------

    # Test suite
    # Example: probandum "Tokenizer" { proba "..." { } }
    #
    # Suite-level annotations:
    #   @ omitte "reason"     - Skip entire suite
    #   @ solum               - Only run this suite
    #   @ tag "name"          - Tag for filtering
    ProbandumSententia {
        Locus locus
        textus nomen
        bivalens? ompitur            # @ omitte - skip entire suite
        textus? ratioOmissionis      # reason for skip
        bivalens? solum              # @ solum - only run this suite
        lista<textus>? tags          # @ tag - filtering tags
        lista<Sententia> corpus      # PraeparaMassa, ProbandumSententia, ProbaSententia
    }

    # Test case
    # Example: proba "parses integers" { adfirma ... }
    #
    # Annotations control test execution:
    #   @ omitte "reason"     - Skip test with reason
    #   @ futurum "reason"    - Mark as todo/pending
    #   @ solum               - Only run this test (exclusive)
    #   @ tag "name"          - Tag for filtering (can repeat)
    #   @ temporis 5000       - Timeout in milliseconds
    #   @ metior              - Benchmark mode
    #   @ repete 100          - Repeat test N times
    #   @ fragilis 3          - Retry flaky test N times
    #   @ requirit "ENV_VAR"  - Skip if env var missing
    #   @ solum_in "darwin"   - Only run on platform
    ProbaSententia {
        Locus locus
        textus nomen
        ProbaModificator? modificator
        textus? ratioModificatoris   # reason for skip/todo
        bivalens? solum              # @ solum - only run this test
        lista<textus>? tags          # @ tag - filtering tags
        numerus? temporis            # @ temporis - timeout in ms
        bivalens? metior             # @ metior - benchmark mode
        numerus? repete              # @ repete - repeat count
        numerus? fragilis            # @ fragilis - retry count
        textus? requirit             # @ requirit - required env var
        textus? solumIn              # @ solum_in - platform filter
        Sententia corpus             # MassaSententia
    }

    # Test setup/teardown block
    # Example: praepara { lexer = init() }
    PraeparaMassa {
        Locus locus
        PraeparaTempus tempus
        bivalens asynca
        bivalens omnia
        Sententia corpus         # MassaSententia
    }
}
