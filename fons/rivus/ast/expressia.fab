# Expression AST - All expression types as a unified discretio
#
# WHY: Single file defines all expression variants for pattern matching.
#      Parsers construct variants with `finge VariantName { ... } qua Expressia`.

ยง ex "./positio" importa Locus
ยง ex "./typus" importa TypusAnnotatio
ยง ex "./sententia" importa MassaSententia

# ============================================================================
# SUPPORTING TYPES
# ============================================================================

@ publica
# Clausura body: either an expression or a block
# WHY: Clausuras can be `clausura x: expr` or `clausura x { ... }`.
discretio ClausuraCorpus {
    Expr {
        Expressia valor
    }
    Massa {
        MassaSententia valor
    }
}

# Literal value type - what kind of constant this is
@ publica
ordo LitteraGenus {
    Numerus    # integer: 42
    Fractus    # float: 3.14
    Textus     # string: "hello"
    Exemplar   # template: `hello ${x}`
    Verum      # true
    Falsum     # false
    Nihil      # null
}

# Object property in object literal
# Example: name: "Alice", or shorthand: name
@ publica
genus ObiectumProprietas {
    Locus locus
    Expressia clavis         # key - usually Nomen or Littera
    Expressia valor
    bivalens brevitas        # true for { name } meaning { name: name }
    bivalens computatum      # true for { [expr]: value }
    bivalens dispersum       # true for { sparge expr }
}

# Clausura parameter (simplified vs full Parametrum)
# Example: clausura x, y: x + y
@ publica
genus ClausuraParametrum {
    Locus locus
    textus nomen
    si TypusAnnotatio typus
}

# Chain step for collection DSL
# Examples: prima 5, ultima 3, summa, ordina per nomen descendens
@ publica
genus CatenaGradus {
    Locus locus
    textus verbum            # prima, ultima, summa, ordina, collige, grupa, maximum, minimum, medium, numera
    si Expressia argumentum    # count for prima/ultima
    si Expressia proprietas    # property for ordina/collige/grupa/summa
    si textus directio         # "ascendens" | "descendens" for ordina
}

# Ab filter clause (ubi condition or boolean shorthand)
@ publica
genus AbFiltrum {
    Locus locus
    bivalens habetUbi        # true if 'ubi' form was used
    Expressia condicio
}

# Morphology dispatch info for method calls
@ publica
genus MorphologiaInvocatio {
    textus recipiens
    textus radix
    textus forma
}

# ============================================================================
# EXPRESSIA DISCRETIO
# ============================================================================

# OPTIONAL TYPES
# WHY: ignotum is reserved for pending union definitions (replace with unions).

# All expression types as a tagged union
#
# Each variant contains its fields directly. Use `finge` to construct:
#   finge Nomen { locus: loc, valor: "x" } qua Expressia
#   finge Littera { locus: loc, species: LitteraGenus.Numerus, crudus: "42" } qua Expressia
@ publica
discretio Expressia {
    # -------------------------------------------------------------------------
    # Identifiers
    # -------------------------------------------------------------------------

    # Simple identifier - a named reference
    # Example: x, nomen, calculateTotal
    Nomen {
        Locus locus
        textus valor
    }

    # Self-reference expression ('ego' in Faber, 'this' in JS, 'self' in Rust/Py)
    EgoExpressia {
        Locus locus
    }

    # -------------------------------------------------------------------------
    # Literals
    # -------------------------------------------------------------------------

    # Literal constant value
    # Examples: 42, 3.14, "hello", verum, falsum, nihil
    Littera {
        Locus locus
        LitteraGenus species
        textus crudus           # original source text
    }

    # Template literal with interpolations
    # Example: `Hello, ${name}!`
    LitteraExemplar {
        Locus locus
        lista<textus> partes       # static string parts
        lista<Expressia> expressiae    # interpolated expressions
    }

    # Regex literal
    # Example: sed "(?i)pattern" (inline flags)
    LitteraRegex {
        Locus locus
        textus forma         # pattern (may include inline flags like (?i))
        textus vexilla       # unused, kept for compatibility
    }

    # -------------------------------------------------------------------------
    # Binary and Unary Operations
    # -------------------------------------------------------------------------

    # Binary expression - two operands with an operator
    # Examples: a + b, x == y, foo && bar
    BinariaExpressia {
        Locus locus
        Expressia sinister       # left operand
        textus signum            # +, -, *, /, %, ==, !=, <, >, <=, >=, &&, ||, ??
        Expressia dexter         # right operand
    }

    # Unary expression - one operand with a prefix operator
    # Examples: -x, !flag, ~bits
    UnariaExpressia {
        Locus locus
        textus signum            # -, !, ~
        Expressia argumentum
    }

    # Assignment expression
    # Examples: x = 5, obj.prop = value
    AssignatioExpressia {
        Locus locus
        Expressia sinister       # must be assignable (identifier, member, etc.)
        textus signum            # =, +=, -=, *=, /=, etc.
        Expressia dexter
    }

    # Conditional (ternary) expression
    # Faber: condition sic consequent secus alternate
    # JS: condition ? consequent : alternate
    CondicioExpressia {
        Locus locus
        Expressia condicio
        Expressia consequens
        Expressia alternans
    }

    # Bit shift expression
    # Examples: x dextratum 3 -> x >> 3, x sinistratum 3 -> x << 3
    TranslatioExpressia {
        Locus locus
        Expressia expressia          # the value being shifted
        textus directio              # "dextratum" | "sinistratum"
        Expressia quantitas          # shift amount
    }

    # Range expression for slicing and iteration
    # Examples: 1..10 (exclusive), 1 usque 10 (inclusive)
    AmbitusExpressia {
        Locus locus
        Expressia initium
        Expressia finis
        si Expressia gradus
        bivalens inclusivum      # true for 'usque', false for '..'
    }

    # Type cast expression
    # Example: value qua numerus
    QuaExpressia {
        Locus locus
        Expressia expressia
        TypusAnnotatio scopus    # target type
    }

    # Native type construction expression
    # Example: {} innatum tabula<textus, numerus>
    # Example: [] innatum lista<textus>
    InnatumExpressia {
        Locus locus
        Expressia expressia
        TypusAnnotatio scopus    # target type
    }

    # Postfix construction expression
    # Example: { x: 1 } novum Type
    # WHY: Provides postfix construction syntax parallel to 'qua' casting.
    #      Makes the distinction between casting and construction explicit:
    #        { ... } qua Type   -> type assertion (compile-time only)
    #        { ... } novum Type -> constructor call (runtime instantiation)
    PostfixNovumExpressia {
        Locus locus
        Expressia expressia
        TypusAnnotatio scopus    # target type (class to instantiate)
    }

    # Type check expression
    # Example: value est numerus
    EstExpressia {
        Locus locus
        Expressia expressia
        TypusAnnotatio scopus    # type to check against
    }

    # Compile-time expression
    # Example: praefixum { ... }
    PraefixumExpressia {
        Locus locus
        ClausuraCorpus corpus
    }


    # -------------------------------------------------------------------------
    # Calls and Member Access
    # -------------------------------------------------------------------------

    # Function/method call expression
    # Examples: foo(1, 2), obj.method(), await fetch()
    VocatioExpressia {
        Locus locus
        Expressia vocatum        # what's being called (callee)
        lista<Expressia> argumenta
        bivalens optivum         # ?. optional call
        si MorphologiaInvocatio morphologia
    }

    # Member access expression
    # Examples: obj.prop, arr[0], obj?.prop, obj!.prop
    MembrumExpressia {
        Locus locus
        Expressia obiectum       # the object being accessed
        Expressia proprietas     # property name or index
        bivalens computatum      # true for arr[0], false for obj.prop
        bivalens optivum         # true for ?.
        bivalens nonNullum       # true for !.
    }

    # New instance creation
    # Example: novum Person { name: "Alice" }
    NovumExpressia {
        Locus locus
        Expressia vocatum        # the type/constructor
        lista<Expressia> argumenta
        si Expressia initor        # optional 'de { ... }' object
    }

    # Await expression (cede in Faber)
    # Example: cede fetchData()
    CedeExpressia {
        Locus locus
        Expressia argumentum
    }

    # Scriptum (format string) expression
    # Example: scriptum("Hello, ยง!", name)
    ScriptumExpressia {
        Locus locus
        textus exemplar          # format template
        lista<Expressia> argumenta
    }

    # Lege (stdin read) expression
    # Example: lege (read all), lege lineam (read one line)
    LegeExpressia {
        Locus locus
        textus modus              # "all" | "line"
    }

    # Ab expression for collection filtering DSL
    # Example: ab items activus, prima 5
    AbExpressia {
        Locus locus
        Expressia fons           # source
        bivalens negata          # true if "non" used
        si AbFiltrum filtrum       # optional filter clause
        lista<CatenaGradus>? gradus
    }

    # -------------------------------------------------------------------------
    # Collections
    # -------------------------------------------------------------------------

    # Array literal expression
    # Example: [1, 2, 3], [], [a, ...rest]
    SeriesExpressia {
        Locus locus
        lista<Expressia> elementa    # includes DispersioElementum for spread
    }

    # Object literal expression
    # Example: { name: "Alice", age: 30 }
    ObiectumExpressia {
        Locus locus
        lista<ObiectumProprietas> proprietates
    }

    # Spread element in array or object
    # Example: ...items, ...rest (sparge in Faber)
    DispersioElementum {
        Locus locus
        Expressia argumentum
    }

    # -------------------------------------------------------------------------
    # Clausura
    # -------------------------------------------------------------------------

    # Clausura expression (anonymous function/closure)
    # Example: clausura x: x * 2
    # Example: clausura x, y: x + y
    ClausuraExpressia {
        Locus locus
        lista<ClausuraParametrum> parametra
        ClausuraCorpus corpus
        si TypusAnnotatio typusReditus    # optional return type
    }

    # -------------------------------------------------------------------------
    # Discretio Construction
    # -------------------------------------------------------------------------

    # Construct a discretio variant
    # Example: finge Click { x: 10, y: 20 } qua Event
    FingeExpressia {
        Locus locus
        textus variansNomen      # variant name (e.g., "Click")
        lista<ObiectumProprietas> campi
        si TypusAnnotatio scopus   # qua Type
    }

    # -------------------------------------------------------------------------
    # Type Conversion
    # -------------------------------------------------------------------------

    # Type conversion expression
    # Examples: "42" numeratum, "3.14" fractatum, 42 textatum, x bivalentum
    #           "ff" numeratum<i32, Hex>, input numeratum vel 0
    ConversioExpressia {
        Locus locus
        Expressia expressia
        textus signum              # "numeratum" | "fractatum" | "textatum" | "bivalentum"
        si TypusAnnotatio scopusTypus    # optional target type (i32, u64, etc.)
        si textus radix              # optional: "Dec" | "Hex" | "Oct" | "Bin"
        si Expressia fallback        # optional vel fallback
    }
}
