# Annotation AST - Type definition for @ annotations
#
# WHY: Collocated with other AST types so both parser and AST can import.
#      Parser functions remain in parser/sententia/annotatio.fab.

importa ex "./positio" privata Locus

# ============================================================================
# ANNOTATION TYPE
# ============================================================================

# Parsed annotation with optional arguments
#
# EXTENDED FIELDS for stdlib annotations:
# - targetMappings: for @ innatum and @ subsidia (target -> value mapping)
# - radixForms: for @ radix (stem + morphological forms)
# - verteTarget: for @ verte (target language)
# - verteMethod: for @ verte simple form (method name)
# - verteParams: for @ verte template form (parameter list)
# - verteTemplate: for @ verte template form (template string)
# - optio*: for @ optio CLI flag definition
# - operandus*: for @ operandus CLI positional argument
@ publica
genus Annotatio {
    Locus locus
    textus nomen                # annotation name (e.g., "futura", "radix")
    lista<textus> argumenta     # optional arguments (e.g., ["imperativus"])

    # For @ innatum and @ subsidia: target-to-value mappings
    # Example: { ts: "Array", py: "list", zig: "Lista" }
    si tabula<textus, textus> targetMappings

    # For @ radix: stem and valid morphological forms
    # First element is the stem, rest are form names
    # Example: ["filtr", "imperativus", "perfectum"]
    si lista<textus> radixForms

    # For @ verte: the target language (ts, py, rs, cpp, zig)
    si textus verteTarget

    # For @ verte with simple method: the method name
    # Example: "push" for `@ verte ts "push"`
    si textus verteMethod

    # For @ verte with template: parameter names
    # Example: ["ego", "elem"] for `@ verte ts (ego, elem) -> "..."`
    si lista<textus> verteParams

    # For @ verte with template: the template string with S placeholders
    # Example: "[...S, S]" for `@ verte ts (ego, elem) -> "[...S, S]"`
    si textus verteTemplate

    # For @ optio: CLI flag definition
    # Old grammar: @ optio <type> <binding> [brevis "x"] [longum "xxx"] [descriptio "..."]
    # New grammar: @ optio <name> [brevis "x"] [longum "xxx"] [bivalens] [descriptio "..."]
    # Example: @ optio target brevis "t" longum "target" descriptio "Target language"
    # Example: @ optio verbose brevis "v" longum "verbose" bivalens descriptio "Enable verbose"
    si textus optioTypus        # type annotation (textus, bivalens, etc.) - legacy
    si textus optioNomen        # binding name
    si textus optioBrevis       # short flag (-x)
    si textus optioLongum       # long flag (--xxx)
    si textus optioDescriptio   # help text
    si bivalens optioBivalens   # true if this is a boolean flag (new syntax)

    # For @ operandus: CLI positional argument
    # Grammar: @ operandus [ceteri] <type> <name> [descriptio "..."]
    # Example: @ operandus textus file descriptio "Input file"
    si textus operandusTypus
    si textus operandusNomen
    si bivalens operandusCeteri  # rest/variadic marker
    si textus operandusDescriptio
}
