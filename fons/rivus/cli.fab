# ═══════════════════════════════════════════════════════════════════════════════
# RIVUS - Bootstrap Faber Compiler CLI
# ═══════════════════════════════════════════════════════════════════════════════
#
# Multi-target compiler for bootstrap testing.
# Compiles Faber source to TypeScript, Go, or other targets.
#
# Usage:
#   rivus emit hello.fab                 # compile to stdout (default: ts)
#   rivus emit hello.fab -t go           # compile to Go
#   rivus emit hello.fab -o hello.ts     # compile to file
#   rivus build main.fab -o dist/        # build with dependencies
#   rivus parse hello.fab                # dump AST as JSON
#   rivus check hello.fab                # validate without codegen
#
# ═══════════════════════════════════════════════════════════════════════════════

# Commands
§ ex "./cli/commands/emit" importa emitCommand
§ ex "./cli/commands/build" importa buildCommand
§ ex "./cli/commands/parse" importa parseCommand
§ ex "./cli/commands/check" importa checkCommand
§ ex "./cli/commands/test" importa testCommand

@ cli "rivus"
@ versio "0.1.0"
@ descriptio "Bootstrap Faber compiler - compiles Faber source to TypeScript or Go"
incipit argumenta args {}

# ─────────────────────────────────────────────────────────────────────────────
# version - show version
# ─────────────────────────────────────────────────────────────────────────────

@ imperium "version"
@ alias "v"
functio version() -> vacuum {
    scribe "rivus v0.1.0"
}

# ─────────────────────────────────────────────────────────────────────────────
# emit - compile single file to target language
# ─────────────────────────────────────────────────────────────────────────────

@ imperium "emit"
@ alias "compile"
@ descriptio "Compile Faber source to target language"
@ futura
@ optio textus target brevis "t" longum "target" descriptio "Target language: ts (default), go"
@ optio textus output brevis "o" longum "output" descriptio "Output file (default: stdout)"
@ optio textus include brevis "I" longum "include" descriptio "Add import search path"
@ optio textus stdinFilename longum "stdin-filename" descriptio "Filename to use for stdin input"
@ optio bivalens json longum "json" descriptio "Output errors as JSON"
@ optio bivalens dryRun longum "dry-run" descriptio "Check without emitting code"
@ optio bivalens stripTests longum "strip-tests" descriptio "Strip probandum/proba test blocks from output"
@ optio bivalens stripComments longum "strip-comments" descriptio "Strip comments from output"
functio emit(
    textus input,
    si textus target,
    si textus output,
    si textus include,
    si textus stdinFilename,
    si bivalens json,
    si bivalens dryRun,
    si bivalens stripTests,
    si bivalens stripComments
) exitus code -> vacuum {
    fixum result = cede emitCommand(input, target, output, include, stdinFilename, json, dryRun, stripTests, stripComments)
    code = result
}

# ─────────────────────────────────────────────────────────────────────────────
# build - compile entry and dependencies to directory
# ─────────────────────────────────────────────────────────────────────────────

@ imperium "build"
@ alias "aedifica"
@ descriptio "Build entry file and all dependencies to output directory"
@ futura
@ optio textus target brevis "t" longum "target" descriptio "Target language: ts (default), go"
@ optio textus output brevis "o" longum "output" descriptio "Output directory (default: ./dist)"
@ optio textus include brevis "I" longum "include" descriptio "Add import search path"
@ optio bivalens json longum "json" descriptio "Output errors as JSON"
@ optio bivalens dryRun longum "dry-run" descriptio "Check without writing files"
@ optio bivalens listFiles longum "list-files" descriptio "List files that would be compiled"
@ optio bivalens stripComments longum "strip-comments" descriptio "Strip comments from output"
functio build(
    textus input,
    si textus target,
    si textus output,
    si textus include,
    si bivalens json,
    si bivalens dryRun,
    si bivalens listFiles,
    si bivalens stripComments
) exitus code -> vacuum {
    fixum result = cede buildCommand(input, target, output, include, json, dryRun, listFiles, stripComments)
    code = result
}

# ─────────────────────────────────────────────────────────────────────────────
# parse - lex and parse, dump AST
# ─────────────────────────────────────────────────────────────────────────────

@ imperium "parse"
@ alias "ast"
@ descriptio "Parse source and dump AST as JSON"
@ futura
@ optio textus output brevis "o" longum "output" descriptio "Output file (default: stdout)"
@ optio textus stdinFilename longum "stdin-filename" descriptio "Filename to use for stdin input"
@ optio bivalens compact longum "compact" descriptio "Output compact JSON (no indentation)"
functio parse(
    textus input,
    si textus output,
    si textus stdinFilename,
    si bivalens compact
) exitus code -> vacuum {
    fixum result = cede parseCommand(input, output, stdinFilename, compact)
    code = result
}

# ─────────────────────────────────────────────────────────────────────────────
# check - validate without codegen
# ─────────────────────────────────────────────────────────────────────────────

@ imperium "check"
@ alias "proba"
@ descriptio "Validate source without generating code"
@ futura
@ optio textus output brevis "o" longum "output" descriptio "Write error report to file"
@ optio textus include brevis "I" longum "include" descriptio "Add import search path"
@ optio textus stdinFilename longum "stdin-filename" descriptio "Filename to use for stdin input"
@ optio bivalens json longum "json" descriptio "Output errors as JSON"
@ optio bivalens strict longum "strict" descriptio "Enable all strict checks"
functio check(
    textus input,
    si textus output,
    si textus include,
    si textus stdinFilename,
    si bivalens json,
    si bivalens strict
) exitus code -> vacuum {
    fixum result = cede checkCommand(input, output, include, stdinFilename, json, strict)
    code = result
}

# ─────────────────────────────────────────────────────────────────────────────
# test - compile and run tests with standalone harness
# ─────────────────────────────────────────────────────────────────────────────

@ imperium "test"
@ alias "probandum"
@ descriptio "Compile and run tests with standalone harness"
@ futura
@ optio textus target brevis "t" longum "target" descriptio "Target language: ts (default)"
@ optio textus tag longum "tag" descriptio "Run only tests with this tag"
@ optio textus exclude longum "exclude" descriptio "Exclude tests with this tag"
@ optio textus stdinFilename longum "stdin-filename" descriptio "Filename to use for stdin input"
@ optio bivalens json longum "json" descriptio "Output errors as JSON"
@ optio bivalens dryRun longum "dry-run" descriptio "Compile only, don't execute"
@ optio bivalens solo longum "only" descriptio "Run only tests marked @ solum"
functio test(
    textus input,
    si textus target,
    si textus tag,
    si textus exclude,
    si textus stdinFilename,
    si bivalens json,
    si bivalens dryRun,
    si bivalens solo
) exitus code -> vacuum {
    figendum result = testCommand(input, target, tag, exclude, stdinFilename, json, dryRun, solo)
    code = result
}
