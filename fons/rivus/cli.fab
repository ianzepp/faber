# CLI - Command-line interface for bootstrap Faber compiler
#
# Minimal stdin-to-stdout compiler for bootstrap testing.
# Reads file path as first line, then Faber source from stdin.
# Writes TypeScript to stdout.
#
# Usage: { echo "/path/to/file.fab"; cat file.fab } | bun opus/rivus/fons/ts/cli.ts
#
# For Zig output, use the test script pattern or import generateZig directly.

ex "./lexor/index" importa lexare, LexorResultatum
ex "./parser/index" importa resolvere, ParserResultatum
ex "./semantic/index" importa analyze
ex "./semantic/nucleus" importa SemanticResultatum
ex "./codegen/ts/index" importa generateTs
ex "./ast/radix" importa Programma

# =============================================================================
# MAIN ENTRY POINT
# =============================================================================

incipiet {
    # Read all stdin: first line is file path, rest is source
    fixum input = lege
    fixum newlineIndex = input.indexOf("\n")

    # Extract file path (first line) and source (rest)
    varia viaIngressus = nihil qua textus?
    varia source = input

    si newlineIndex > 0 {
        fixum firstLine = input.substring(0, newlineIndex)
        # Check if first line looks like a file path (starts with / or ./)
        si firstLine.startsWith("/") aut firstLine.startsWith("./") {
            viaIngressus = firstLine
            source = input.substring(newlineIndex + 1)
        }
    }

    # Lexical analysis
    fixum lexResult = lexare(source)

    si lexResult.errores.longitudo() > 0 {
        mone "Lexor errors:"
        ex lexResult.errores pro err {
            mone scriptum("  §:§ - §", err.locus.linea, err.locus.columna, err.textus)
        }
        # Exit with error (no explicit exit in Faber yet)
        redde
    }

    # Parsing
    fixum parseResult = resolvere(lexResult.symbola)

    si parseResult.errores.longitudo() > 0 {
        mone "Parser errors:"
        ex parseResult.errores pro err {
            mone scriptum("  §:§ - §", err.locus.linea, err.locus.columna, err.nuntius)
        }
        redde
    }

    si parseResult.programma est nihil {
        mone "Failed to parse program"
        redde
    }

    # Semantic analysis
    fixum semResult = analyze(parseResult.programma qua Programma, viaIngressus)

    si semResult.errores.longitudo() > 0 {
        mone "Semantic errors:"
        ex semResult.errores pro err {
            mone scriptum("  §:§ - §", err.locus.linea, err.locus.columna, err.nuntius)
        }
        redde
    }

    # Code generation
    fixum output = generateTs((parseResult.programma qua Programma).corpus)

    # Write to stdout
    scribe output
}
