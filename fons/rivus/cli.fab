# ═══════════════════════════════════════════════════════════════════════════════
# RIVUS - Bootstrap Faber Compiler CLI
# ═══════════════════════════════════════════════════════════════════════════════
#
# Multi-target compiler for bootstrap testing.
# Compiles Faber source to TypeScript, Go, or other targets.
#
# Usage:
#   rivus emit hello.fab                 # compile to stdout (default: ts)
#   rivus emit hello.fab -t go           # compile to Go
#   rivus emit hello.fab -o hello.ts     # compile to file
#   rivus build main.fab -o dist/        # build with dependencies
#   rivus parse hello.fab                # dump AST as JSON
#   rivus check hello.fab                # validate without codegen
#
# ═══════════════════════════════════════════════════════════════════════════════

# Commands
ex "./cli/commands/emit" importa emitCommand
ex "./cli/commands/build" importa buildCommand
ex "./cli/commands/parse" importa parseCommand
ex "./cli/commands/check" importa checkCommand

@ cli "rivus"
@ versio "0.1.0"
@ descriptio "Bootstrap Faber compiler - compiles Faber source to TypeScript or Go"
incipit argumenta args {}

# ─────────────────────────────────────────────────────────────────────────────
# version - show version
# ─────────────────────────────────────────────────────────────────────────────

@ imperium "version"
@ alias "v"
functio version() -> vacuum {
    scribe "rivus v0.1.0"
}

# ─────────────────────────────────────────────────────────────────────────────
# emit - compile single file to target language
# ─────────────────────────────────────────────────────────────────────────────

@ imperium "emit"
@ alias "compile"
@ descriptio "Compile Faber source to target language"
@ futura
@ optio textus target brevis "t" longum "target" descriptio "Target language: ts (default), go"
@ optio textus output brevis "o" longum "output" descriptio "Output file (default: stdout)"
functio emit(
    textus input,
    si textus target,
    si textus output
) exitus code -> vacuum {
    fixum result = cede emitCommand(input, target, output)
    code = result
}

# ─────────────────────────────────────────────────────────────────────────────
# build - compile entry and dependencies to directory
# ─────────────────────────────────────────────────────────────────────────────

@ imperium "build"
@ alias "aedifica"
@ descriptio "Build entry file and all dependencies to output directory"
@ futura
@ optio textus target brevis "t" longum "target" descriptio "Target language: ts (default), go"
@ optio textus output brevis "o" longum "output" descriptio "Output directory (default: ./dist)"
functio build(
    textus input,
    si textus target,
    si textus output
) exitus code -> vacuum {
    fixum result = cede buildCommand(input, target, output)
    code = result
}

# ─────────────────────────────────────────────────────────────────────────────
# parse - lex and parse, dump AST
# ─────────────────────────────────────────────────────────────────────────────

@ imperium "parse"
@ alias "ast"
@ descriptio "Parse source and dump AST as JSON"
@ futura
@ optio textus output brevis "o" longum "output" descriptio "Output file (default: stdout)"
functio parse(
    textus input,
    si textus output
) exitus code -> vacuum {
    fixum result = cede parseCommand(input, output)
    code = result
}

# ─────────────────────────────────────────────────────────────────────────────
# check - validate without codegen
# ─────────────────────────────────────────────────────────────────────────────

@ imperium "check"
@ alias "proba"
@ descriptio "Validate source without generating code"
@ futura
functio check(textus input) exitus code -> vacuum {
    fixum result = cede checkCommand(input)
    code = result
}
