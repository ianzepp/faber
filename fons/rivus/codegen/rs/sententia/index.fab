# Rust Statement Generator - Dispatch

ex "../../../ast/sententia" importa Sententia, VariaGenus, ScribeGradus, IteratioGenus
ex "../../../ast/sententia" importa Parametrum, CampusDeclaratio, EligeCasus, VariansCasus
ex "../../../ast/sententia" importa OrdoMembrum, VariansDeclaratio, ImportaSpecificator, PactumMethodus, TypusParametrum
ex "../../../ast/expressia" importa Expressia
ex "../../../ast/typus" importa TypusAnnotatio
ex "../nucleus" importa RsGenerator
ex "../typus" importa genTypus
ex "../expressia/index" importa genExpressia
ex "./varia" importa genVaria
ex "./si" importa genSi
ex "./functio" importa genFunctio, genParametrum
ex "./genus" importa genGenus
ex "./ordo" importa genOrdo
ex "./dum" importa genDum
ex "./iteratio" importa genIteratio
ex "./elige" importa genElige
ex "./discerne" importa genDiscerne
ex "./tempta" importa genTempta
ex "./scribe" importa genScribe
ex "./redde" importa genRedde

@ publica
functio genSententia(Sententia stmt, RsGenerator g) -> textus {
    fixum leading = g.notaePrae(stmt)
    fixum trailing = g.notaePost(stmt)
    fixum content = genSententiaContent(stmt, g)
    redde scriptum("§§§", leading, content, trailing)
}

functio genSententiaContent(Sententia stmt, RsGenerator g) -> textus {
    discerne stmt {
        casu MassaSententia ut s { redde genMassa(s.corpus qua lista<Sententia>, g) }
        casu VariaSententia ut s {
            redde genVaria(s.species qua VariaGenus, s.nomen qua textus, s.typus, s.valor, s.externa qua bivalens, g)
        }
        casu ImportaSententia ut s {
            fixum path = (s.fons qua textus).replace("/", "::")
            si s.totum qua bivalens { redde scriptum("§use §::*;", g.ind(), path) }
            varia names = [] innatum lista<textus>
            ex (s.specificatores qua lista<ImportaSpecificator>) pro spec {
                names.adde(spec.nomen)
            }
            si names.longitudo() == 1 { redde scriptum("§use §::§;", g.ind(), path, names[0]) }
            redde scriptum("§use §::{{§}};", g.ind(), path, names.coniunge(", "))
        }
        casu FunctioDeclaratio ut f {
            redde genFunctio(f.nomen qua textus, f.generaParametra, f.parametra qua lista<Parametrum>, f.reddeVerbum, f.typusReditus, f.corpus, f.asynca qua bivalens, f.generator qua bivalens, f.structor qua bivalens, f.visibilitas, f.abstracta qua bivalens, f.externa qua bivalens, g)
        }
        casu GenusDeclaratio ut s {
            redde genGenus(s.nomen qua textus, s.generaParametra, s.extendit, s.implet, s.abstractum qua bivalens, s.campi qua lista<CampusDeclaratio>, s.structor, s.methodi qua lista<Sententia>, g)
        }
        casu OrdoDeclaratio ut s { redde genOrdo(s.nomen qua textus, s.membra qua lista<OrdoMembrum>, g) }
        casu DiscretioDeclaratio ut s {
            varia result = scriptum("§pub enum § {{", g.ind(), s.nomen)
            g.intraProfundum()
            ex (s.variantes qua lista<VariansDeclaratio>) pro v {
                result = scriptum("§\n§§,", result, g.ind(), v.nomen)
            }
            g.exiProfundum()
            redde scriptum("§\n§}}", result, g.ind())
        }
        casu TypusAliasDeclaratio ut s {
            redde scriptum("§type § = §;", g.ind(), s.nomen, genTypus(s.typus qua TypusAnnotatio, g))
        }
        casu PactumDeclaratio ut s {
            varia result = scriptum("§pub trait § {{", g.ind(), s.nomen)
            g.intraProfundum()
            ex (s.methodi qua lista<PactumMethodus>) pro m {
                varia params = [] innatum lista<textus>
                si m.parametra != nihil {
                    ex (m.parametra qua lista<Parametrum>) pro param {
                        params.adde(genParametrum(param, g))
                    }
                }
                varia sig = scriptum("§fn §(§)", g.ind(), m.nomen, params.coniunge(", "))
                si nonnihil m.typusReditus {
                    sig = scriptum("§ -> §", sig, genTypus(m.typusReditus qua TypusAnnotatio, g))
                }
                result = scriptum("§\n§;", result, sig)
            }
            g.exiProfundum()
            redde scriptum("§\n§}}", result, g.ind())
        }
        casu SiSententia ut s { redde genSi(s.condicio, s.consequens qua Sententia, s.alternans, s.cape, g) }
        casu DumSententia ut s { redde genDum(s.condicio, s.corpus qua Sententia, s.cape, g) }
        casu IteratioSententia ut s {
            redde genIteratio(s.species qua IteratioGenus, s.variabilis qua textus, s.iterabile, s.corpus qua Sententia, s.asynca qua bivalens, s.cape, g)
        }
        casu EligeSententia ut s {
            redde genElige(s.discriminans, s.casus qua lista<EligeCasus>, s.praedefinitum, s.cape, g)
        }
        casu DiscerneSententia ut s { redde genDiscerne(s.discriminans, s.casus qua lista<VariansCasus>, g) }
        casu TemptaSententia ut s { redde genTempta(s.corpus qua Sententia, s.cape, s.demum, g) }
        casu IaceSententia ut s {
            si s.fatale qua bivalens {
                si nonnihil s.argumentum { redde scriptum("§panic!(\"{{:?}}\", §);", g.ind(), genExpressia(s.argumentum qua Expressia, g)) }
                redde scriptum("§panic!();", g.ind())
            }
            si nonnihil s.argumentum { redde scriptum("§return Err(§);", g.ind(), genExpressia(s.argumentum qua Expressia, g)) }
            redde scriptum("§return Err(());", g.ind())
        }
        casu ScribeSententia ut s { redde genScribe(s.gradus qua ScribeGradus, s.argumenta qua lista<Expressia>, g) }
        casu ReddeSententia ut s { redde genRedde(s.valor, g) }
        casu RumpeSententia { redde scriptum("§break;", g.ind()) }
        casu PergeSententia { redde scriptum("§continue;", g.ind()) }
        casu ExpressiaSententia ut s { redde scriptum("§§;", g.ind(), genExpressia(s.expressia, g)) }
    }
    redde scriptum("§/* unknown statement */", g.ind())
}

@ publica
functio genMassa(lista<Sententia> corpus, RsGenerator g) -> textus {
    si corpus.longitudo() == 0 { redde "" }
    varia lines = [] innatum lista<textus>
    ex corpus pro stmt { lines.adde(genSententia(stmt, g)) }
    redde lines.coniunge("\n")
}
