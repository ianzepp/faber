# Go Statement Generator - Iteration Loops
#
# TRANSFORMS:
#   ex lista pro item { ... }   -> for _, item := range lista { ... }
#   de tabula pro key { ... }   -> for key := range tabula { ... }
#   ex 0..10 pro i { ... }      -> for i := 0; i < 10; i++ { ... }
#   ex 0 usque 10 pro i { ... } -> for i := 0; i <= 10; i++ { ... }

ex "../../../ast/sententia" importa Sententia, IteratioGenus
ex "../../../ast/expressia" importa Expressia
ex "../nucleus" importa GoGenerator
ex "../expressia/index" importa genExpressia
ex "./index" importa genSententia

@ publica
functio genIteratio(IteratioGenus species, textus variabilis, Expressia iterabile, Sententia corpus, GoGenerator g) -> textus {
    g.intraProfundum()
    fixum body = genSententia(corpus, g)
    g.exiProfundum()

    # Check for range expression (AmbitusExpressia) - use traditional for loop
    discerne iterabile {
        casu AmbitusExpressia ut a {
            fixum initium = genExpressia(a.initium, g)
            fixum finis = genExpressia(a.finis, g)
            fixum op = (a.inclusivum qua bivalens) sic "<=" secus "<"

            varia incrementum = scriptum("§++", variabilis)
            si nonnihil a.gradus {
                incrementum = scriptum("§ += §", variabilis, genExpressia(a.gradus qua Expressia, g))
            }

            redde scriptum("§for § := §; § § §; § {\n§\n§}", g.ind(), variabilis, initium, variabilis, op, finis, incrementum, body, g.ind())
        }
        ceterum { }
    }

    # Regular iteration
    fixum iterStr = genExpressia(iterabile, g)

    si species == IteratioGenus.De {
        # de: iterate over keys only
        redde scriptum("§for § := range § {\n§\n§}", g.ind(), variabilis, iterStr, body, g.ind())
    }

    # ex: iterate over values (use blank identifier for index)
    redde scriptum("§for _, § := range § {\n§\n§}", g.ind(), variabilis, iterStr, body, g.ind())
}
