# Go Statement Generator - Iteration Loops
#
# TRANSFORMS:
#   ex lista fixum item { ... }   -> for _, item := range lista { ... }
#   de tabula fixum key { ... }   -> for key := range tabula { ... }
#   ex 0..10 fixum i { ... }      -> for i := 0; i < 10; i++ { ... }
#   ex 0 usque 10 fixum i { ... } -> for i := 0; i <= 10; i++ { ... }

§ ex "../../../ast/sententia" importa Sententia, IteratioGenus, IteratioVariabilis
§ ex "../../../ast/expressia" importa Expressia
§ ex "../nucleus" importa GoGenerator
§ ex "../../shared/syntaxis" importa SYNTAXIS_GO
§ ex "../../shared/iteratio" importa genAmbitusIteratio
§ ex "../revocata" importa creaGoRevocata
§ ex "../expressia/index" importa genExpressia
§ ex "./index" importa genSententia

@ publica
functio genIteratio(in GoGenerator g, species, de IteratioVariabilis variabilis, de Expressia iterabile, de Sententia corpus) -> textus {
    fixum rev = creaGoRevocata()

    # Check for range expression - use shared handler (only for simple identifier)
    discerne variabilis {
        casu Nomen ut n {
            discerne iterabile {
                casu AmbitusExpressia ut a {
                    g.intraProfundum()
                    fixum body = genSententia(g, corpus)
                    g.exiProfundum()

                    fixum initium = genExpressia(g, a.initium)
                    fixum finis = genExpressia(g, a.finis)

                    redde genAmbitusIteratio(
                        n.valor,
                        initium,
                        finis,
                        a.inclusivum qua bivalens,
                        a.gradus,
                        body,
                        falsum,
                        nihil,
                        g,
                        SYNTAXIS_GO,
                        rev
                    )
                }
                ceterum { }
            }
        }
        ceterum { }
    }

    # Regular iteration - Go-specific range syntax
    g.intraProfundum()
    fixum body = genSententia(g, corpus)
    g.exiProfundum()

    fixum iterStr = genExpressia(g, iterabile)

    discerne variabilis {
        casu Nomen ut n {
            si species == IteratioGenus.De {
                redde scriptum("§for § := range § {\n§\n§}", g.ind(), n.valor, iterStr, body, g.ind())
            }
            redde scriptum("§for _, § := range § {\n§\n§}", g.ind(), n.valor, iterStr, body, g.ind())
        }
        casu Series ut s {
            # For maps with 2 elements, use Go's native k,v syntax
            si s.elementa.longitudo() == 2 {
                fixum k = s.elementa[0].nomen vel "_"
                fixum v = s.elementa[1].nomen vel "_"
                redde scriptum("§for §, § := range § {\n§\n§}", g.ind(), k, v, iterStr, body, g.ind())
            }

            # For other patterns, use temp var + unpacking
            varia unpacks = [] innatum lista<textus>
            varia indice = 0
            ex s.elementa fixum elem {
                si non elem.omissum et nonnihil elem.nomen {
                    g.intraProfundum()
                    unpacks.adde(scriptum("§§ := _item[§]", g.ind(), elem.nomen, indice))
                    g.exiProfundum()
                }
                indice = indice + 1
            }
            fixum unpackStr = unpacks.coniunge("\n")
            redde scriptum("§for _, _item := range § {\n§\n§\n§}", g.ind(), iterStr, unpackStr, body, g.ind())
        }
    }
}
