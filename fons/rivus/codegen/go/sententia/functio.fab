# Go Statement Generator - Function Declarations
#
# Generates Go function declarations.
#
# TRANSFORMS:
#   functio f() { ... }                    -> func f() { ... }
#   functio f(textus x) -> textus { ... }  -> func f(x string) string { ... }
#   functio f() curata alloc -> T { ... }  -> func f() T { ... }  (ignore allocator)
#   @ publica functio f() { ... }          -> func F() { ... }    (capitalize)

§ ex "../../../ast/sententia" importa Sententia, Parametrum, TypusParametrum, Visibilitas, FunctioModificator
§ ex "../../../ast/typus" importa TypusAnnotatio
§ ex "../nucleus" importa GoGenerator

# External declarations
§ ex "../expressia/index" importa genExpressia
§ ex "./index" importa genSententia
§ ex "../typus" importa genTypus

functio habetErrataModificator(ignotum modificatores) -> bivalens {
    si nihil modificatores {
        redde falsum
    }
    ex (modificatores qua lista<FunctioModificator>) fixum m {
        discerne m {
            casu ErrataModificator {
                redde verum
            }
            ceterum { }
        }
    }
    redde falsum
}

@ publica
functio genFunctio(textus nomen, ignotum generaParametra, lista<Parametrum> parametra, ignotum modificatores, ignotum reddeVerbum, ignotum typusReditus, ignotum corpus, bivalens asynca, bivalens generator, bivalens structor, ignotum visibilitas, bivalens abstracta, bivalens externa, GoGenerator g) -> textus {
    # External declarations - Go doesn't have declare syntax
    si externa {
        redde scriptum("§// extern: func §(...)", g.ind(), nomen)
    }

    varia result = g.ind()

    # Determine function name - capitalize if public (Go visibility convention)
    varia funcName = nomen
    si nonnihil visibilitas {
        fixum vis = visibilitas qua Visibilitas
        si vis == Visibilitas.Publica {
            # Capitalize first letter for Go export
            si funcName.longitudo() > 0 {
                fixum textus firstChar = funcName.sectio(0, 1)
                fixum first = firstChar.maiuscula()
                fixum len = funcName.longitudo()
                fixum rest = funcName.sectio(1, len)
                funcName = scriptum("§§", first, rest)
            }
        }
    }

    result = scriptum("§func §", result, funcName)

    # Generic parameters - Go 1.18+ generics
    si nonnihil generaParametra {
        fixum gp = generaParametra qua lista<TypusParametrum>
        si gp.longitudo() > 0 {
            varia names = [] innatum lista<textus>
            ex gp fixum p {
                # Go generics need type constraint, default to 'any'
                names.adde(scriptum("§ any", p.nomen))
            }
            result = scriptum("§[§]", result, names.coniunge(", "))
        }
    }

    # Parameters
    varia params = [] innatum lista<textus>
    ex parametra fixum param {
        params.adde(genParametrum(param, g))
    }
    result = scriptum("§(§)", result, params.coniunge(", "))

    # Return type
    varia retType = ""
    si nonnihil typusReditus {
        retType = genTypus(typusReditus novum TypusAnnotatio, g)
    }
    fixum hasErrata = habetErrataModificator(modificatores)
    si hasErrata {
        si retType == "" {
            result = scriptum("§ error", result)
        } secus {
            result = scriptum("§ (§, error)", result, retType)
        }
    } sin retType != "" {
        result = scriptum("§ §", result, retType)
    }

    # Body
    si nihil corpus {
        # No body - abstract or declaration only
        redde result
    }

    si nonnihil corpus {
        fixum prevInErrata = g.inErrata
        fixum prevErrataType = g.errataTypusReditus
        g.inErrata = hasErrata
        varia errataType = nihil qua TypusAnnotatio?
        # WHY: Only track a value return type for errata when Go emits (T, error).
        # EDGE: `-> vacuum` or no return type becomes `error` only.
        si hasErrata et retType != "" et nonnihil typusReditus {
            errataType = typusReditus novum TypusAnnotatio
        }
        g.errataTypusReditus = errataType

        g.intraProfundum()
        fixum body = genSententia(corpus qua Sententia, g)
        g.exiProfundum()

        g.inErrata = prevInErrata
        g.errataTypusReditus = prevErrataType

        si body == "" {
            result = scriptum("§ {}", result)
        } secus {
            result = scriptum("§ {\n§\n§}", result, body, g.ind())
        }
    }

    redde result
}

@ publica
functio genParametrum(Parametrum param, GoGenerator g) -> textus {
    varia result = param.nomen

    # Type annotation
    si nonnihil param.typus {
        fixum typeName = genTypus(param.typus novum TypusAnnotatio, g)
        result = scriptum("§ §", result, typeName)
    }

    # Go doesn't support default values in function params
    # Would need to handle with function overloading or optional pattern

    redde result
}
