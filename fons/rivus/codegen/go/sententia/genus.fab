# Go Statement Generator - Genus (Struct) Declarations
#
# TRANSFORMS:
#   genus Persona { textus nomen } -> type Persona struct { Nomen string }
#   @ publica genus Persona { ... } -> type Persona struct { ... } (exported via name)

§ ex "../../../ast/sententia" importa Sententia, FunctioDeclaratio, CampusDeclaratio, Parametrum, TypusParametrum, Visibilitas, FunctioModificator, GenusDeclaratio
§ ex "../../../ast/typus" importa TypusAnnotatio
§ ex "../nucleus" importa GoGenerator
§ ex "../typus" importa genTypus
§ ex "./index" importa genSententia
§ ex "./functio" importa genParametrum

@ publica
functio genGenus(in GoGenerator g, de GenusDeclaratio s) -> textus {
    # NOTE: Go has no class inheritance; extendit/implet/structor are ignored here.
    varia typeName = s.nomen qua textus
    si nonnihil s.visibilitas {
        fixum vis = s.visibilitas qua Visibilitas
        si vis == Visibilitas.Publica {
            typeName = capitaliza(typeName)
        }
    }

    varia header = scriptum("§type §", g.ind(), typeName)

    # Generic parameters (Go 1.18+)
    si nonnihil s.generaParametra {
        fixum gp = s.generaParametra qua lista<textus>
        si gp.longitudo() > 0 {
            varia params = [] innatum lista<textus>
            ex gp fixum p {
                params.adde(scriptum("§ any", p))
            }
            header = scriptum("§[§]", header, params.coniunge(", "))
        }
    }

    varia lines = [] innatum lista<textus>
    lines.adde(scriptum("§ struct {", header))
    g.intraProfundum()
    ex s.campi fixum campus {
        fixum fieldName = campusNomenGo(campus)
        fixum fieldType = genTypus(g, campus.typus)
        lines.adde(scriptum("§§ §", g.ind(), fieldName, fieldType))
    }
    g.exiProfundum()
    lines.adde(scriptum("§}", g.ind()))

    lines.adde("")
    lines.adde(genGenusConstructor(g, typeName))

    ex s.methodi fixum methodus {
        lines.adde("")
        lines.adde(genGenusMethod(g, typeName, methodus qua Sententia))
    }

    redde lines.coniunge("\n")
}

functio habetErrataModificator(si de ignotum modificatores) -> bivalens {
    si nihil modificatores {
        redde falsum
    }
    ex (modificatores qua lista<FunctioModificator>) fixum m {
        discerne m {
            casu ErrataModificator {
                redde verum
            }
            ceterum tacet
        }
    }
    redde falsum
}

functio genGenusConstructor(in GoGenerator g, de textus typeName) -> textus {
    varia lines = [] innatum lista<textus>
    lines.adde(scriptum("§func New§(_ ...interface{}) *§ {", g.ind(), capitaliza(typeName), typeName))
    g.intraProfundum()
    lines.adde(scriptum("§return &§{}", g.ind(), typeName))
    g.exiProfundum()
    lines.adde(scriptum("§}", g.ind()))
    redde lines.coniunge("\n")
}

functio genGenusMethod(in GoGenerator g, de textus typeName, de Sententia methodus) -> textus {
    discerne methodus {
        casu FunctioDeclaratio ut f {
            # External method declarations are not supported in Go
            si f.externa {
                redde scriptum("§// extern: method §", g.ind(), f.nomen)
            }

            varia methodName = f.nomen
            si nonnihil f.visibilitas {
                fixum vis = f.visibilitas qua Visibilitas
                si vis == Visibilitas.Publica {
                    methodName = capitaliza(methodName)
                }
            }

            varia result = scriptum("§func (this *§) §", g.ind(), typeName, methodName)

            # Generic parameters
            si nonnihil f.generaParametra {
                fixum gp = f.generaParametra qua lista<TypusParametrum>
                si gp.longitudo() > 0 {
                    varia names = [] innatum lista<textus>
                    ex gp fixum p {
                        names.adde(scriptum("§ any", p.nomen))
                    }
                    result = scriptum("§[§]", result, names.coniunge(", "))
                }
            }

            # Parameters
            varia params = [] innatum lista<textus>
            ex (f.parametra qua lista<Parametrum>) fixum param {
                params.adde(genParametrum(g, param))
            }
            result = scriptum("§(§)", result, params.coniunge(", "))

            # Return type
            varia retType = ""
            si nonnihil f.typusReditus {
                retType = genTypus(g, f.typusReditus qua TypusAnnotatio)
            }
            fixum hasErrata = habetErrataModificator(f.modificatores)
            si hasErrata {
                si retType == "" {
                    result = scriptum("§ error", result)
                } secus {
                    result = scriptum("§ (§, error)", result, retType)
                }
            } sin retType != "" {
                result = scriptum("§ §", result, retType)
            }

            # Body
            si nihil f.corpus {
                redde result
            }

            fixum prevInErrata = g.inErrata
            fixum prevErrataType = g.errataTypusReditus
            g.inErrata = hasErrata
            varia errataType = nihil qua si TypusAnnotatio
            si hasErrata et retType != "" et nonnihil f.typusReditus {
                errataType = f.typusReditus qua TypusAnnotatio
            }
            g.errataTypusReditus = errataType

            g.intraProfundum()
            fixum body = genSententia(g, f.corpus)
            g.exiProfundum()

            g.inErrata = prevInErrata
            g.errataTypusReditus = prevErrataType

            si body == "" {
                redde scriptum("§ {}", result)
            }
            redde scriptum("§ {\n§\n§}", result, body, g.ind())
        }
        ceterum tacet
    }

    redde ""
}

functio campusNomenGo(de CampusDeclaratio campus) -> textus {
    si campus.visibilitas == Visibilitas.Publica {
        redde capitaliza(campus.nomen)
    }
    redde campus.nomen
}

# Capitalize first letter for Go field names
functio capitaliza(de textus s) -> textus {
    si s.longitudo() == 0 {
        redde s
    }
    fixum primum = s.sectio(0, 1) qua textus
    fixum first = primum.maiuscula()
    si s.longitudo() == 1 {
        redde first
    }
    redde scriptum("§§", first, s.sectio(1, s.longitudo()))
}
