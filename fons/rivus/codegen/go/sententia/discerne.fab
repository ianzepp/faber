# Go Statement Generator - Discerne (Variant Matching)
#
# Generates Go type switches for discriminated union matching.
# Uses idiomatic Go interface-based tagged unions.
#
# TRANSFORMS:
#   discerne x { casu A {...} }             -> switch _v := x.(type) { case A: ... }
#   discerne x { casu B ut b {...} }        -> switch _v := x.(type) { case B: b := _v; ... }
#   discerne x { casu C fixum a, b {...} }    -> switch _v := x.(type) { case C: a := _v.A; b := _v.B; ... }
#   discerne x { casu _ {...} }             -> default: ...
#
#   Multi-discriminant:
#   discerne a, b { casu X ut x, Y ut y {...} }
#     -> _a, aOk := a.(X); _b, bOk := b.(Y); if aOk && bOk { x := _a; y := _b; ... }

§ ex "../../../ast/sententia" importa Sententia, VariansCasus, VariansExemplar
§ ex "../../../ast/expressia" importa Expressia
§ ex "../nucleus" importa GoGenerator
§ ex "../expressia/index" importa genExpressia
§ ex "./index" importa genSententia

@ publica
functio genDiscerne(lista<Expressia> discriminantes, lista<VariansCasus> casus, GoGenerator g) -> textus {
    # Generate expressions for all discriminants
    varia discriminantStrs = [] innatum lista<textus>
    ex discriminantes fixum d {
        discriminantStrs.adde(genExpressia(d, g))
    }

    # Single discriminant: use type switch
    si discriminantStrs.longitudo() == 1 {
        redde genDiscerneSimplex(discriminantStrs[0], casus, g)
    }

    # Multi-discriminant: use type assertions with if/else
    redde genDiscerneMultiplex(discriminantStrs, casus, g)
}

# Single discriminant: generates Go type switch
functio genDiscerneSimplex(textus discriminant, lista<VariansCasus> casus, GoGenerator g) -> textus {
    # Check if any case uses bindings (alias or field extraction)
    varia needsBinding = falsum
    ex casus fixum c {
        fixum pattern = c.exemplaria[0]
        si non pattern.estWildcard {
            si nonnihil pattern.alias aut pattern.vincula.longitudo() > 0 {
                needsBinding = verum
                rumpe
            }
        }
    }

    # Go type switch: switch _v := x.(type) or switch x.(type) if no bindings needed
    varia result = ""
    si needsBinding {
        result = scriptum("§switch _v := §.(type) {\n", g.ind(), discriminant)
    } secus {
        result = scriptum("§switch §.(type) {\n", g.ind(), discriminant)
    }

    ex casus fixum c {
        fixum pattern = c.exemplaria[0]

        si pattern.estWildcard {
            result = scriptum("§§default:\n", result, g.ind())
        } secus {
            result = scriptum("§§case §:\n", result, g.ind(), pattern.variansNomen)
        }

        g.intraProfundum()

        # Generate bindings (use _v as the typed value)
        si non pattern.estWildcard {
            result = scriptum("§§", result, genPatternBindingsTypeSwitch(pattern, g))
        }

        # Generate body
        result = scriptum("§§\n", result, genSententia(c.consequens, g))
        g.exiProfundum()
    }

    # Check if we have a default case (wildcard)
    varia hasDefault = falsum
    ex casus fixum c {
        si c.exemplaria[0].estWildcard {
            hasDefault = verum
            rumpe
        }
    }

    # Add implicit default panic if no default case (for Go's exhaustiveness check)
    si non hasDefault {
        result = scriptum("§§default:\n", result, g.ind())
        g.intraProfundum()
        result = scriptum("§§panic(\"unhandled case\")\n", result, g.ind())
        g.exiProfundum()
    }

    result = scriptum("§§}", result, g.ind())
    redde result
}

# Multi-discriminant: generates type assertions with if/else chain
functio genDiscerneMultiplex(lista<textus> discriminantStrs, lista<VariansCasus> casus, GoGenerator g) -> textus {
    varia result = ""
    varia first = verum

    ex casus fixum c {
        # Check if all patterns are wildcards
        varia allWildcards = verum
        ex c.exemplaria fixum pattern {
            si non pattern.estWildcard {
                allWildcards = falsum
                rumpe
            }
        }

        si allWildcards {
            # All wildcards - else block (no assertions needed)
            si first {
                result = scriptum("§{\n", g.ind())
            } secus {
                result = scriptum("§ else {\n", result)
            }
        } secus {
            # Generate type assertions for each non-wildcard pattern
            varia assertions = [] innatum lista<textus>
            varia okVars = [] innatum lista<textus>
            varia i = 0

            ex c.exemplaria fixum pattern {
                si non pattern.estWildcard {
                    fixum disc = discriminantStrs[i]
                    fixum tempVar = scriptum("_d§", i)
                    fixum okVar = scriptum("_ok§", i)
                    assertions.adde(scriptum("§§, § := §.(§)", g.ind(), tempVar, okVar, disc, pattern.variansNomen))
                    okVars.adde(okVar)
                }
                i += 1
            }

            # Add assertions before the if
            ex assertions fixum assertion {
                result = scriptum("§§\n", result, assertion)
            }

            # Generate if condition
            fixum condition = okVars.coniunge(" && ")
            si first {
                result = scriptum("§if § {\n", g.ind(), condition)
                first = falsum
            } secus {
                result = scriptum("§ else if § {\n", result, condition)
            }
        }

        g.intraProfundum()

        # Generate bindings for each pattern
        varia j = 0
        ex c.exemplaria fixum pattern {
            si non pattern.estWildcard {
                fixum tempVar = scriptum("_d§", j)
                result = scriptum("§§", result, genPatternBindingsMulti(pattern, tempVar, g))
            }
            j += 1
        }

        # Generate body
        result = scriptum("§§\n", result, genSententia(c.consequens, g))
        g.exiProfundum()
        result = scriptum("§§}", result, g.ind())
    }

    redde result
}

# Generate bindings for type switch (single discriminant)
# The typed value is available as _v
functio genPatternBindingsTypeSwitch(VariansExemplar pattern, GoGenerator g) -> textus {
    varia result = ""

    # Alias binding: casu Click ut c -> c := _v
    si nonnihil pattern.alias {
        result = scriptum("§§ := _v\n", g.ind(), pattern.alias)
    }

    # Field bindings: casu Click fixum x, y -> x := _v.X; y := _v.Y
    si pattern.vincula.longitudo() > 0 {
        ex pattern.vincula fixum vinculum {
            fixum fieldName = capitaliza(vinculum)
            result = scriptum("§§§ := _v.§\n", result, g.ind(), vinculum, fieldName)
        }
    }

    redde result
}

# Generate bindings for multi-discriminant (type assertions)
functio genPatternBindingsMulti(VariansExemplar pattern, textus tempVar, GoGenerator g) -> textus {
    varia result = ""

    # Alias binding: casu Click ut c -> c := _dN
    si nonnihil pattern.alias {
        result = scriptum("§§ := §\n", g.ind(), pattern.alias, tempVar)
    }

    # Field bindings: casu Click fixum x, y -> x := _dN.X; y := _dN.Y
    si pattern.vincula.longitudo() > 0 {
        ex pattern.vincula fixum vinculum {
            fixum fieldName = capitaliza(vinculum)
            result = scriptum("§§§ := §.§\n", result, g.ind(), vinculum, tempVar, fieldName)
        }
    }

    redde result
}

# Capitalize first letter for Go field access
functio capitaliza(textus s) -> textus {
    si s.longitudo() == 0 {
        redde s
    }
    fixum primum = s.sectio(0, 1) qua textus
    fixum first = primum.maiuscula()
    si s.longitudo() == 1 {
        redde first
    }
    redde scriptum("§§", first, s.sectio(1, s.longitudo()))
}
