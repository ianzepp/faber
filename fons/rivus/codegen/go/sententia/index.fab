# Go Statement Generator - Dispatch
#
# Routes statement AST nodes to their specific generators.

importa ex "../../../ast/sententia" privata Sententia
importa ex "../../../ast/sententia" privata Parametrum
importa ex "../../../ast/sententia" privata CampusDeclaratio
importa ex "../../../ast/sententia" privata ScribeGradus
importa ex "../../../ast/sententia" privata VariaGenus
importa ex "../../../ast/sententia" privata IteratioGenus
importa ex "../../../ast/sententia" privata EligeCasus
importa ex "../../../ast/sententia" privata VariansCasus
importa ex "../../../ast/sententia" privata VariansDeclaratio
importa ex "../../../ast/sententia" privata SeriesDestructuraElementum
importa ex "../../../ast/expressia" privata Expressia
importa ex "../nucleus" privata GoGenerator
importa ex "../expressia/index" privata genExpressia
importa ex "./functio" privata genFunctio
importa ex "./functio" privata genParametrum
importa ex "./scribe" privata genScribe
importa ex "./adfirma" privata genAdfirma
importa ex "./redde" privata genRedde
importa ex "./iace" privata genIace
importa ex "./incipit" privata genIncipit
importa ex "./incipit" privata genIncipiet
importa ex "./varia" privata genVaria
importa ex "./varia" privata genSeriesDestructura
importa ex "./si" privata genSi
importa ex "./dum" privata genDum
importa ex "./iteratio" privata genIteratio
importa ex "./fac" privata genFac
importa ex "./elige" privata genElige
importa ex "./discerne" privata genDiscerne
importa ex "./discretio" privata genDiscretio
importa ex "./genus" privata genGenus

# =============================================================================
# STATEMENT DISPATCH
# =============================================================================

# Generate Go code for a statement
@ publica
functio genSententia(in GoGenerator g, de Sententia stmt) -> textus {
    discerne stmt {
        # Block
        casu MassaSententia ut s {
            redde genMassa(g, s.corpus qua lista<Sententia>)
        }

        # Function declaration
        casu FunctioDeclaratio ut f {
            redde genFunctio(g, f)
        }

        # Variable declaration
        casu VariaSententia ut v {
            redde genVaria(g, v.species qua VariaGenus, v.nomen qua textus, v.externa qua bivalens, v.typus, v.valor, v.visibilitas)
        }

        # Array destructuring declaration
        casu SeriesDestructuraSententia ut s {
            redde genSeriesDestructura(g, s.species qua VariaGenus, s.elementa, s.fons qua Expressia)
        }

        # Type declarations
        casu GenusDeclaratio ut s {
            redde genGenus(g, s)
        }

        casu DiscretioDeclaratio ut d {
            redde genDiscretio(g, d.nomen qua textus, d.variantes qua lista<VariansDeclaratio>, d.generaParametra, d.visibilitas)
        }

        # Actions
        casu ScribeSententia ut s {
            redde genScribe(g, s.gradus qua ScribeGradus, s.argumenta qua lista<Expressia>)
        }

        casu AdfirmaSententia ut s {
            redde genAdfirma(g, s.condicio qua Expressia, s.nuntius)
        }

        casu ReddeSententia ut s {
            redde genRedde(g, s.valor)
        }

        casu IaceSententia ut s {
            redde genIace(g, s.argumentum, s.fatale qua bivalens)
        }

        casu RumpeSententia {
            redde scriptum("§break", g.ind())
        }

        casu PergeSententia {
            redde scriptum("§continue", g.ind())
        }

        casu TacetSententia {
            redde scriptum("§{}", g.ind())
        }

        casu ExpressiaSententia ut s {
            redde scriptum("§§", g.ind(), genExpressia(g, s.expressia))
        }

        # Entry points
        casu IncipitSententia ut s {
            redde genIncipit(g, s.corpus, s.ergo)
        }

        casu IncipietSententia ut s {
            redde genIncipiet(g, s.corpus, s.ergo)
        }

        # Cura (resource management) - for Go, we ignore arena allocation
        # The body statements should still be generated
        casu CuraSententia ut s {
            # For Go, cura...fit blocks become just the body statements
            # Resource cleanup is handled by Go's GC or defer patterns
            redde genSententia(g, s.corpus)
        }

        # Control flow
        casu SiSententia ut s {
            redde genSi(g, s.condicio qua Expressia, s.consequens qua Sententia, s.alternans)
        }

        casu DumSententia ut s {
            redde genDum(g, s.condicio qua Expressia, s.corpus)
        }

        casu IteratioSententia ut s {
            redde genIteratio(g, s.species qua IteratioGenus, s.variabilis, s.iterabile qua Expressia, s.corpus)
        }

        casu FacSententia ut s {
            redde genFac(g, s.corpus, s.condicio)
        }

        casu EligeSententia ut s {
            redde genElige(g, s.discriminans qua Expressia, s.casus qua lista<EligeCasus>, s.praedefinitum, s.cape)
        }

        casu DiscerneSententia ut s {
            redde genDiscerne(g, s.discriminantes qua lista<Expressia>, s.casus qua lista<VariansCasus>)
        }

        # Fail on unimplemented statement types
        ceterum {
            mori scriptum("Go codegen: unsupported statement type '§'", stmt.tag)
        }
    }
}

# =============================================================================
# BLOCK
# =============================================================================

@ publica
functio genMassa(in GoGenerator g, de lista<Sententia> corpus) -> textus {
    si corpus.longitudo() == 0 {
        redde ""
    }
    varia lines = [] innatum lista<textus>
    ex corpus fixum stmt {
        lines.appende(genSententia(g, stmt))
    }
    redde lines.coniunge("\n")
}
