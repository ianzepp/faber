# Go Statement Generator - Dispatch
#
# Routes statement AST nodes to their specific generators.

§ ex "../../../ast/sententia" importa Sententia, Parametrum, CampusDeclaratio, ScribeGradus, VariaGenus, IteratioGenus, EligeCasus, VariansCasus, VariansDeclaratio, SeriesDestructuraElementum
§ ex "../../../ast/expressia" importa Expressia
§ ex "../nucleus" importa GoGenerator
§ ex "../expressia/index" importa genExpressia
§ ex "./functio" importa genFunctio, genParametrum
§ ex "./scribe" importa genScribe
§ ex "./adfirma" importa genAdfirma
§ ex "./redde" importa genRedde
§ ex "./iace" importa genIace
§ ex "./incipit" importa genIncipit, genIncipiet
§ ex "./varia" importa genVaria, genSeriesDestructura
§ ex "./si" importa genSi
§ ex "./dum" importa genDum
§ ex "./iteratio" importa genIteratio
§ ex "./fac" importa genFac
§ ex "./elige" importa genElige
§ ex "./discerne" importa genDiscerne
§ ex "./discretio" importa genDiscretio
§ ex "./genus" importa genGenus

# =============================================================================
# STATEMENT DISPATCH
# =============================================================================

# Generate Go code for a statement
@ publica
functio genSententia(Sententia stmt, GoGenerator g) -> textus {
    discerne stmt {
        # Block
        casu MassaSententia ut s {
            redde genMassa(s.corpus qua lista<Sententia>, g)
        }

        # Function declaration
        casu FunctioDeclaratio ut f {
            redde genFunctio(f.nomen qua textus, f.generaParametra, f.parametra qua lista<Parametrum>, f.modificatores, f.reddeVerbum, f.typusReditus, f.corpus, f.asynca qua bivalens, f.generator qua bivalens, f.structor qua bivalens, f.visibilitas, f.abstracta qua bivalens, f.externa qua bivalens, g)
        }

        # Variable declaration
        casu VariaSententia ut v {
            redde genVaria(v.species qua VariaGenus, v.nomen qua textus, v.typus, v.valor, v.externa qua bivalens, v.visibilitas, g)
        }

        # Array destructuring declaration
        casu SeriesDestructuraSententia ut s {
            redde genSeriesDestructura(s.species qua VariaGenus, s.elementa, s.fons qua Expressia, g)
        }

        # Type declarations
        casu GenusDeclaratio ut s {
            redde genGenus(s.nomen qua textus, s.generaParametra, s.extendit, s.implet, s.abstractum qua bivalens, s.campi qua lista<CampusDeclaratio>, s.structor, s.methodi, s.visibilitas, g)
        }

        casu DiscretioDeclaratio ut d {
            redde genDiscretio(d.nomen qua textus, d.generaParametra, d.variantes qua lista<VariansDeclaratio>, d.visibilitas, g)
        }

        # Actions
        casu ScribeSententia ut s {
            redde genScribe(s.gradus qua ScribeGradus, s.argumenta qua lista<Expressia>, g)
        }

        casu AdfirmaSententia ut s {
            redde genAdfirma(s.condicio qua Expressia, s.nuntius, g)
        }

        casu ReddeSententia ut s {
            redde genRedde(s.valor, g)
        }

        casu IaceSententia ut s {
            redde genIace(s.argumentum, s.fatale qua bivalens, g)
        }

        casu RumpeSententia {
            redde scriptum("§break", g.ind())
        }

        casu PergeSententia {
            redde scriptum("§continue", g.ind())
        }

        casu TacetSententia {
            redde scriptum("§{}", g.ind())
        }

        casu ExpressiaSententia ut s {
            redde scriptum("§§", g.ind(), genExpressia(s.expressia, g))
        }

        # Entry points
        casu IncipitSententia ut s {
            redde genIncipit(s.corpus, s.ergo, g)
        }

        casu IncipietSententia ut s {
            redde genIncipiet(s.corpus, s.ergo, g)
        }

        # Cura (resource management) - for Go, we ignore arena allocation
        # The body statements should still be generated
        casu CuraSententia ut s {
            # For Go, cura...fit blocks become just the body statements
            # Resource cleanup is handled by Go's GC or defer patterns
            redde genSententia(s.corpus, g)
        }

        # Control flow
        casu SiSententia ut s {
            redde genSi(s.condicio qua Expressia, s.consequens qua Sententia, s.alternans, g)
        }

        casu DumSententia ut s {
            redde genDum(s.condicio qua Expressia, s.corpus, g)
        }

        casu IteratioSententia ut s {
            redde genIteratio(s.species qua IteratioGenus, s.variabilis, s.iterabile qua Expressia, s.corpus, g)
        }

        casu FacSententia ut s {
            redde genFac(s.corpus, s.condicio, g)
        }

        casu EligeSententia ut s {
            redde genElige(s.discriminans qua Expressia, s.casus qua lista<EligeCasus>, s.praedefinitum, s.cape, g)
        }

        casu DiscerneSententia ut s {
            redde genDiscerne(s.discriminantes qua lista<Expressia>, s.casus qua lista<VariansCasus>, g)
        }

        # Fail on unimplemented statement types
        ceterum {
            mori scriptum("Go codegen: unsupported statement type '§'", stmt.tag)
        }
    }
}

# =============================================================================
# BLOCK
# =============================================================================

@ publica
functio genMassa(lista<Sententia> corpus, GoGenerator g) -> textus {
    si corpus.longitudo() == 0 {
        redde ""
    }
    varia lines = [] innatum lista<textus>
    ex corpus fixum stmt {
        lines.adde(genSententia(stmt, g))
    }
    redde lines.coniunge("\n")
}
