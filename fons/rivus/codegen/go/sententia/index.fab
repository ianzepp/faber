# Go Statement Generator - Dispatch
#
# Routes statement AST nodes to their specific generators.

§ ex "../../../ast/sententia" importa Sententia, Parametrum, CampusDeclaratio, ScribeGradus, VariaGenus, IteratioGenus, EligeCasus, VariansCasus, VariansDeclaratio, SeriesDestructuraElementum
§ ex "../../../ast/expressia" importa Expressia
§ ex "../nucleus" importa GoGenerator
§ ex "../expressia/index" importa genExpressia
§ ex "./functio" importa genFunctio, genParametrum
§ ex "./scribe" importa genScribe
§ ex "./adfirma" importa genAdfirma
§ ex "./redde" importa genRedde
§ ex "./iace" importa genIace
§ ex "./incipit" importa genIncipit, genIncipiet
§ ex "./varia" importa genVaria, genSeriesDestructura
§ ex "./si" importa genSi
§ ex "./dum" importa genDum
§ ex "./iteratio" importa genIteratio
§ ex "./fac" importa genFac
§ ex "./elige" importa genElige
§ ex "./discerne" importa genDiscerne
§ ex "./discretio" importa genDiscretio
§ ex "./genus" importa genGenus

# =============================================================================
# STATEMENT DISPATCH
# =============================================================================

# Generate Go code for a statement
@ publica
functio genSententia(in GoGenerator g, de Sententia stmt) -> textus {
    discerne stmt {
        # Block
        casu MassaSententia ut s {
            redde genMassa(g, s.corpus qua lista<Sententia>)
        }

        # Function declaration
        casu FunctioDeclaratio ut f {
            redde genFunctio(g, f)
        }

        # Variable declaration
        casu VariaSententia ut v {
            redde genVaria(g, v.species qua VariaGenus, v.nomen qua textus, v.externa qua bivalens, v.typus, v.valor, v.visibilitas)
        }

        # Array destructuring declaration
        casu SeriesDestructuraSententia ut s {
            redde genSeriesDestructura(g, s.species qua VariaGenus, s.elementa, s.fons qua Expressia)
        }

        # Type declarations
        casu GenusDeclaratio ut s {
            redde genGenus(g, s)
        }

        casu DiscretioDeclaratio ut d {
            redde genDiscretio(g, d.nomen qua textus, d.variantes qua lista<VariansDeclaratio>, d.generaParametra, d.visibilitas)
        }

        # Actions
        casu ScribeSententia ut s {
            redde genScribe(g, s.gradus qua ScribeGradus, s.argumenta qua lista<Expressia>)
        }

        casu AdfirmaSententia ut s {
            redde genAdfirma(g, s.condicio qua Expressia, s.nuntius)
        }

        casu ReddeSententia ut s {
            redde genRedde(g, s.valor)
        }

        casu IaceSententia ut s {
            redde genIace(g, s.argumentum, s.fatale qua bivalens)
        }

        casu RumpeSententia {
            redde scriptum("§break", g.ind())
        }

        casu PergeSententia {
            redde scriptum("§continue", g.ind())
        }

        casu TacetSententia {
            redde scriptum("§{}", g.ind())
        }

        casu ExpressiaSententia ut s {
            redde scriptum("§§", g.ind(), genExpressia(g, s.expressia))
        }

        # Entry points
        casu IncipitSententia ut s {
            redde genIncipit(g, s.corpus, s.ergo)
        }

        casu IncipietSententia ut s {
            redde genIncipiet(g, s.corpus, s.ergo)
        }

        # Cura (resource management) - for Go, we ignore arena allocation
        # The body statements should still be generated
        casu CuraSententia ut s {
            # For Go, cura...fit blocks become just the body statements
            # Resource cleanup is handled by Go's GC or defer patterns
            redde genSententia(g, s.corpus)
        }

        # Control flow
        casu SiSententia ut s {
            redde genSi(g, s.condicio qua Expressia, s.consequens qua Sententia, s.alternans)
        }

        casu DumSententia ut s {
            redde genDum(g, s.condicio qua Expressia, s.corpus)
        }

        casu IteratioSententia ut s {
            redde genIteratio(g, s.species qua IteratioGenus, s.variabilis, s.iterabile qua Expressia, s.corpus)
        }

        casu FacSententia ut s {
            redde genFac(g, s.corpus, s.condicio)
        }

        casu EligeSententia ut s {
            redde genElige(g, s.discriminans qua Expressia, s.casus qua lista<EligeCasus>, s.praedefinitum, s.cape)
        }

        casu DiscerneSententia ut s {
            redde genDiscerne(g, s.discriminantes qua lista<Expressia>, s.casus qua lista<VariansCasus>)
        }

        # Fail on unimplemented statement types
        ceterum {
            mori scriptum("Go codegen: unsupported statement type '§'", stmt.tag)
        }
    }
}

# =============================================================================
# BLOCK
# =============================================================================

@ publica
functio genMassa(in GoGenerator g, de lista<Sententia> corpus) -> textus {
    si corpus.longitudo() == 0 {
        redde ""
    }
    varia lines = [] innatum lista<textus>
    ex corpus fixum stmt {
        lines.appende(genSententia(g, stmt))
    }
    redde lines.coniunge("\n")
}
