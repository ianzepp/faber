# Go Statement Generator - Dispatch
#
# Routes statement AST nodes to their specific generators.

ex "../../../ast/sententia" importa Sententia, Parametrum, ScribeGradus
ex "../../../ast/expressia" importa Expressia
ex "../nucleus" importa GoGenerator
ex "../expressia/index" importa genExpressia
ex "./functio" importa genFunctio, genParametrum
ex "./scribe" importa genScribe
ex "./redde" importa genRedde
ex "./incipit" importa genIncipit, genIncipiet

# =============================================================================
# STATEMENT DISPATCH
# =============================================================================

# Generate Go code for a statement
@ publica
functio genSententia(Sententia stmt, GoGenerator g) -> textus {
    discerne stmt {
        # Block
        casu MassaSententia ut s {
            redde genMassa(s.corpus qua lista<Sententia>, g)
        }

        # Function declaration
        casu FunctioDeclaratio ut f {
            redde genFunctio(f.nomen qua textus, f.generaParametra, f.parametra qua lista<Parametrum>, f.reddeVerbum, f.typusReditus, f.corpus, f.asynca qua bivalens, f.generator qua bivalens, f.structor qua bivalens, f.visibilitas, f.abstracta qua bivalens, f.externa qua bivalens, g)
        }

        # Actions
        casu ScribeSententia ut s {
            redde genScribe(s.gradus qua ScribeGradus, s.argumenta qua lista<Expressia>, g)
        }

        casu ReddeSententia ut s {
            redde genRedde(s.valor, g)
        }

        casu RumpeSententia {
            redde scriptum("§break", g.ind())
        }

        casu PergeSententia {
            redde scriptum("§continue", g.ind())
        }

        casu ExpressiaSententia ut s {
            redde scriptum("§§", g.ind(), genExpressia(s.expressia, g))
        }

        # Entry points
        casu IncipitSententia ut s {
            redde genIncipit(s.corpus, s.ergo, g)
        }

        casu IncipietSententia ut s {
            redde genIncipiet(s.corpus, s.ergo, g)
        }

        # Cura (resource management) - for Go, we ignore arena allocation
        # The body statements should still be generated
        casu CuraSententia ut s {
            # For Go, cura...fit blocks become just the body statements
            # Resource cleanup is handled by Go's GC or defer patterns
            redde genSententia(s.corpus qua Sententia, g)
        }

        # Fallback for unimplemented statement types
        ceterum {
            redde scriptum("§// TODO: unhandled statement: §", g.ind(), stmt.tag)
        }
    }
}

# =============================================================================
# BLOCK
# =============================================================================

@ publica
functio genMassa(lista<Sententia> corpus, GoGenerator g) -> textus {
    si corpus.longitudo() == 0 {
        redde ""
    }
    varia lines = [] innatum lista<textus>
    ex corpus pro stmt {
        lines.adde(genSententia(stmt, g))
    }
    redde lines.coniunge("\n")
}
