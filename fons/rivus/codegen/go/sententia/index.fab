# Go Statement Generator - Dispatch
#
# Routes statement AST nodes to their specific generators.

ex "../../../ast/sententia" importa Sententia, Parametrum, ScribeGradus, VariaGenus, IteratioGenus, EligeCasus, VariansCasus, VariansDeclaratio
ex "../../../ast/expressia" importa Expressia
ex "../nucleus" importa GoGenerator
ex "../expressia/index" importa genExpressia
ex "./functio" importa genFunctio, genParametrum
ex "./scribe" importa genScribe
ex "./redde" importa genRedde
ex "./incipit" importa genIncipit, genIncipiet
ex "./varia" importa genVaria
ex "./si" importa genSi
ex "./dum" importa genDum
ex "./iteratio" importa genIteratio
ex "./fac" importa genFac
ex "./elige" importa genElige
ex "./discerne" importa genDiscerne
ex "./discretio" importa genDiscretio

# =============================================================================
# STATEMENT DISPATCH
# =============================================================================

# Generate Go code for a statement
@ publica
functio genSententia(Sententia stmt, GoGenerator g) -> textus {
    discerne stmt {
        # Block
        casu MassaSententia ut s {
            redde genMassa(s.corpus qua lista<Sententia>, g)
        }

        # Function declaration
        casu FunctioDeclaratio ut f {
            redde genFunctio(f.nomen qua textus, f.generaParametra, f.parametra qua lista<Parametrum>, f.reddeVerbum, f.typusReditus, f.corpus, f.asynca qua bivalens, f.generator qua bivalens, f.structor qua bivalens, f.visibilitas, f.abstracta qua bivalens, f.externa qua bivalens, g)
        }

        # Variable declaration
        casu VariaSententia ut v {
            redde genVaria(v.species qua VariaGenus, v.nomen qua textus, v.typus, v.valor, v.externa qua bivalens, v.visibilitas, g)
        }

        # Type declarations
        casu DiscretioDeclaratio ut d {
            redde genDiscretio(d.nomen qua textus, d.generaParametra, d.variantes qua lista<VariansDeclaratio>, d.visibilitas, g)
        }

        # Actions
        casu ScribeSententia ut s {
            redde genScribe(s.gradus qua ScribeGradus, s.argumenta qua lista<Expressia>, g)
        }

        casu ReddeSententia ut s {
            redde genRedde(s.valor, g)
        }

        casu RumpeSententia {
            redde scriptum("§break", g.ind())
        }

        casu PergeSententia {
            redde scriptum("§continue", g.ind())
        }

        casu ExpressiaSententia ut s {
            redde scriptum("§§", g.ind(), genExpressia(s.expressia, g))
        }

        # Entry points
        casu IncipitSententia ut s {
            redde genIncipit(s.corpus, s.ergo, g)
        }

        casu IncipietSententia ut s {
            redde genIncipiet(s.corpus, s.ergo, g)
        }

        # Cura (resource management) - for Go, we ignore arena allocation
        # The body statements should still be generated
        casu CuraSententia ut s {
            # For Go, cura...fit blocks become just the body statements
            # Resource cleanup is handled by Go's GC or defer patterns
            redde genSententia(s.corpus qua Sententia, g)
        }

        # Control flow
        casu SiSententia ut s {
            redde genSi(s.condicio qua Expressia, s.consequens qua Sententia, s.alternans, g)
        }

        casu DumSententia ut s {
            redde genDum(s.condicio qua Expressia, s.corpus qua Sententia, g)
        }

        casu IteratioSententia ut s {
            redde genIteratio(s.species qua IteratioGenus, s.variabilis qua textus, s.iterabile qua Expressia, s.corpus qua Sententia, g)
        }

        casu FacSententia ut s {
            redde genFac(s.corpus qua Sententia, s.condicio, g)
        }

        casu EligeSententia ut s {
            redde genElige(s.discriminans qua Expressia, s.casus qua lista<EligeCasus>, s.praedefinitum, s.cape, g)
        }

        casu DiscerneSententia ut s {
            redde genDiscerne(s.discriminantes qua lista<Expressia>, s.casus qua lista<VariansCasus>, g)
        }

        # Fail on unimplemented statement types
        ceterum {
            iace scriptum("Go codegen: unsupported statement type '§'", stmt.tag)
        }
    }
}

# =============================================================================
# BLOCK
# =============================================================================

@ publica
functio genMassa(lista<Sententia> corpus, GoGenerator g) -> textus {
    si corpus.longitudo() == 0 {
        redde ""
    }
    varia lines = [] innatum lista<textus>
    ex corpus pro stmt {
        lines.adde(genSententia(stmt, g))
    }
    redde lines.coniunge("\n")
}
