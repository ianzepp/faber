# Go Code Generator - Public API
#
# Entry point for generating Go from Faber AST.
#
# TRANSFORMS:
#   lista<Sententia> -> Go source code string

importa ex "../../ast/sententia" privata Sententia
importa ex "./nucleus" privata GoGenerator
importa ex "./nucleus" privata creaGoGenerator
importa ex "./sententia/index" privata genSententia

# =============================================================================
# PUBLIC API
# =============================================================================

# Generate Go source code from a list of statements
@ publica
functio generateGo(de lista<Sententia> corpus) -> textus {
    fixum g = creaGoGenerator()

    # Separate declarations from executables, preserving source order
    varia declarationes = [] innatum lista<Sententia>
    varia mainSententiae = [] innatum lista<Sententia>

    itera ex corpus fixum stmt {
        discerne stmt {
            # Entry points - inline their body statements into func main
            casu IncipitSententia ut s {
                si nonnihil s.corpus {
                    mainSententiae.appende(s.corpus)
                }
                si nonnihil s.ergo {
                    mainSententiae.appende(s.ergo qua Sententia)
                }
            }

            casu IncipietSententia ut s {
                si nonnihil s.corpus {
                    mainSententiae.appende(s.corpus)
                }
                si nonnihil s.ergo {
                    mainSententiae.appende(s.ergo qua Sententia)
                }
            }

            # Declarations (top-level)
            casu FunctioDeclaratio { declarationes.appende(stmt) }
            casu GenusDeclaratio { declarationes.appende(stmt) }
            casu DiscretioDeclaratio { declarationes.appende(stmt) }
            casu OrdoDeclaratio { declarationes.appende(stmt) }
            casu PactumDeclaratio { declarationes.appende(stmt) }
            casu TypusAliasDeclaratio { declarationes.appende(stmt) }
            casu ImportaSententia { declarationes.appende(stmt) }
            casu VariaSententia { declarationes.appende(stmt) }

            # Everything else is executable
            ceterum {
                mainSententiae.appende(stmt)
            }
        }
    }

    # Generate declarations
    varia declarationesLines = [] innatum lista<textus>
    itera ex declarationes fixum s {
        declarationesLines.appende(genSententia(g, s))
    }
    fixum declsBody = declarationesLines.coniunge("\n")

    # Generate func main
    varia mainBody = ""
    si mainSententiae.longitudo() == 0 {
        mainBody = "func main() {}"
    } secus {
        g.intraProfundum()
        varia mainLines = [] innatum lista<textus>
        itera ex mainSententiae fixum s {
            mainLines.appende(genSententia(g, s))
        }
        g.exiProfundum()
        fixum mainContent = mainLines.coniunge("\n")
        mainBody = scriptum("func main() {\n§\n}", mainContent)
    }

    # Combine: preamble + declarations + main
    fixum preamble = genPreamble(g)

    varia parts = [] innatum lista<textus>
    si preamble != "" {
        parts.appende(preamble)
    }
    si declsBody != "" {
        parts.appende(declsBody)
    }
    parts.appende(mainBody)

    redde parts.coniunge("\n\n")
}

# =============================================================================
# PREAMBLE GENERATION
# =============================================================================

# Generate Go preamble (package declaration and imports)
functio genPreamble(in GoGenerator g) -> textus {
    varia parts = [] innatum lista<textus>

    # Package declaration - always main for executables
    parts.appende("package main")

    # Imports based on required features
    varia imports = [] innatum lista<textus>

    si g.requisita.fmt {
        imports.appende("\"fmt\"")
    }

    si g.requisita.errors {
        imports.appende("\"errors\"")
    }

    si imports.longitudo() > 0 {
        si imports.longitudo() == 1 {
            parts.appende(scriptum("import §", imports[0]))
        } secus {
            parts.appende(scriptum("import (\n\t§\n)", imports.coniunge("\n\t")))
        }
    }

    redde parts.coniunge("\n\n")
}
