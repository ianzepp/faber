# Go Code Generator - Public API
#
# Entry point for generating Go from Faber AST.
#
# TRANSFORMS:
#   lista<Sententia> -> Go source code string

§ ex "../../ast/sententia" importa Sententia
§ ex "./nucleus" importa GoGenerator, creaGoGenerator
§ ex "./sententia/index" importa genSententia

# =============================================================================
# PUBLIC API
# =============================================================================

# Generate Go source code from a list of statements
@ publica
functio generateGo(lista<Sententia> corpus) -> textus {
    fixum g = creaGoGenerator()

    # Separate declarations from executables, preserving source order
    varia declarationes = [] innatum lista<Sententia>
    varia mainSententiae = [] innatum lista<Sententia>

    ex corpus pro stmt {
        discerne stmt {
            # Entry points - inline their body statements into func main
            casu IncipitSententia ut s {
                si nonnihil s.corpus {
                    mainSententiae.adde(s.corpus)
                }
                si nonnihil s.ergo {
                    mainSententiae.adde(s.ergo qua Sententia)
                }
            }

            casu IncipietSententia ut s {
                si nonnihil s.corpus {
                    mainSententiae.adde(s.corpus)
                }
                si nonnihil s.ergo {
                    mainSententiae.adde(s.ergo qua Sententia)
                }
            }

            # Declarations (top-level)
            casu FunctioDeclaratio { declarationes.adde(stmt) }
            casu GenusDeclaratio { declarationes.adde(stmt) }
            casu DiscretioDeclaratio { declarationes.adde(stmt) }
            casu OrdoDeclaratio { declarationes.adde(stmt) }
            casu PactumDeclaratio { declarationes.adde(stmt) }
            casu TypusAliasDeclaratio { declarationes.adde(stmt) }
            casu ImportaSententia { declarationes.adde(stmt) }
            casu VariaSententia { declarationes.adde(stmt) }

            # Everything else is executable
            ceterum {
                mainSententiae.adde(stmt)
            }
        }
    }

    # Generate declarations
    varia declarationesLines = [] innatum lista<textus>
    ex declarationes pro s {
        declarationesLines.adde(genSententia(s, g))
    }
    fixum declsBody = declarationesLines.coniunge("\n")

    # Generate func main
    varia mainBody = ""
    si mainSententiae.longitudo() == 0 {
        mainBody = "func main() {}"
    } secus {
        g.intraProfundum()
        varia mainLines = [] innatum lista<textus>
        ex mainSententiae pro s {
            mainLines.adde(genSententia(s, g))
        }
        g.exiProfundum()
        fixum mainContent = mainLines.coniunge("\n")
        mainBody = scriptum("func main() {\n§\n}", mainContent)
    }

    # Combine: preamble + declarations + main
    fixum preamble = genPreamble(g)

    varia parts = [] innatum lista<textus>
    si preamble != "" {
        parts.adde(preamble)
    }
    si declsBody != "" {
        parts.adde(declsBody)
    }
    parts.adde(mainBody)

    redde parts.coniunge("\n\n")
}

# =============================================================================
# PREAMBLE GENERATION
# =============================================================================

# Generate Go preamble (package declaration and imports)
functio genPreamble(GoGenerator g) -> textus {
    varia parts = [] innatum lista<textus>

    # Package declaration - always main for executables
    parts.adde("package main")

    # Imports based on required features
    varia imports = [] innatum lista<textus>

    si g.requisita.fmt {
        imports.adde("\"fmt\"")
    }

    si g.requisita.errors {
        imports.adde("\"errors\"")
    }

    si imports.longitudo() > 0 {
        si imports.longitudo() == 1 {
            parts.adde(scriptum("import §", imports[0]))
        } secus {
            parts.adde(scriptum("import (\n\t§\n)", imports.coniunge("\n\t")))
        }
    }

    redde parts.coniunge("\n\n")
}
