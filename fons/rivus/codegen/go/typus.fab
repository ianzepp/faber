# Go Type Mapping - Latin types to Go types
#
# Maps Latin type names to their Go equivalents.

importa ex "../../ast/typus" privata TypusAnnotatio
importa ex "../../ast/typus" privata TypusParametrum
importa ex "./nucleus" privata GoGenerator

# =============================================================================
# TYPE MAPPING
# =============================================================================

# Map a Latin type name to Go type name
@ publica
functio mappaNomenTypi(de textus nomen) -> textus {
    elige nomen {
        # Primitives
        casu "textus" reddit "string"
        casu "numerus" reddit "int64"
        casu "fractus" reddit "float64"
        casu "bivalens" reddit "bool"
        casu "vacuum" reddit ""
        casu "nihil" reddit ""  # void return type

        # Binary
        casu "octeti" reddit "[]byte"

        # Collections - base names only, generics handled separately
        casu "lista" reddit "[]"
        casu "tabula" reddit "map"
        casu "copia" reddit "map"

        # Error
        casu "erratum" reddit "error"

        # Any/unknown
        casu "ignotum" reddit "interface{}"
        casu "objectum" reddit "interface{}"
    }

    # User-defined type: pass through unchanged
    redde nomen
}

# =============================================================================
# TYPE GENERATION
# =============================================================================

# Generate Go type from type annotation
@ publica
functio genTypus(in GoGenerator g, de TypusAnnotatio adnotatio) -> textus {
    fixum base = mappaNomenTypi(adnotatio.nomen)

    # Handle vacuum (void) - returns empty string
    si adnotatio.nomen == "vacuum" {
        redde ""
    }

    # Handle generic types
    si nonnihil adnotatio.typusParametra {
        fixum parametra = adnotatio.typusParametra
        si parametra.longitudo() > 0 {
            # lista<T> -> []T
            si adnotatio.nomen == "lista" {
                varia elemType = "interface{}"
                discerne parametra[0] {
                    casu Typus ut t {
                        elemType = genTypus(g, t.adnotatio)
                    }
                    casu _ tacet
                }
                redde scriptum("[]§", elemType)
            }

            # tabula<K,V> -> map[K]V
            si adnotatio.nomen == "tabula" {
                varia keyType = "string"
                varia valueType = "interface{}"
                si parametra.longitudo() >= 1 {
                    discerne parametra[0] {
                        casu Typus ut t {
                            keyType = genTypus(g, t.adnotatio)
                        }
                        casu _ tacet
                    }
                }
                si parametra.longitudo() >= 2 {
                    discerne parametra[1] {
                        casu Typus ut t {
                            valueType = genTypus(g, t.adnotatio)
                        }
                        casu _ tacet
                    }
                }
                redde scriptum("map[§]§", keyType, valueType)
            }

            # copia<T> -> map[T]struct{}
            si adnotatio.nomen == "copia" {
                varia elemType = "interface{}"
                discerne parametra[0] {
                    casu Typus ut t {
                        elemType = genTypus(g, t.adnotatio)
                    }
                    casu _ tacet
                }
                redde scriptum("map[§]struct{}", elemType)
            }
        }
    }

    # Handle nullable: textus? -> *string
    si adnotatio.nullabilis {
        redde scriptum("*§", base)
    }

    redde base
}

# Generate Go zero value for a type annotation
@ publica
functio zeroValueForType(de TypusAnnotatio adnotatio, in GoGenerator g) -> textus {
    # Nullables and pointer-like types default to nil
    si adnotatio.nullabilis {
        redde "nil"
    }

    elige adnotatio.nomen {
        casu "numerus" reddit "0"
        casu "fractus" reddit "0.0"
        casu "bivalens" reddit "false"
        casu "textus" reddit "\"\""
        casu "vacuum" reddit "nil"
        casu "nihil" reddit "nil"
        casu "erratum" reddit "nil"
        casu "lista" reddit "nil"
        casu "tabula" reddit "nil"
        casu "copia" reddit "nil"
        casu "ignotum" reddit "nil"
        casu "objectum" reddit "nil"
    }

    fixum typeName = genTypus(g, adnotatio)
    si typeName == "" {
        redde "nil"
    }
    si typeName == "interface{}" {
        redde "nil"
    }
    si typeName.sectio(0, 1) == "*" {
        redde "nil"
    }
    si typeName.sectio(0, 2) == "[]" {
        redde "nil"
    }
    si typeName.sectio(0, 4) == "map[" {
        redde "nil"
    }

    redde scriptum("§{}", typeName)
}

# Generate a single type parameter
@ publica
functio genTypusParametrum(in GoGenerator g, de TypusParametrum param) -> si textus {
    discerne param {
        casu Typus ut p {
            redde genTypus(g, p.adnotatio)
        }
        casu Littera {
            # Ignore numeric parameters
            redde nihil
        }
    }
    redde nihil
}
