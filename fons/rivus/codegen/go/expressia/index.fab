# Go Expression Generator - Dispatch
#
# Routes expression AST nodes to their specific generators.

§ ex "../../../ast/expressia" importa Expressia, LitteraGenus, ObiectumProprietas, ClausuraParametrum, ClausuraCorpus
§ ex "../../../ast/sententia" importa Sententia, VariaGenus
§ ex "../../../ast/typus" importa TypusAnnotatio
§ ex "../nucleus" importa GoGenerator
§ ex "../typus" importa genTypus
§ ex "./littera" importa genLittera
§ ex "./scriptum" importa genScriptum

# =============================================================================
# EXPRESSION DISPATCH
# =============================================================================

# Generate Go code for an expression
@ publica
functio genExpressia(in GoGenerator g, de Expressia expr) -> textus {
    discerne expr {
        # Identifiers
        casu Nomen ut e {
            redde e.valor qua textus
        }

        casu EgoExpressia {
            # Go uses explicit receiver names, not 'this'
            # For now, assume receiver is named in function scope
            redde "this"
        }

        # Literals
        casu Littera ut e {
            redde genLittera(e.species qua LitteraGenus, e.crudus qua textus)
        }

        # Binary operations
        casu BinariaExpressia ut e {
            fixum sinister = genExpressia(g, e.sinister)
            fixum dexter = genExpressia(g, e.dexter)
            varia signum = e.signum qua textus

            # Normalize keyword operators to Go equivalents
            elige signum {
                casu "et" { signum = "&&" }
                casu "aut" { signum = "||" }
                casu "vel" {
                    # WHY: Go lacks nullish coalescing operator. Generate inline func that
                    # returns left value when non-nil, otherwise returns right fallback.
                    # Optional chaining yields interface{}, so check via != nil.
                    redde scriptum("func() interface{} { if _left := §; _left != nil { return _left }; return § }()", sinister, dexter)
                }
            }

            redde scriptum("(§ § §)", sinister, signum, dexter)
        }

        # Unary operations
        casu UnariaExpressia ut e {
            fixum arg = genExpressia(g, e.argumentum)
            redde scriptum("§§", e.signum, arg)
        }

        # Function calls
        casu VocatioExpressia ut e {
            varia args = [] innatum lista<textus>
            ex (e.argumenta qua lista<Expressia>) fixum arg {
                args.adde(genExpressia(g, arg))
            }
            redde scriptum("§(§)", genExpressia(g, e.vocatum), args.coniunge(", "))
        }

        # Member access
        casu MembrumExpressia ut e {
            # WHY: Optional chaining requires flattening nested chains to avoid type issues
            si e.optivum qua bivalens {
                redde genOptionalMembrum(g, e)
            }

            fixum obj = genExpressia(g, e.obiectum)
            si e.computatum qua bivalens {
                fixum idx = genExpressia(g, e.proprietas)
                redde scriptum("§[§]", obj, idx)
            }
            fixum prop = genExpressia(g, e.proprietas)
            redde scriptum("§.§", obj, prop)
        }

        # Format strings
        casu ScriptumExpressia ut e {
            redde genScriptum(g, e.exemplar qua textus, e.argumenta qua lista<Expressia>)
        }

        # Arrays
        casu SeriesExpressia ut e {
            varia items = [] innatum lista<textus>
            ex (e.elementa qua lista<Expressia>) fixum elem {
                items.adde(genExpressia(g, elem))
            }

            # WHY: Go slice literals must be typed. Infer simple literal element types
            # to avoid generating []interface{} where a typed slice is expected.
            fixum elemTypus = inferSeriesElemTypus(e.elementa qua lista<Expressia>)
            redde scriptum("[]§{§}", elemTypus, items.coniunge(", "))
        }

        # Object literals
        casu ObiectumExpressia ut e {
            varia props = [] innatum lista<textus>
            varia habetDispersum = falsum
            ex (e.proprietates qua lista<ObiectumProprietas>) fixum prop {
                si prop.computatum {
                    mori "Go codegen: unsupported object property (computed key)"
                }
                si prop.dispersum {
                    habetDispersum = verum
                    perge
                }
                fixum key = genObiectumClavis(g, prop.clavis)
                fixum val = genExpressia(g, prop.valor)
                props.adde(scriptum("§: §", key, val))
            }

            si props.longitudo() == 0 {
                si habetDispersum {
                    redde genObiectumDispersum(g, e.proprietates qua lista<ObiectumProprietas>)
                }
                redde "map[string]interface{}{}"
            }
            si habetDispersum {
                redde genObiectumDispersum(g, e.proprietates qua lista<ObiectumProprietas>)
            }
            redde scriptum("map[string]interface{}{§}", props.coniunge(", "))
        }

        # Conditional expression (ternary)
        casu CondicioExpressia ut e {
            # Go doesn't have ternary operator - emit as inline func
            # For simple cases this works; complex cases need statement form
            fixum cond = genExpressia(g, e.condicio)
            fixum cons = genExpressia(g, e.consequens)
            fixum alt = genExpressia(g, e.alternans)
            g.requisita.fmt = verum
            redde scriptum("func() interface{} { if § { return § }; return § }()", cond, cons, alt)
        }

        # Assignment expression
        casu AssignatioExpressia ut e {
            fixum sinister = genExpressia(g, e.sinister)
            fixum dexter = genExpressia(g, e.dexter)
            redde scriptum("§ § §", sinister, e.signum, dexter)
        }

        # Discretio construction
        casu FingeExpressia ut e {
            # finge Click { x: 10, y: 20 } -> Click{X: 10, Y: 20}
            varia props = [] innatum lista<textus>
            ex (e.campi qua lista<ObiectumProprietas>) fixum campo {
                fixum key = genExpressia(g, campo.clavis)
                fixum keyCapitalized = capitaliza(key)
                fixum val = genExpressia(g, campo.valor)
                props.adde(scriptum("§: §", keyCapitalized, val))
            }
            si props.longitudo() == 0 {
                redde scriptum("§{}", e.variansNomen)
            }
            redde scriptum("§{§}", e.variansNomen, props.coniunge(", "))
        }

        # Clausura
        casu ClausuraExpressia ut e {
            varia params = [] innatum lista<textus>
            ex (e.parametra qua lista<ClausuraParametrum>) fixum p {
                si nonnihil p.typus {
                    params.adde(scriptum("§ §", p.nomen, genTypus(g, p.typus novum TypusAnnotatio)))
                } secus {
                    params.adde(scriptum("§ interface{}", p.nomen))
                }
            }

            discerne e.corpus {
                casu Massa ut m {
                    discerne m.valor {
                        casu MassaSententia ut body {
                            g.intraProfundum()
                            fixum rendered = genClausuraMassa(g, body.corpus)
                            g.exiProfundum()
                            si rendered == "" {
                                redde scriptum("func(§) interface{} { }", params.coniunge(", "))
                            }
                            redde scriptum("func(§) interface{} {\n§\n§}", params.coniunge(", "), rendered, g.ind())
                        }
                        casu _ { }
                    }
                }
                casu Expr ut expr {
                    redde scriptum("func(§) interface{} { return § }", params.coniunge(", "), genExpressia(g, expr.valor))
                }
            }

            redde scriptum("func(§) interface{} { return § }", params.coniunge(", "), genExpressia(g, finge Littera { locus: e.locus, species: LitteraGenus.Nihil, crudus: "nihil" } qua Expressia))
        }

        # New instance creation
        casu NovumExpressia ut e {
            varia args = [] innatum lista<textus>
            ex (e.argumenta qua lista<Expressia>) fixum arg {
                args.adde(genExpressia(g, arg))
            }
            si nonnihil e.initor {
                args.adde(genExpressia(g, e.initor))
            }
            fixum ctor = genConstructorNomen(g, e.vocatum)
            redde scriptum("§(§)", ctor, args.coniunge(", "))
        }

        # Fail on unimplemented expression types
        ceterum {
            mori scriptum("Go codegen: unsupported expression type '§'", expr.tag)
        }
    }
}

functio inferSeriesElemTypus(de lista<Expressia> elementa) -> textus {
    si elementa.longitudo() == 0 {
        redde "interface{}"
    }

    varia viditTextus = falsum
    varia viditNumerus = falsum
    varia viditFractus = falsum
    varia viditBivalens = falsum

    ex elementa fixum elem {
        discerne elem {
            casu Littera ut l {
                elige l.species {
                    casu LitteraGenus.Numerus {
                        viditNumerus = verum
                    }
                    casu LitteraGenus.Fractus {
                        viditFractus = verum
                    }
                    casu LitteraGenus.Textus {
                        viditTextus = verum
                    }
                    casu LitteraGenus.Verum {
                        viditBivalens = verum
                    }
                    casu LitteraGenus.Falsum {
                        viditBivalens = verum
                    }
                    casu LitteraGenus.Nihil {
                        redde "interface{}"
                    }
                }
            }
            casu _ {
                redde "interface{}"
            }
        }
    }

    # Mixed primitive element types fall back to interface{}
    varia genera = 0
    si viditTextus { genera += 1 }
    si viditBivalens { genera += 1 }
    si viditNumerus aut viditFractus { genera += 1 }
    si genera != 1 {
        redde "interface{}"
    }

    si viditTextus {
        redde "string"
    }
    si viditBivalens {
        redde "bool"
    }
    si viditFractus {
        redde "float64"
    }
    redde "int64"
}

functio genObiectumClavis(in GoGenerator g, de Expressia clavis) -> textus {
    discerne clavis {
        casu Nomen ut n {
            redde scriptum("\"§\"", n.valor)
        }
        casu Littera ut l {
            si l.species == LitteraGenus.Textus {
                redde genLittera(l.species qua LitteraGenus, l.crudus qua textus)
            }
        }
        casu _ { }
    }

    mori "Go codegen: unsupported object key expression"
    redde "\"\""
}

functio genObiectumDispersum(in GoGenerator g, de lista<ObiectumProprietas> proprietates) -> textus {
    varia lines = [] innatum lista<textus>
    fixum baseInd = g.ind()
    lines.adde(scriptum("§func() map[string]interface{} {", baseInd))
    g.intraProfundum()
    lines.adde(scriptum("§m := map[string]interface{}{}", g.ind()))
    ex proprietates fixum prop {
        si prop.computatum {
            mori "Go codegen: unsupported object property (computed key)"
        }
        si prop.dispersum {
            fixum src = genExpressia(g, prop.valor)
            lines.adde(scriptum("§for k, v := range § { m[k] = v }", g.ind(), src))
        } secus {
            fixum key = genObiectumClavis(g, prop.clavis)
            fixum val = genExpressia(g, prop.valor)
            lines.adde(scriptum("§m[§] = §", g.ind(), key, val))
        }
    }
    lines.adde(scriptum("§return m", g.ind()))
    g.exiProfundum()
    lines.adde(scriptum("§}()", baseInd))
    redde lines.coniunge("\n")
}

functio genClausuraMassa(in GoGenerator g, de lista<Sententia> corpus) -> textus {
    si corpus.longitudo() == 0 {
        redde ""
    }
    varia lines = [] innatum lista<textus>
    ex corpus fixum stmt {
        lines.adde(genClausuraSententia(g, stmt))
    }
    redde lines.coniunge("\n")
}

functio genClausuraSententia(in GoGenerator g, de Sententia stmt) -> textus {
    discerne stmt {
        casu VariaSententia ut s {
            varia result = scriptum("§var §", g.ind(), s.nomen)
            si nonnihil s.typus {
                result = scriptum("§ §", result, genTypus(g, s.typus novum TypusAnnotatio))
            }
            si nonnihil s.valor {
                result = scriptum("§ = §", result, genExpressia(g, s.valor qua Expressia))
            }
            redde result
        }
        casu ReddeSententia ut s {
            si nonnihil s.valor {
                redde scriptum("§return §", g.ind(), genExpressia(g, s.valor qua Expressia))
            }
            redde scriptum("§return", g.ind())
        }
        casu ExpressiaSententia ut s {
            redde scriptum("§§", g.ind(), genExpressia(g, s.expressia))
        }
        casu _ { }
    }

    mori scriptum("Go codegen: unsupported lambda statement '§'", stmt.tag)
}

functio genConstructorNomen(in GoGenerator g, de Expressia vocatum) -> textus {
    discerne vocatum {
        casu Nomen ut n {
            redde scriptum("New§", capitaliza(n.valor))
        }
        casu MembrumExpressia ut m {
            si m.computatum qua bivalens {
                mori "Go codegen: unsupported constructor access (computed member)"
            }
            fixum obj = genExpressia(g, m.obiectum)
            discerne m.proprietas {
                casu Nomen ut n {
                    redde scriptum("§.New§", obj, capitaliza(n.valor))
                }
                casu _ { }
            }
        }
        casu _ { }
    }

    mori "Go codegen: unsupported constructor target"
    redde "New"
}

# Generate optional member access by flattening the chain
functio genOptionalMembrum(in GoGenerator g, de Expressia expr) -> textus {
    # Collect the full chain: base.prop1.prop2.prop3
    varia chain = [] innatum lista<textus>
    varia checks = [] innatum lista<textus>
    varia current = expr
    varia base = nihil qua textus?
    # WHY: Extract initial computatum from the MembrumExpressia variant
    varia isComputedAccess = falsum
    discerne expr {
        casu MembrumExpressia ut m {
            isComputedAccess = m.computatum qua bivalens
        }
        casu _ { }
    }

    # Walk backwards through the chain collecting properties
    dum verum {
        discerne current {
            casu MembrumExpressia ut m {
                si m.optivum qua bivalens {
                    # Add this property to the chain
                    si m.computatum qua bivalens {
                        fixum idx = genExpressia(g, m.proprietas)
                        chain.adde(scriptum("[§]", idx))
                        isComputedAccess = verum
                    } secus {
                        fixum prop = genExpressia(g, m.proprietas)
                        chain.adde(scriptum(".§", prop))
                    }
                    # Continue with the object
                    current = m.obiectum
                } secus {
                    # Non-optional member, treat as base
                    base = genExpressia(g, current)
                    rumpe
                }
            }
            casu _ {
                # Reached the base object
                base = genExpressia(g, current)
                rumpe
            }
        }
    }

    # Reverse the chain (we collected it backwards)
    varia reversedChain = [] innatum lista<textus>
    varia i = chain.longitudo() - 1
    dum i >= 0 {
        reversedChain.adde(chain[i])
        i -= 1
    }

    # Build the access path for checks: base, base.prop1, base.prop1.prop2, etc.
    fixum baseExpr = base qua textus
    varia accessPath = baseExpr
    ex reversedChain fixum segment {
        checks.adde(scriptum("§ != nil", accessPath))
        accessPath = scriptum("§§", accessPath, segment)
    }

    # WHY: For optional index, need bounds check instead of nil check for final access
    si isComputedAccess {
        # For array access, final value is taken by reference
        redde scriptum("func() interface{} { if § { v := §; return &v }; return nil }()", checks.coniunge(" && "), accessPath)
    }

    # Final expression returns pointer to the value
    redde scriptum("func() interface{} { if § { v := §; return &v }; return nil }()", checks.coniunge(" && "), accessPath)
}

# Capitalize first letter for Go field names
functio capitaliza(de textus s) -> textus {
    si s.longitudo() == 0 {
        redde s
    }
    fixum primum = s.sectio(0, 1) qua textus
    fixum first = primum.maiuscula()
    si s.longitudo() == 1 {
        redde first
    }
    redde scriptum("§§", first, s.sectio(1, s.longitudo()))
}
