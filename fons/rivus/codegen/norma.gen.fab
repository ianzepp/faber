# AUTO-GENERATED FILE - DO NOT EDIT
# Generated by: bun run build:norma
# Source: fons/norma/

# Translation result type
@ publicum
genus VerteTranslation {
    textus? method
    textus? template
    lista<textus>? params
}

# Registry data structure (type inferred)
fixum norma = {
    "mathesis": {
        "methods": {
            "pavimentum": {
                "ts": { "template": "Math.floor(§)", "params": ["x"] },
                "py": { "template": "math.floor(§)", "params": ["x"] },
                "rs": { "template": "§.floor()", "params": ["x"] },
                "cpp": { "template": "std::floor(§)", "params": ["x"] },
                "zig": { "template": "@floor(§)", "params": ["x"] }
            },
            "tectum": {
                "ts": { "template": "Math.ceil(§)", "params": ["x"] },
                "py": { "template": "math.ceil(§)", "params": ["x"] },
                "rs": { "template": "§.ceil()", "params": ["x"] },
                "cpp": { "template": "std::ceil(§)", "params": ["x"] },
                "zig": { "template": "@ceil(§)", "params": ["x"] }
            },
            "rotundum": {
                "ts": { "template": "Math.round(§)", "params": ["x"] },
                "py": { "template": "round(§)", "params": ["x"] },
                "rs": { "template": "§.round()", "params": ["x"] },
                "cpp": { "template": "std::round(§)", "params": ["x"] },
                "zig": { "template": "@round(§)", "params": ["x"] }
            },
            "truncatum": {
                "ts": { "template": "Math.trunc(§)", "params": ["x"] },
                "py": { "template": "math.trunc(§)", "params": ["x"] },
                "rs": { "template": "§.trunc()", "params": ["x"] },
                "cpp": { "template": "std::trunc(§)", "params": ["x"] },
                "zig": { "template": "@trunc(§)", "params": ["x"] }
            },
            "radix": {
                "ts": { "template": "Math.sqrt(§)", "params": ["x"] },
                "py": { "template": "math.sqrt(§)", "params": ["x"] },
                "rs": { "template": "§.sqrt()", "params": ["x"] },
                "cpp": { "template": "std::sqrt(§)", "params": ["x"] },
                "zig": { "template": "@sqrt(§)", "params": ["x"] }
            },
            "potentia": {
                "ts": { "template": "Math.pow(§, §)", "params": ["base", "exp"] },
                "py": { "template": "math.pow(§, §)", "params": ["base", "exp"] },
                "rs": { "template": "§.powf(§)", "params": ["base", "exp"] },
                "cpp": { "template": "std::pow(§, §)", "params": ["base", "exp"] },
                "zig": { "template": "std.math.pow(§, §)", "params": ["base", "exp"] }
            },
            "logarithmus": {
                "ts": { "template": "Math.log(§)", "params": ["x"] },
                "py": { "template": "math.log(§)", "params": ["x"] },
                "rs": { "template": "§.ln()", "params": ["x"] },
                "cpp": { "template": "std::log(§)", "params": ["x"] },
                "zig": { "template": "@log(§)", "params": ["x"] }
            },
            "logarithmus10": {
                "ts": { "template": "Math.log10(§)", "params": ["x"] },
                "py": { "template": "math.log10(§)", "params": ["x"] },
                "rs": { "template": "§.log10()", "params": ["x"] },
                "cpp": { "template": "std::log10(§)", "params": ["x"] },
                "zig": { "template": "std.math.log10(§)", "params": ["x"] }
            },
            "exponens": {
                "ts": { "template": "Math.exp(§)", "params": ["x"] },
                "py": { "template": "math.exp(§)", "params": ["x"] },
                "rs": { "template": "§.exp()", "params": ["x"] },
                "cpp": { "template": "std::exp(§)", "params": ["x"] },
                "zig": { "template": "@exp(§)", "params": ["x"] }
            },
            "sinus": {
                "ts": { "template": "Math.sin(§)", "params": ["x"] },
                "py": { "template": "math.sin(§)", "params": ["x"] },
                "rs": { "template": "§.sin()", "params": ["x"] },
                "cpp": { "template": "std::sin(§)", "params": ["x"] },
                "zig": { "template": "@sin(§)", "params": ["x"] }
            },
            "cosinus": {
                "ts": { "template": "Math.cos(§)", "params": ["x"] },
                "py": { "template": "math.cos(§)", "params": ["x"] },
                "rs": { "template": "§.cos()", "params": ["x"] },
                "cpp": { "template": "std::cos(§)", "params": ["x"] },
                "zig": { "template": "@cos(§)", "params": ["x"] }
            },
            "tangens": {
                "ts": { "template": "Math.tan(§)", "params": ["x"] },
                "py": { "template": "math.tan(§)", "params": ["x"] },
                "rs": { "template": "§.tan()", "params": ["x"] },
                "cpp": { "template": "std::tan(§)", "params": ["x"] },
                "zig": { "template": "@tan(§)", "params": ["x"] }
            },
            "absolutum": {
                "ts": { "template": "Math.abs(§)", "params": ["x"] },
                "py": { "template": "abs(§)", "params": ["x"] },
                "rs": { "template": "§.abs()", "params": ["x"] },
                "cpp": { "template": "std::abs(§)", "params": ["x"] },
                "zig": { "template": "@abs(§)", "params": ["x"] }
            },
            "signum": {
                "ts": { "template": "Math.sign(§)", "params": ["x"] },
                "py": { "template": "(1 if §0 > 0 else (-1 if §0 < 0 else 0))", "params": ["x"] },
                "rs": { "template": "§.signum()", "params": ["x"] },
                "cpp": { "template": "((§0 > 0) - (§0 < 0))", "params": ["x"] },
                "zig": { "template": "std.math.sign(§)", "params": ["x"] }
            },
            "minimus": {
                "ts": { "template": "Math.min(§, §)", "params": ["a", "b"] },
                "py": { "template": "min(§, §)", "params": ["a", "b"] },
                "rs": { "template": "§.min(§)", "params": ["a", "b"] },
                "cpp": { "template": "std::min(§, §)", "params": ["a", "b"] },
                "zig": { "template": "@min(§, §)", "params": ["a", "b"] }
            },
            "maximus": {
                "ts": { "template": "Math.max(§, §)", "params": ["a", "b"] },
                "py": { "template": "max(§, §)", "params": ["a", "b"] },
                "rs": { "template": "§.max(§)", "params": ["a", "b"] },
                "cpp": { "template": "std::max(§, §)", "params": ["a", "b"] },
                "zig": { "template": "@max(§, §)", "params": ["a", "b"] }
            },
            "constringens": {
                "ts": { "template": "Math.min(Math.max(§, §), §)", "params": ["x", "lo", "hi"] },
                "py": { "template": "max(§1, min(§0, §2))", "params": ["x", "lo", "hi"] },
                "rs": { "template": "§.clamp(§, §)", "params": ["x", "lo", "hi"] },
                "cpp": { "template": "std::clamp(§, §, §)", "params": ["x", "lo", "hi"] },
                "zig": { "template": "std.math.clamp(§, §, §)", "params": ["x", "lo", "hi"] }
            },
            "PI": {
                "ts": { "template": "Math.PI", "params": [] },
                "py": { "template": "math.pi", "params": [] },
                "rs": { "template": "std::f64::consts::PI", "params": [] },
                "cpp": { "template": "M_PI", "params": [] },
                "zig": { "template": "std.math.pi", "params": [] }
            },
            "E": {
                "ts": { "template": "Math.E", "params": [] },
                "py": { "template": "math.e", "params": [] },
                "rs": { "template": "std::f64::consts::E", "params": [] },
                "cpp": { "template": "M_E", "params": [] },
                "zig": { "template": "std.math.e", "params": [] }
            },
            "TAU": {
                "ts": { "template": "(Math.PI * 2)", "params": [] },
                "py": { "template": "(math.pi * 2)", "params": [] },
                "rs": { "template": "std::f64::consts::TAU", "params": [] },
                "cpp": { "template": "(M_PI * 2)", "params": [] },
                "zig": { "template": "(std.math.pi * 2)", "params": [] }
            }
        }
    },
    "tabula": {
        "methods": {
            "pone": {
                "ts": { "method": "set" },
                "py": { "template": "§0[§1] = §2", "params": ["ego", "k", "v"] },
                "rs": { "template": "§0.insert(§1, §2)", "params": ["ego", "k", "v"] },
                "cpp": { "template": "§0.insert_or_assign(§1, §2)", "params": ["ego", "k", "v"] },
                "zig": { "template": "§0.pone(§3, §1, §2)", "params": ["ego", "k", "v", "alloc"] }
            },
            "accipe": {
                "ts": { "method": "get" },
                "py": { "template": "§0.get(§1)", "params": ["ego", "k"] },
                "rs": { "template": "§0.get(&§1)", "params": ["ego", "k"] },
                "cpp": { "template": "§0.at(§1)", "params": ["ego", "k"] },
                "zig": { "template": "§0.accipe(§1)", "params": ["ego", "k"] }
            },
            "accipeAut": {
                "ts": { "template": "(§0.get(§1) ?? §2)", "params": ["ego", "k", "def"] },
                "py": { "template": "§0.get(§1, §2)", "params": ["ego", "k", "def"] },
                "rs": { "template": "§0.get(&§1).cloned().unwrap_or(§2)", "params": ["ego", "k", "def"] },
                "cpp": { "template": "(§0.contains(§1) ? §0.at(§1) : §2)", "params": ["ego", "k", "def"] },
                "zig": { "template": "§0.accipeAut(§1, §2)", "params": ["ego", "k", "def"] }
            },
            "habet": {
                "ts": { "method": "has" },
                "py": { "template": "(§1 in §0)", "params": ["ego", "k"] },
                "rs": { "template": "§0.contains_key(&§1)", "params": ["ego", "k"] },
                "cpp": { "template": "§0.contains(§1)", "params": ["ego", "k"] },
                "zig": { "template": "§0.habet(§1)", "params": ["ego", "k"] }
            },
            "dele": {
                "ts": { "method": "delete" },
                "py": { "template": "del §0[§1]", "params": ["ego", "k"] },
                "rs": { "template": "§0.remove(&§1)", "params": ["ego", "k"] },
                "cpp": { "template": "§0.erase(§1)", "params": ["ego", "k"] },
                "zig": { "template": "_ = §0.dele(§1)", "params": ["ego", "k"] }
            },
            "longitudo": {
                "ts": { "template": "§.size", "params": ["ego"] },
                "py": { "template": "len(§)", "params": ["ego"] },
                "rs": { "template": "§.len()", "params": ["ego"] },
                "cpp": { "template": "§.size()", "params": ["ego"] },
                "zig": { "template": "§.longitudo()", "params": ["ego"] }
            },
            "vacua": {
                "ts": { "template": "§.size === 0", "params": ["ego"] },
                "py": { "template": "len(§) == 0", "params": ["ego"] },
                "rs": { "template": "§.is_empty()", "params": ["ego"] },
                "cpp": { "template": "§.empty()", "params": ["ego"] },
                "zig": { "template": "§.vacua()", "params": ["ego"] }
            },
            "purga": {
                "ts": { "method": "clear" },
                "py": { "method": "clear" },
                "rs": { "method": "clear" },
                "cpp": { "method": "clear" },
                "zig": { "template": "§.purga()", "params": ["ego"] }
            },
            "claves": {
                "ts": { "method": "keys" },
                "py": { "method": "keys" },
                "rs": { "template": "§.keys()", "params": ["ego"] },
                "cpp": { "template": "§ | std::views::keys", "params": ["ego"] },
                "zig": { "template": "§.claves()", "params": ["ego"] }
            },
            "valores": {
                "ts": { "method": "values" },
                "py": { "method": "values" },
                "rs": { "template": "§.values()", "params": ["ego"] },
                "cpp": { "template": "§ | std::views::values", "params": ["ego"] },
                "zig": { "template": "§.valores()", "params": ["ego"] }
            },
            "paria": {
                "ts": { "method": "entries" },
                "py": { "method": "items" },
                "rs": { "template": "§.iter()", "params": ["ego"] },
                "cpp": { "template": "§", "params": ["ego"] },
                "zig": { "template": "§.paria()", "params": ["ego"] }
            },
            "selecta": {
                "ts": { "template": "new Map([...§0].filter(([k]) => [§1].flat().includes(k)))", "params": ["ego", "claves"] },
                "py": { "template": "{k: v for k, v in §0.items() if k in [§1]}", "params": ["ego", "claves"] },
                "rs": { "template": "faber::tabula_selecta(&§0, &§1)", "params": ["ego", "claves"] },
                "cpp": { "template": "faber::tabula_selecta(§0, §1)", "params": ["ego", "claves"] },
                "zig": { "template": "@compileError(\"selecta not implemented for Zig - use explicit loop\")", "params": ["ego", "claves"] }
            },
            "omissa": {
                "ts": { "template": "new Map([...§0].filter(([k]) => ![§1].flat().includes(k)))", "params": ["ego", "claves"] },
                "py": { "template": "{k: v for k, v in §0.items() if k not in [§1]}", "params": ["ego", "claves"] },
                "rs": { "template": "faber::tabula_omissa(&§0, &§1)", "params": ["ego", "claves"] },
                "cpp": { "template": "faber::tabula_omissa(§0, §1)", "params": ["ego", "claves"] },
                "zig": { "template": "@compileError(\"omissa not implemented for Zig - use explicit loop\")", "params": ["ego", "claves"] }
            },
            "conflata": {
                "ts": { "template": "new Map([...§0, ...§1])", "params": ["ego", "alia"] },
                "py": { "template": "{**§0, **§1}", "params": ["ego", "alia"] },
                "rs": { "template": "faber::tabula_conflata(&§0, &§1)", "params": ["ego", "alia"] },
                "cpp": { "template": "faber::tabula_conflata(§0, §1)", "params": ["ego", "alia"] },
                "zig": { "template": "§0.conflata(&§1)", "params": ["ego", "alia"] }
            },
            "inversa": {
                "ts": { "template": "new Map([...§].map(([k, v]) => [v, k]))", "params": ["ego"] },
                "py": { "template": "{v: k for k, v in §.items()}", "params": ["ego"] },
                "rs": { "template": "faber::tabula_inversa(&§)", "params": ["ego"] },
                "cpp": { "template": "faber::tabula_inversa(§)", "params": ["ego"] },
                "zig": { "template": "@compileError(\"inversa not implemented for Zig - use explicit loop\")", "params": ["ego"] }
            },
            "mappaValores": {
                "ts": { "template": "new Map([...§0].map(([k, v]) => [k, (§1)(v)]))", "params": ["ego", "fn"] },
                "py": { "template": "{k: (§1)(v) for k, v in §0.items()}", "params": ["ego", "fn"] },
                "zig": { "template": "@compileError(\"mappaValores not implemented for Zig - use explicit loop\")", "params": ["ego", "fn"] }
            },
            "mappaClaves": {
                "ts": { "template": "new Map([...§0].map(([k, v]) => [(§1)(k), v]))", "params": ["ego", "fn"] },
                "py": { "template": "{(§1)(k): v for k, v in §0.items()}", "params": ["ego", "fn"] },
                "zig": { "template": "@compileError(\"mappaClaves not implemented for Zig - use explicit loop\")", "params": ["ego", "fn"] }
            },
            "inLista": {
                "ts": { "template": "[...§]", "params": ["ego"] },
                "py": { "template": "list(§.items())", "params": ["ego"] },
                "rs": { "template": "faber::tabula_in_lista(&§)", "params": ["ego"] },
                "cpp": { "template": "faber::tabula_in_lista(§)", "params": ["ego"] },
                "zig": { "template": "§.inLista(§)", "params": ["ego", "alloc"] }
            },
            "inObjectum": {
                "ts": { "template": "Object.fromEntries(§)", "params": ["ego"] },
                "py": { "template": "dict(§)", "params": ["ego"] },
                "zig": { "template": "@compileError(\"inObjectum not implemented for Zig - Zig has no object type\")", "params": ["ego"] }
            }
        }
    },
    "numerus": {
        "methods": {
            "absolutum": {
                "ts": { "template": "Math.abs(§)", "params": ["ego"] },
                "py": { "template": "abs(§)", "params": ["ego"] },
                "rs": { "template": "§.abs()", "params": ["ego"] },
                "cpp": { "template": "std::abs(§)", "params": ["ego"] },
                "zig": { "template": "@intCast(@abs(§))", "params": ["ego"] }
            },
            "signum": {
                "ts": { "template": "Math.sign(§)", "params": ["ego"] },
                "py": { "template": "((§0>0)-(§0<0))", "params": ["ego"] },
                "rs": { "template": "§.signum()", "params": ["ego"] },
                "cpp": { "template": "((§0 > 0) - (§0 < 0))", "params": ["ego"] },
                "zig": { "template": "std.math.sign(§)", "params": ["ego"] }
            },
            "minimus": {
                "ts": { "template": "Math.min(§, §)", "params": ["ego", "other"] },
                "py": { "template": "min(§, §)", "params": ["ego", "other"] },
                "rs": { "template": "std::cmp::min(§, §)", "params": ["ego", "other"] },
                "cpp": { "template": "std::min(§, §)", "params": ["ego", "other"] },
                "zig": { "template": "@min(§, §)", "params": ["ego", "other"] }
            },
            "maximus": {
                "ts": { "template": "Math.max(§, §)", "params": ["ego", "other"] },
                "py": { "template": "max(§, §)", "params": ["ego", "other"] },
                "rs": { "template": "std::cmp::max(§, §)", "params": ["ego", "other"] },
                "cpp": { "template": "std::max(§, §)", "params": ["ego", "other"] },
                "zig": { "template": "@max(§, §)", "params": ["ego", "other"] }
            }
        }
    },
    "fractus": {
        "methods": {
            "absolutum": {
                "ts": { "template": "Math.abs(§)", "params": ["ego"] },
                "py": { "template": "abs(§)", "params": ["ego"] },
                "rs": { "template": "§.abs()", "params": ["ego"] },
                "cpp": { "template": "std::abs(§)", "params": ["ego"] },
                "zig": { "template": "@abs(§)", "params": ["ego"] }
            },
            "signum": {
                "ts": { "template": "Math.sign(§)", "params": ["ego"] },
                "py": { "template": "math.copysign(1, §)", "params": ["ego"] },
                "rs": { "template": "§.signum()", "params": ["ego"] },
                "cpp": { "template": "std::copysign(1.0, §)", "params": ["ego"] },
                "zig": { "template": "std.math.sign(§)", "params": ["ego"] }
            },
            "minimus": {
                "ts": { "template": "Math.min(§, §)", "params": ["ego", "other"] },
                "py": { "template": "min(§, §)", "params": ["ego", "other"] },
                "rs": { "template": "§.min(§)", "params": ["ego", "other"] },
                "cpp": { "template": "std::min(§, §)", "params": ["ego", "other"] },
                "zig": { "template": "@min(§, §)", "params": ["ego", "other"] }
            },
            "maximus": {
                "ts": { "template": "Math.max(§, §)", "params": ["ego", "other"] },
                "py": { "template": "max(§, §)", "params": ["ego", "other"] },
                "rs": { "template": "§.max(§)", "params": ["ego", "other"] },
                "cpp": { "template": "std::max(§, §)", "params": ["ego", "other"] },
                "zig": { "template": "@max(§, §)", "params": ["ego", "other"] }
            },
            "rotunda": {
                "ts": { "template": "Math.round(§)", "params": ["ego"] },
                "py": { "template": "round(§)", "params": ["ego"] },
                "rs": { "template": "§.round() as i64", "params": ["ego"] },
                "cpp": { "template": "static_cast<int64_t>(std::round(§))", "params": ["ego"] },
                "zig": { "template": "@intFromFloat(@round(§))", "params": ["ego"] }
            },
            "pavimentum": {
                "ts": { "template": "Math.floor(§)", "params": ["ego"] },
                "py": { "template": "math.floor(§)", "params": ["ego"] },
                "rs": { "template": "§.floor() as i64", "params": ["ego"] },
                "cpp": { "template": "static_cast<int64_t>(std::floor(§))", "params": ["ego"] },
                "zig": { "template": "@intFromFloat(@floor(§))", "params": ["ego"] }
            },
            "tectum": {
                "ts": { "template": "Math.ceil(§)", "params": ["ego"] },
                "py": { "template": "math.ceil(§)", "params": ["ego"] },
                "rs": { "template": "§.ceil() as i64", "params": ["ego"] },
                "cpp": { "template": "static_cast<int64_t>(std::ceil(§))", "params": ["ego"] },
                "zig": { "template": "@intFromFloat(@ceil(§))", "params": ["ego"] }
            },
            "trunca": {
                "ts": { "template": "Math.trunc(§)", "params": ["ego"] },
                "py": { "template": "math.trunc(§)", "params": ["ego"] },
                "rs": { "template": "§.trunc() as i64", "params": ["ego"] },
                "cpp": { "template": "static_cast<int64_t>(std::trunc(§))", "params": ["ego"] },
                "zig": { "template": "@intFromFloat(@trunc(§))", "params": ["ego"] }
            }
        }
    },
    "textus": {
        "methods": {
            "longitudo": {
                "ts": { "template": "§.length", "params": ["ego"] },
                "py": { "template": "len(§)", "params": ["ego"] },
                "rs": { "template": "§.len()", "params": ["ego"] },
                "cpp": { "template": "§.length()", "params": ["ego"] },
                "zig": { "template": "§.len", "params": ["ego"] }
            },
            "sectio": {
                "ts": { "method": "slice" },
                "py": { "template": "§[§:§]", "params": ["ego", "start", "end"] },
                "rs": { "template": "&§[§..§]", "params": ["ego", "start", "end"] },
                "cpp": { "template": "§.substr(§, § - §)", "params": ["ego", "start", "end"] },
                "zig": { "template": "§[§..§]", "params": ["ego", "start", "end"] }
            },
            "continet": {
                "ts": { "method": "includes" },
                "py": { "template": "§ in §", "params": ["ego", "sub"] },
                "rs": { "method": "contains" },
                "cpp": { "template": "(§.find(§) != std::string::npos)", "params": ["ego", "sub"] },
                "zig": { "template": "(std.mem.indexOf(u8, §, §) != null)", "params": ["ego", "sub"] }
            },
            "initium": {
                "ts": { "method": "startsWith" },
                "py": { "method": "startswith" },
                "rs": { "method": "starts_with" },
                "cpp": { "template": "(§.rfind(§, 0) == 0)", "params": ["ego", "prefix"] },
                "zig": { "template": "std.mem.startsWith(u8, §, §)", "params": ["ego", "prefix"] }
            },
            "finis": {
                "ts": { "method": "endsWith" },
                "py": { "method": "endswith" },
                "rs": { "method": "ends_with" },
                "cpp": { "template": "(§.size() >= §.size() && §.compare(§.size() - §.size(), §.size(), §) == 0)", "params": ["ego", "suffix"] },
                "zig": { "template": "std.mem.endsWith(u8, §, §)", "params": ["ego", "suffix"] }
            },
            "maiuscula": {
                "ts": { "method": "toUpperCase" },
                "py": { "method": "upper" },
                "rs": { "method": "to_uppercase" },
                "cpp": { "template": "[&]{ auto s = §; std::transform(s.begin(), s.end(), s.begin(), ::toupper); return s; }()", "params": ["ego"] },
                "zig": { "template": "std.ascii.upperString(§)", "params": ["ego"] }
            },
            "minuscula": {
                "ts": { "method": "toLowerCase" },
                "py": { "method": "lower" },
                "rs": { "method": "to_lowercase" },
                "cpp": { "template": "[&]{ auto s = §; std::transform(s.begin(), s.end(), s.begin(), ::tolower); return s; }()", "params": ["ego"] },
                "zig": { "template": "std.ascii.lowerString(§)", "params": ["ego"] }
            },
            "recide": {
                "ts": { "method": "trim" },
                "py": { "method": "strip" },
                "rs": { "method": "trim" },
                "cpp": { "template": "[&]{ auto s = §; s.erase(0, s.find_first_not_of(\" \\t\\n\\r\")); s.erase(s.find_last_not_of(\" \\t\\n\\r\") + 1); return s; }()", "params": ["ego"] },
                "zig": { "template": "std.mem.trim(u8, §, \" \\t\\n\\r\")", "params": ["ego"] }
            },
            "divide": {
                "ts": { "method": "split" },
                "py": { "method": "split" },
                "rs": { "template": "§.split(§).collect::<Vec<_>>()", "params": ["ego", "sep"] },
                "cpp": { "template": "@compileError(\"No single-expression split in C++ - use manual loop\")", "params": ["ego", "sep"] },
                "zig": { "template": "@compileError(\"Use std.mem.splitSequence for Zig\")", "params": ["ego", "sep"] }
            },
            "muta": {
                "ts": { "method": "replaceAll" },
                "py": { "method": "replace" },
                "rs": { "method": "replace" },
                "cpp": { "template": "std::regex_replace(§, std::regex(§), §)", "params": ["ego", "old", "new"] },
                "zig": { "template": "@compileError(\"Use std.mem.replace for Zig\")", "params": ["ego", "old", "new"] }
            }
        }
    },
    "copia": {
        "methods": {
            "adde": {
                "ts": { "method": "add" },
                "py": { "method": "add" },
                "rs": { "method": "insert" },
                "cpp": { "method": "insert" },
                "zig": { "template": "§0.adde(§2, §1)", "params": ["ego", "elem", "alloc"] }
            },
            "habet": {
                "ts": { "method": "has" },
                "py": { "template": "(§1 in §0)", "params": ["ego", "elem"] },
                "rs": { "template": "§0.contains(&§1)", "params": ["ego", "elem"] },
                "cpp": { "template": "§0.contains(§1)", "params": ["ego", "elem"] },
                "zig": { "template": "§0.habet(§1)", "params": ["ego", "elem"] }
            },
            "dele": {
                "ts": { "method": "delete" },
                "py": { "method": "discard" },
                "rs": { "template": "§0.remove(&§1)", "params": ["ego", "elem"] },
                "cpp": { "template": "§0.erase(§1)", "params": ["ego", "elem"] },
                "zig": { "template": "_ = §0.dele(§1)", "params": ["ego", "elem"] }
            },
            "longitudo": {
                "ts": { "template": "§.size", "params": ["ego"] },
                "py": { "template": "len(§)", "params": ["ego"] },
                "rs": { "template": "§.len()", "params": ["ego"] },
                "cpp": { "template": "§.size()", "params": ["ego"] },
                "zig": { "template": "§.longitudo()", "params": ["ego"] }
            },
            "vacua": {
                "ts": { "template": "§.size === 0", "params": ["ego"] },
                "py": { "template": "len(§) == 0", "params": ["ego"] },
                "rs": { "template": "§.is_empty()", "params": ["ego"] },
                "cpp": { "template": "§.empty()", "params": ["ego"] },
                "zig": { "template": "§.vacua()", "params": ["ego"] }
            },
            "purga": {
                "ts": { "method": "clear" },
                "py": { "method": "clear" },
                "rs": { "method": "clear" },
                "cpp": { "method": "clear" },
                "zig": { "template": "§.purga()", "params": ["ego"] }
            },
            "valores": {
                "ts": { "method": "values" },
                "py": { "template": "iter(§)", "params": ["ego"] },
                "rs": { "template": "§.iter()", "params": ["ego"] },
                "cpp": { "template": "§", "params": ["ego"] },
                "zig": { "template": "§.valores()", "params": ["ego"] }
            },
            "perambula": {
                "ts": { "method": "forEach" },
                "py": { "template": "[(§1)(x) for x in §0]", "params": ["ego", "fn"] },
                "rs": { "template": "§0.iter().for_each(§1)", "params": ["ego", "fn"] },
                "cpp": { "template": "std::ranges::for_each(§0, §1)", "params": ["ego", "fn"] },
                "zig": { "template": "@compileError(\"perambula not implemented for Zig - use 'ex set.valores() pro item { ... }' loop\")", "params": ["ego", "fn"] }
            },
            "unio": {
                "ts": { "template": "new Set([...§0, ...§1])", "params": ["ego", "alia"] },
                "py": { "template": "§0 | §1", "params": ["ego", "alia"] },
                "rs": { "template": "faber::copia_unio(&§0, &§1)", "params": ["ego", "alia"] },
                "cpp": { "template": "faber::copia_unio(§0, §1)", "params": ["ego", "alia"] },
                "zig": { "template": "@compileError(\"unio not implemented for Zig - use explicit loop to merge sets\")", "params": ["ego", "alia"] }
            },
            "intersectio": {
                "ts": { "template": "new Set([...§0].filter(x => §1.has(x)))", "params": ["ego", "alia"] },
                "py": { "template": "§0 & §1", "params": ["ego", "alia"] },
                "rs": { "template": "faber::copia_intersectio(&§0, &§1)", "params": ["ego", "alia"] },
                "cpp": { "template": "faber::copia_intersectio(§0, §1)", "params": ["ego", "alia"] },
                "zig": { "template": "@compileError(\"intersectio not implemented for Zig - use explicit loop\")", "params": ["ego", "alia"] }
            },
            "differentia": {
                "ts": { "template": "new Set([...§0].filter(x => !§1.has(x)))", "params": ["ego", "alia"] },
                "py": { "template": "§0 - §1", "params": ["ego", "alia"] },
                "rs": { "template": "faber::copia_differentia(&§0, &§1)", "params": ["ego", "alia"] },
                "cpp": { "template": "faber::copia_differentia(§0, §1)", "params": ["ego", "alia"] },
                "zig": { "template": "@compileError(\"differentia not implemented for Zig - use explicit loop\")", "params": ["ego", "alia"] }
            },
            "symmetrica": {
                "ts": { "template": "new Set([...[...§0].filter(x => !§1.has(x)), ...[...§1].filter(x => !§0.has(x))])", "params": ["ego", "alia"] },
                "py": { "template": "§0 ^ §1", "params": ["ego", "alia"] },
                "rs": { "template": "faber::copia_symmetrica(&§0, &§1)", "params": ["ego", "alia"] },
                "cpp": { "template": "faber::copia_symmetrica(§0, §1)", "params": ["ego", "alia"] },
                "zig": { "template": "@compileError(\"symmetrica not implemented for Zig - use explicit loop\")", "params": ["ego", "alia"] }
            },
            "subcopia": {
                "ts": { "template": "[...§0].every(x => §1.has(x))", "params": ["ego", "alia"] },
                "py": { "template": "§0 <= §1", "params": ["ego", "alia"] },
                "rs": { "template": "§0.is_subset(&§1)", "params": ["ego", "alia"] },
                "cpp": { "template": "faber::copia_subcopia(§0, §1)", "params": ["ego", "alia"] },
                "zig": { "template": "@compileError(\"subcopia not implemented for Zig - use explicit loop\")", "params": ["ego", "alia"] }
            },
            "supercopia": {
                "ts": { "template": "[...§1].every(x => §0.has(x))", "params": ["ego", "alia"] },
                "py": { "template": "§0 >= §1", "params": ["ego", "alia"] },
                "rs": { "template": "§0.is_superset(&§1)", "params": ["ego", "alia"] },
                "cpp": { "template": "faber::copia_supercopia(§0, §1)", "params": ["ego", "alia"] },
                "zig": { "template": "@compileError(\"supercopia not implemented for Zig - use explicit loop\")", "params": ["ego", "alia"] }
            },
            "inLista": {
                "ts": { "template": "[...§]", "params": ["ego"] },
                "py": { "template": "list(§)", "params": ["ego"] },
                "rs": { "template": "faber::copia_in_lista(&§)", "params": ["ego"] },
                "cpp": { "template": "faber::copia_in_lista(§)", "params": ["ego"] },
                "zig": { "template": "@compileError(\"inLista not implemented for Zig - iterate with ex...pro into ArrayList\")", "params": ["ego"] }
            }
        }
    },
    "lista": {
        "methods": {
            "adde": {
                "ts": { "method": "push" },
                "py": { "method": "append" },
                "rs": { "method": "push" },
                "cpp": { "method": "push_back" },
                "zig": { "template": "§0.adde(§2, §1)", "params": ["ego", "elem", "alloc"] }
            },
            "addita": {
                "ts": { "template": "[...§, §]", "params": ["ego", "elem"] },
                "py": { "template": "[*§, §]", "params": ["ego", "elem"] },
                "rs": { "template": "faber::lista_addita(&§0, §1)", "params": ["ego", "elem"] },
                "cpp": { "template": "faber::lista_addita(§0, §1)", "params": ["ego", "elem"] },
                "zig": { "template": "§0.addita(§2, §1)", "params": ["ego", "elem", "alloc"] }
            },
            "praepone": {
                "ts": { "method": "unshift" },
                "py": { "template": "§.insert(0, §)", "params": ["ego", "elem"] },
                "rs": { "template": "§.insert(0, §)", "params": ["ego", "elem"] },
                "cpp": { "template": "§.insert(§.begin(), §)", "params": ["ego", "elem"] },
                "zig": { "template": "§0.praepone(§2, §1)", "params": ["ego", "elem", "alloc"] }
            },
            "praeposita": {
                "ts": { "template": "[§1, ...§0]", "params": ["ego", "elem"] },
                "py": { "template": "[§1, *§0]", "params": ["ego", "elem"] },
                "rs": { "template": "faber::lista_praeposita(&§0, §1)", "params": ["ego", "elem"] },
                "cpp": { "template": "faber::lista_praeposita(§0, §1)", "params": ["ego", "elem"] },
                "zig": { "template": "§0.praeposita(§2, §1)", "params": ["ego", "elem", "alloc"] }
            },
            "remove": {
                "ts": { "method": "pop" },
                "py": { "method": "pop" },
                "rs": { "template": "§.pop()", "params": ["ego"] },
                "cpp": { "template": "faber::lista_remove(§0)", "params": ["ego"] },
                "zig": { "template": "§.remove()", "params": ["ego"] }
            },
            "remota": {
                "ts": { "template": "§.slice(0, -1)", "params": ["ego"] },
                "py": { "template": "§[:-1]", "params": ["ego"] },
                "rs": { "template": "§0[..§0.len().saturating_sub(1)].to_vec()", "params": ["ego"] },
                "cpp": { "template": "std::vector(§0.begin(), §0.end() - 1)", "params": ["ego"] },
                "zig": { "template": "§.remota(§)", "params": ["ego", "alloc"] }
            },
            "decapita": {
                "ts": { "method": "shift" },
                "py": { "template": "§.pop(0)", "params": ["ego"] },
                "rs": { "template": "§.remove(0)", "params": ["ego"] },
                "cpp": { "template": "faber::lista_decapita(§0)", "params": ["ego"] },
                "zig": { "template": "§.decapita()", "params": ["ego"] }
            },
            "decapitata": {
                "ts": { "template": "§.slice(1)", "params": ["ego"] },
                "py": { "template": "§[1:]", "params": ["ego"] },
                "rs": { "template": "§[1..].to_vec()", "params": ["ego"] },
                "cpp": { "template": "std::vector(§0.begin() + 1, §0.end())", "params": ["ego"] },
                "zig": { "template": "§.decapitata(§)", "params": ["ego", "alloc"] }
            },
            "purga": {
                "ts": { "template": "§.length = 0", "params": ["ego"] },
                "py": { "method": "clear" },
                "rs": { "method": "clear" },
                "cpp": { "method": "clear" },
                "zig": { "template": "§.purga()", "params": ["ego"] }
            },
            "primus": {
                "ts": { "template": "§[0]", "params": ["ego"] },
                "py": { "template": "§[0]", "params": ["ego"] },
                "rs": { "template": "§.first()", "params": ["ego"] },
                "cpp": { "template": "§.front()", "params": ["ego"] },
                "zig": { "template": "§.primus()", "params": ["ego"] }
            },
            "ultimus": {
                "ts": { "template": "§.at(-1)", "params": ["ego"] },
                "py": { "template": "§[-1]", "params": ["ego"] },
                "rs": { "template": "§.last()", "params": ["ego"] },
                "cpp": { "template": "§.back()", "params": ["ego"] },
                "zig": { "template": "§.ultimus()", "params": ["ego"] }
            },
            "accipe": {
                "ts": { "template": "§[§]", "params": ["ego", "idx"] },
                "py": { "template": "§[§]", "params": ["ego", "idx"] },
                "rs": { "template": "§.get(§)", "params": ["ego", "idx"] },
                "cpp": { "template": "§.at(§)", "params": ["ego", "idx"] },
                "zig": { "template": "§.accipe(§)", "params": ["ego", "idx"] }
            },
            "longitudo": {
                "ts": { "template": "§.length", "params": ["ego"] },
                "py": { "template": "len(§)", "params": ["ego"] },
                "rs": { "template": "§.len()", "params": ["ego"] },
                "cpp": { "template": "§.size()", "params": ["ego"] },
                "zig": { "template": "§.longitudo()", "params": ["ego"] }
            },
            "vacua": {
                "ts": { "template": "§.length === 0", "params": ["ego"] },
                "py": { "template": "len(§) == 0", "params": ["ego"] },
                "rs": { "template": "§.is_empty()", "params": ["ego"] },
                "cpp": { "template": "§.empty()", "params": ["ego"] },
                "zig": { "template": "§.vacua()", "params": ["ego"] }
            },
            "continet": {
                "ts": { "method": "includes" },
                "py": { "template": "(§1 in §0)", "params": ["ego", "elem"] },
                "rs": { "template": "§0.contains(&§1)", "params": ["ego", "elem"] },
                "cpp": { "template": "(std::find(§0.begin(), §0.end(), §1) != §0.end())", "params": ["ego", "elem"] },
                "zig": { "template": "§.continet(§)", "params": ["ego", "elem"] }
            },
            "indiceDe": {
                "ts": { "method": "indexOf" },
                "py": { "template": "§0.index(§1)", "params": ["ego", "elem"] },
                "rs": { "template": "§0.iter().position(|e| e == &§1)", "params": ["ego", "elem"] },
                "cpp": { "template": "faber::lista_indice_de(§0, §1)", "params": ["ego", "elem"] },
                "zig": { "template": "§.indiceDe(§)", "params": ["ego", "elem"] }
            },
            "inveni": {
                "ts": { "method": "find" },
                "py": { "template": "next(filter(§1, §0), None)", "params": ["ego", "pred"] },
                "rs": { "template": "§0.iter().find(§1)", "params": ["ego", "pred"] },
                "cpp": { "template": "*std::find_if(§0.begin(), §0.end(), §1)", "params": ["ego", "pred"] },
                "zig": { "template": "§.inveni(§)", "params": ["ego", "pred"] }
            },
            "inveniIndicem": {
                "ts": { "method": "findIndex" },
                "py": { "template": "next((i for i, x in enumerate(§0) if (§1)(x)), -1)", "params": ["ego", "pred"] },
                "rs": { "template": "§0.iter().position(§1)", "params": ["ego", "pred"] },
                "cpp": { "template": "faber::lista_inveni_indicem(§0, §1)", "params": ["ego", "pred"] },
                "zig": { "template": "§.inveniIndicem(§)", "params": ["ego", "pred"] }
            },
            "omnes": {
                "ts": { "method": "every" },
                "py": { "template": "all(map(§, §))", "params": ["ego", "pred"] },
                "rs": { "template": "§.iter().all(§)", "params": ["ego", "pred"] },
                "cpp": { "template": "std::ranges::all_of(§, §)", "params": ["ego", "pred"] },
                "zig": { "template": "§.omnes(§)", "params": ["ego", "pred"] }
            },
            "aliquis": {
                "ts": { "method": "some" },
                "py": { "template": "any(map(§, §))", "params": ["ego", "pred"] },
                "rs": { "template": "§.iter().any(§)", "params": ["ego", "pred"] },
                "cpp": { "template": "std::ranges::any_of(§, §)", "params": ["ego", "pred"] },
                "zig": { "template": "§.aliquis(§)", "params": ["ego", "pred"] }
            },
            "filtrata": {
                "ts": { "method": "filter" },
                "py": { "template": "list(filter(§, §))", "params": ["ego", "pred"] },
                "rs": { "template": "§.iter().filter(§).cloned().collect::<Vec<_>>()", "params": ["ego", "pred"] },
                "cpp": { "template": "(§ | std::views::filter(§) | std::ranges::to<std::vector>())", "params": ["ego", "pred"] },
                "zig": { "template": "§0.filtrata(§2, §1)", "params": ["ego", "pred", "alloc"] }
            },
            "mappata": {
                "ts": { "method": "map" },
                "py": { "template": "list(map(§, §))", "params": ["ego", "fn"] },
                "rs": { "template": "§.iter().map(§).collect::<Vec<_>>()", "params": ["ego", "fn"] },
                "cpp": { "template": "(§ | std::views::transform(§) | std::ranges::to<std::vector>())", "params": ["ego", "fn"] },
                "zig": { "template": "§0.mappata(§2, §1)", "params": ["ego", "fn", "alloc"] }
            },
            "explanata": {
                "ts": { "method": "flatMap" },
                "py": { "template": "[y for x in § for y in (§)(x)]", "params": ["ego", "fn"] },
                "rs": { "template": "§.iter().flat_map(§).collect::<Vec<_>>()", "params": ["ego", "fn"] },
                "cpp": { "template": "(§ | std::views::transform(§) | std::views::join | std::ranges::to<std::vector>())", "params": ["ego", "fn"] }
            },
            "plana": {
                "ts": { "method": "flat" },
                "py": { "template": "[y for x in § for y in x]", "params": ["ego"] },
                "rs": { "template": "§.iter().flatten().cloned().collect::<Vec<_>>()", "params": ["ego"] },
                "cpp": { "template": "(§ | std::views::join | std::ranges::to<std::vector>())", "params": ["ego"] }
            },
            "inversa": {
                "ts": { "template": "[...§].reverse()", "params": ["ego"] },
                "py": { "template": "§[::-1]", "params": ["ego"] },
                "rs": { "template": "§.iter().rev().cloned().collect::<Vec<_>>()", "params": ["ego"] },
                "cpp": { "template": "faber::lista_inversa(§)", "params": ["ego"] },
                "zig": { "template": "§.inversa(§)", "params": ["ego", "alloc"] }
            },
            "ordinata": {
                "ts": { "template": "[...§].sort()", "params": ["ego"] },
                "py": { "template": "sorted(§)", "params": ["ego"] },
                "rs": { "template": "faber::lista_ordinata(&§)", "params": ["ego"] },
                "cpp": { "template": "faber::lista_ordinata(§)", "params": ["ego"] },
                "zig": { "template": "§.ordinata(§)", "params": ["ego", "alloc"] }
            },
            "sectio": {
                "ts": { "method": "slice" },
                "py": { "template": "§[§:§]", "params": ["ego", "start", "end"] },
                "rs": { "template": "§[§..§].to_vec()", "params": ["ego", "start", "end"] },
                "cpp": { "template": "std::vector(§0.begin() + §1, §0.begin() + §2)", "params": ["ego", "start", "end"] },
                "zig": { "template": "§0.sectio(§3, §1, §2)", "params": ["ego", "start", "end", "alloc"] }
            },
            "prima": {
                "ts": { "template": "§.slice(0, §)", "params": ["ego", "n"] },
                "py": { "template": "§[:§]", "params": ["ego", "n"] },
                "rs": { "template": "§.iter().take(§).cloned().collect::<Vec<_>>()", "params": ["ego", "n"] },
                "cpp": { "template": "(§ | std::views::take(§) | std::ranges::to<std::vector>())", "params": ["ego", "n"] },
                "zig": { "template": "§0.prima(§2, §1)", "params": ["ego", "n", "alloc"] }
            },
            "ultima": {
                "ts": { "template": "§.slice(-§)", "params": ["ego", "n"] },
                "py": { "template": "§[-§:]", "params": ["ego", "n"] },
                "rs": { "template": "faber::lista_ultima(&§0, §1)", "params": ["ego", "n"] },
                "cpp": { "template": "faber::lista_ultima(§0, §1)", "params": ["ego", "n"] },
                "zig": { "template": "§0.ultima(§2, §1)", "params": ["ego", "n", "alloc"] }
            },
            "omissa": {
                "ts": { "template": "§.slice(§)", "params": ["ego", "n"] },
                "py": { "template": "§[§:]", "params": ["ego", "n"] },
                "rs": { "template": "§.iter().skip(§).cloned().collect::<Vec<_>>()", "params": ["ego", "n"] },
                "cpp": { "template": "(§ | std::views::drop(§) | std::ranges::to<std::vector>())", "params": ["ego", "n"] },
                "zig": { "template": "§0.omissa(§2, §1)", "params": ["ego", "n", "alloc"] }
            },
            "reducta": {
                "ts": { "method": "reduce" },
                "py": { "template": "functools.reduce(§, §, §)", "params": ["ego", "fn", "init"] },
                "rs": { "template": "§.iter().fold(§, §)", "params": ["ego", "fn", "init"] },
                "cpp": { "template": "std::ranges::fold_left(§, §, §)", "params": ["ego", "fn", "init"] },
                "zig": { "template": "§.reducta(§, §)", "params": ["ego", "fn", "init"] }
            },
            "filtra": {
                "ts": { "template": "(() => { for (let i = §.length - 1; i >= 0; i--) { if (!(§)(§[i])) §.splice(i, 1); } })()", "params": ["ego", "pred"] },
                "py": { "template": "§[:] = [x for x in § if (§)(x)]", "params": ["ego", "pred"] },
                "cpp": { "template": "§0.erase(std::remove_if(§0.begin(), §0.end(), [&](auto& x) { return !(§1)(x); }), §0.end())", "params": ["ego", "pred"] }
            },
            "ordina": {
                "ts": { "template": "§.sort()", "params": ["ego"] },
                "py": { "template": "§.sort()", "params": ["ego"] },
                "rs": { "template": "§.sort()", "params": ["ego"] },
                "cpp": { "template": "std::ranges::sort(§)", "params": ["ego"] },
                "zig": { "template": "§.ordina()", "params": ["ego"] }
            },
            "inverte": {
                "ts": { "method": "reverse" },
                "py": { "template": "§.reverse()", "params": ["ego"] },
                "rs": { "template": "§.reverse()", "params": ["ego"] },
                "cpp": { "template": "std::ranges::reverse(§)", "params": ["ego"] },
                "zig": { "template": "§.inverte()", "params": ["ego"] }
            },
            "perambula": {
                "ts": { "method": "forEach" },
                "py": { "template": "[(§)(x) for x in §]", "params": ["ego", "fn"] },
                "rs": { "template": "§.iter().for_each(§)", "params": ["ego", "fn"] },
                "cpp": { "template": "std::ranges::for_each(§, §)", "params": ["ego", "fn"] },
                "zig": { "template": "§.perambula(§)", "params": ["ego", "fn"] }
            },
            "coniunge": {
                "ts": { "method": "join" },
                "py": { "template": "§.join(§)", "params": ["ego", "sep"] },
                "rs": { "template": "§.join(§)", "params": ["ego", "sep"] },
                "cpp": { "template": "faber::lista_coniunge(§0, §1)", "params": ["ego", "sep"] }
            },
            "summa": {
                "ts": { "template": "§.reduce((a, b) => a + b, 0)", "params": ["ego"] },
                "py": { "template": "sum(§)", "params": ["ego"] },
                "rs": { "template": "§.iter().sum::<i64>()", "params": ["ego"] },
                "cpp": { "template": "std::accumulate(§0.begin(), §0.end(), 0)", "params": ["ego"] },
                "zig": { "template": "§.summa()", "params": ["ego"] }
            },
            "medium": {
                "ts": { "template": "(§0.reduce((a, b) => a + b, 0) / §0.length)", "params": ["ego"] },
                "py": { "template": "(sum(§0) / len(§0))", "params": ["ego"] },
                "rs": { "template": "(§0.iter().sum::<i64>() as f64 / §0.len() as f64)", "params": ["ego"] },
                "cpp": { "template": "(std::accumulate(§0.begin(), §0.end(), 0.0) / §0.size())", "params": ["ego"] },
                "zig": { "template": "§.medium()", "params": ["ego"] }
            },
            "minimus": {
                "ts": { "template": "Math.min(...§)", "params": ["ego"] },
                "py": { "template": "min(§)", "params": ["ego"] },
                "rs": { "template": "§.iter().min()", "params": ["ego"] },
                "cpp": { "template": "*std::ranges::min_element(§)", "params": ["ego"] },
                "zig": { "template": "§.minimus()", "params": ["ego"] }
            },
            "maximus": {
                "ts": { "template": "Math.max(...§)", "params": ["ego"] },
                "py": { "template": "max(§)", "params": ["ego"] },
                "rs": { "template": "§.iter().max()", "params": ["ego"] },
                "cpp": { "template": "*std::ranges::max_element(§)", "params": ["ego"] },
                "zig": { "template": "§.maximus()", "params": ["ego"] }
            },
            "minimusPer": {
                "ts": { "template": "§.reduce((min, x) => (§)(x) < (§)(min) ? x : min)", "params": ["ego", "fn"] },
                "rs": { "template": "§.iter().min_by_key(§)", "params": ["ego", "fn"] },
                "cpp": { "template": "*std::ranges::min_element(§, [&](auto& a, auto& b) { return (§)(a) < (§)(b); })", "params": ["ego", "fn"] }
            },
            "maximusPer": {
                "ts": { "template": "§.reduce((max, x) => (§)(x) > (§)(max) ? x : max)", "params": ["ego", "fn"] },
                "rs": { "template": "§.iter().max_by_key(§)", "params": ["ego", "fn"] },
                "cpp": { "template": "*std::ranges::max_element(§, [&](auto& a, auto& b) { return (§)(a) < (§)(b); })", "params": ["ego", "fn"] }
            },
            "numera": {
                "ts": { "template": "§.filter(§).length", "params": ["ego", "pred"] },
                "py": { "template": "sum(1 for x in § if (§)(x))", "params": ["ego", "pred"] },
                "rs": { "template": "§.iter().filter(§).count()", "params": ["ego", "pred"] },
                "cpp": { "template": "std::ranges::count_if(§, §)", "params": ["ego", "pred"] },
                "zig": { "template": "§.numera(§)", "params": ["ego", "pred"] }
            },
            "congrega": {
                "ts": { "template": "Object.groupBy(§, §)", "params": ["ego", "fn"] },
                "py": { "template": "{k: list(g) for k, g in itertools.groupby(sorted(§, key=§), key=§)}", "params": ["ego", "fn"] },
                "rs": { "template": "faber::lista_congrega(&§0, §1)", "params": ["ego", "fn"] },
                "cpp": { "template": "faber::lista_congrega(§0, §1)", "params": ["ego", "fn"] }
            },
            "unica": {
                "ts": { "template": "[...new Set(§)]", "params": ["ego"] },
                "py": { "template": "list(dict.fromkeys(§))", "params": ["ego"] },
                "rs": { "template": "faber::lista_unica(&§)", "params": ["ego"] },
                "cpp": { "template": "faber::lista_unica(§)", "params": ["ego"] }
            },
            "planaOmnia": {
                "ts": { "template": "§.flat(Infinity)", "params": ["ego"] },
                "cpp": { "template": "(§ | std::views::join | std::ranges::to<std::vector>())", "params": ["ego"] }
            },
            "fragmenta": {
                "ts": { "template": "Array.from({ length: Math.ceil(§.length / §) }, (_, i) => §.slice(i * §, i * § + §))", "params": ["ego", "n"] },
                "py": { "template": "[§[i:i+§] for i in range(0, len(§), §)]", "params": ["ego", "n"] },
                "rs": { "template": "§.chunks(§).map(|c| c.to_vec()).collect::<Vec<_>>()", "params": ["ego", "n"] },
                "cpp": { "template": "faber::lista_fragmenta(§0, §1)", "params": ["ego", "n"] }
            },
            "densa": {
                "ts": { "template": "§.filter(Boolean)", "params": ["ego"] },
                "py": { "template": "[x for x in § if x]", "params": ["ego"] },
                "cpp": { "template": "(§ | std::views::filter([](auto& x) { return static_cast<bool>(x); }) | std::ranges::to<std::vector>())", "params": ["ego"] }
            },
            "partire": {
                "ts": { "template": "§.reduce(([t, f], x) => (§)(x) ? [[...t, x], f] : [t, [...f, x]], [[], []])", "params": ["ego", "pred"] },
                "py": { "template": "[[x for x in § if (§)(x)], [x for x in § if not (§)(x)]]", "params": ["ego", "pred"] },
                "rs": { "template": "faber::lista_partire(&§0, §1)", "params": ["ego", "pred"] },
                "cpp": { "template": "faber::lista_partire(§0, §1)", "params": ["ego", "pred"] }
            },
            "miscita": {
                "ts": { "template": "(() => { const a = [...§]; for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; } return a; })()", "params": ["ego"] },
                "py": { "template": "random.shuffle(§)", "params": ["ego"] },
                "cpp": { "template": "faber::lista_miscita(§)", "params": ["ego"] }
            },
            "specimen": {
                "ts": { "template": "§0[Math.floor(Math.random() * §0.length)]", "params": ["ego"] },
                "py": { "template": "random.choice(§)", "params": ["ego"] },
                "cpp": { "template": "faber::lista_specimen(§0)", "params": ["ego"] }
            },
            "specimina": {
                "ts": { "template": "(() => { const a = [...§]; for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; } return a.slice(0, §); })()", "params": ["ego", "n"] },
                "py": { "template": "random.sample(§, §)", "params": ["ego", "n"] },
                "cpp": { "template": "faber::lista_specimina(§0, §1)", "params": ["ego", "n"] }
            }
        }
    }
};

# Lookup translation for target/collection/method
@ publica
functio getNormaTranslation(textus target, textus collection, textus method) fit VerteTranslation? {
    fixum coll = norma[collection]
    si coll == nihil reddit nihil

    fixum methodMap = coll.methods[method]
    si methodMap == nihil reddit nihil

    redde methodMap[target]
}
