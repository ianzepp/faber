# AUTO-GENERATED FILE - DO NOT EDIT
# Generated by: bun run build:norma
# Source: fons/norma/
# Generated: 2026-01-15T14:33:44.457Z

# Translation result type
@ publicum
genus VerteTranslation {
    textus? method
    textus? template
    lista<textus>? params
}

# Registry data structure (type inferred)
fixum norma = {
    "json": {
        "methods": {
            "solve": {
                "ts": { "template": "JSON.stringify(§)", "params": ["val"] },
                "py": { "template": "json.dumps(§)", "params": ["val"] },
                "rs": { "template": "serde_json::to_string(&§).unwrap()", "params": ["val"] },
                "cpp": { "template": "nlohmann::json(§).dump()", "params": ["val"] },
                "zig": { "template": "std.json.stringifyAlloc(§1, §0, .{})", "params": ["val", "alloc"] }
            },
            "solvePulchre": {
                "ts": { "template": "JSON.stringify(§, null, §)", "params": ["val", "indentum"] },
                "py": { "template": "json.dumps(§, indent=§)", "params": ["val", "indentum"] },
                "rs": { "template": "serde_json::to_string_pretty(&§).unwrap()", "params": ["val", "indentum"] },
                "cpp": { "template": "nlohmann::json(§).dump(§)", "params": ["val", "indentum"] },
                "zig": { "template": "std.json.stringifyAlloc(§2, §0, .{ .whitespace = .{ .indent_level = §1 } })", "params": ["val", "indentum", "alloc"] }
            },
            "pange": {
                "ts": { "template": "JSON.parse(§)", "params": ["textus"] },
                "py": { "template": "json.loads(§)", "params": ["textus"] },
                "rs": { "template": "serde_json::from_str(&§).unwrap()", "params": ["textus"] },
                "cpp": { "template": "nlohmann::json::parse(§)", "params": ["textus"] },
                "zig": { "template": "std.json.parseFromSlice(std.json.Value, std.heap.page_allocator, §, .{})", "params": ["textus"] }
            },
            "estNihil": {
                "ts": { "template": "(§ === null)", "params": ["val"] },
                "py": { "template": "(§ is None)", "params": ["val"] },
                "rs": { "template": "§.is_null()", "params": ["val"] },
                "cpp": { "template": "§.is_null()", "params": ["val"] },
                "zig": { "template": "(§ == .null)", "params": ["val"] }
            },
            "estBivalens": {
                "ts": { "template": "(typeof § === 'boolean')", "params": ["val"] },
                "py": { "template": "isinstance(§, bool)", "params": ["val"] },
                "rs": { "template": "§.is_boolean()", "params": ["val"] },
                "cpp": { "template": "§.is_boolean()", "params": ["val"] },
                "zig": { "template": "(§ == .true or § == .false)", "params": ["val"] }
            },
            "estNumerus": {
                "ts": { "template": "(typeof § === 'number')", "params": ["val"] },
                "py": { "template": "isinstance(§, (int, float))", "params": ["val"] },
                "rs": { "template": "§.is_number()", "params": ["val"] },
                "cpp": { "template": "§.is_number()", "params": ["val"] },
                "zig": { "template": "(§ == .integer or § == .float)", "params": ["val"] }
            },
            "estTextus": {
                "ts": { "template": "(typeof § === 'string')", "params": ["val"] },
                "py": { "template": "isinstance(§, str)", "params": ["val"] },
                "rs": { "template": "§.is_string()", "params": ["val"] },
                "cpp": { "template": "§.is_string()", "params": ["val"] },
                "zig": { "template": "(§ == .string)", "params": ["val"] }
            },
            "estLista": {
                "ts": { "template": "Array.isArray(§)", "params": ["val"] },
                "py": { "template": "isinstance(§, list)", "params": ["val"] },
                "rs": { "template": "§.is_array()", "params": ["val"] },
                "cpp": { "template": "§.is_array()", "params": ["val"] },
                "zig": { "template": "(§ == .array)", "params": ["val"] }
            },
            "estTabula": {
                "ts": { "template": "(typeof § === 'object' && § !== null && !Array.isArray(§))", "params": ["val"] },
                "py": { "template": "isinstance(§, dict)", "params": ["val"] },
                "rs": { "template": "§.is_object()", "params": ["val"] },
                "cpp": { "template": "§.is_object()", "params": ["val"] },
                "zig": { "template": "(§ == .object)", "params": ["val"] }
            },
            "utTextus": {
                "ts": { "template": "(typeof § === 'string' ? § : '')", "params": ["val"] },
                "py": { "template": "(§ if isinstance(§, str) else '')", "params": ["val"] },
                "rs": { "template": "§.as_str().unwrap_or(\"\")", "params": ["val"] },
                "cpp": { "template": "(§.is_string() ? §.get<std::string>() : \"\")", "params": ["val"] },
                "zig": { "template": "(if (§ == .string) §.string else \"\")", "params": ["val"] }
            },
            "utNumerus": {
                "ts": { "template": "(typeof § === 'number' ? § : 0)", "params": ["val"] },
                "py": { "template": "(§ if isinstance(§, (int, float)) else 0)", "params": ["val"] },
                "rs": { "template": "§.as_i64().unwrap_or(0)", "params": ["val"] },
                "cpp": { "template": "(§.is_number() ? §.get<int64_t>() : 0)", "params": ["val"] },
                "zig": { "template": "(if (§ == .integer) §.integer else 0)", "params": ["val"] }
            },
            "utBivalens": {
                "ts": { "template": "(typeof § === 'boolean' ? § : false)", "params": ["val"] },
                "py": { "template": "(§ if isinstance(§, bool) else False)", "params": ["val"] },
                "rs": { "template": "§.as_bool().unwrap_or(false)", "params": ["val"] },
                "cpp": { "template": "(§.is_boolean() ? §.get<bool>() : false)", "params": ["val"] },
                "zig": { "template": "(if (§ == .true) true else false)", "params": ["val"] }
            },
            "cape": {
                "ts": { "template": "(§?.[§] ?? null)", "params": ["val", "key"] },
                "py": { "template": "§.get(§)", "params": ["val", "key"] },
                "rs": { "template": "§.get(§).cloned().unwrap_or(serde_json::Value::Null)", "params": ["val", "key"] },
                "cpp": { "template": "(§.contains(§) ? §[§] : nlohmann::json())", "params": ["val", "key"] },
                "zig": { "template": "(if (§.object.get(§)) |v| v else .null)", "params": ["val", "key"] }
            },
            "capeIndice": {
                "ts": { "template": "(§?.[§] ?? null)", "params": ["val", "idx"] },
                "py": { "template": "(§[§] if § < len(§) else None)", "params": ["val", "idx"] },
                "rs": { "template": "§.get(§).cloned().unwrap_or(serde_json::Value::Null)", "params": ["val", "idx"] },
                "cpp": { "template": "(§ < §.size() ? §[§] : nlohmann::json())", "params": ["val", "idx"] },
                "zig": { "template": "(if (§ < §.array.len) §.array[§] else .null)", "params": ["val", "idx"] }
            }
        }
    },
    "tempus": {
        "methods": {
            "nunc": {
                "ts": { "template": "Date.now()", "params": [] },
                "py": { "template": "int(time.time() * 1000)", "params": [] },
                "rs": { "template": "std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_millis() as i64", "params": [] },
                "cpp": { "template": "std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count()", "params": [] },
                "zig": { "template": "std.time.milliTimestamp()", "params": [] }
            },
            "nunc_nano": {
                "ts": { "template": "BigInt(Date.now()) * 1000000n", "params": [] },
                "py": { "template": "time.time_ns()", "params": [] },
                "rs": { "template": "std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_nanos() as i64", "params": [] },
                "cpp": { "template": "std::chrono::duration_cast<std::chrono::nanoseconds>(std::chrono::system_clock::now().time_since_epoch()).count()", "params": [] },
                "zig": { "template": "std.time.nanoTimestamp()", "params": [] }
            },
            "nunc_secunda": {
                "ts": { "template": "Math.floor(Date.now() / 1000)", "params": [] },
                "py": { "template": "int(time.time())", "params": [] },
                "rs": { "template": "std::time::SystemTime::now().duration_since(std::time::UNIX_EPOCH).unwrap().as_secs() as i64", "params": [] },
                "cpp": { "template": "std::chrono::duration_cast<std::chrono::seconds>(std::chrono::system_clock::now().time_since_epoch()).count()", "params": [] },
                "zig": { "template": "std.time.timestamp()", "params": [] }
            },
            "dormi": {
                "ts": { "template": "new Promise(r => setTimeout(r, §))", "params": ["ms"] },
                "py": { "template": "time.sleep(§ / 1000)", "params": ["ms"] },
                "rs": { "template": "std::thread::sleep(std::time::Duration::from_millis(§ as u64))", "params": ["ms"] },
                "cpp": { "template": "std::this_thread::sleep_for(std::chrono::milliseconds(§))", "params": ["ms"] },
                "zig": { "template": "std.time.sleep(§ * 1_000_000)", "params": ["ms"] }
            },
            "MILLISECUNDUM": {
                "ts": { "template": "1", "params": [] },
                "py": { "template": "1", "params": [] },
                "rs": { "template": "1_i64", "params": [] },
                "cpp": { "template": "1", "params": [] },
                "zig": { "template": "1", "params": [] }
            },
            "SECUNDUM": {
                "ts": { "template": "1000", "params": [] },
                "py": { "template": "1000", "params": [] },
                "rs": { "template": "1000_i64", "params": [] },
                "cpp": { "template": "1000", "params": [] },
                "zig": { "template": "1000", "params": [] }
            },
            "MINUTUM": {
                "ts": { "template": "60000", "params": [] },
                "py": { "template": "60000", "params": [] },
                "rs": { "template": "60000_i64", "params": [] },
                "cpp": { "template": "60000", "params": [] },
                "zig": { "template": "60000", "params": [] }
            },
            "HORA": {
                "ts": { "template": "3600000", "params": [] },
                "py": { "template": "3600000", "params": [] },
                "rs": { "template": "3600000_i64", "params": [] },
                "cpp": { "template": "3600000", "params": [] },
                "zig": { "template": "3600000", "params": [] }
            },
            "DIES": {
                "ts": { "template": "86400000", "params": [] },
                "py": { "template": "86400000", "params": [] },
                "rs": { "template": "86400000_i64", "params": [] },
                "cpp": { "template": "86400000", "params": [] },
                "zig": { "template": "86400000", "params": [] }
            }
        }
    },
    "mathesis": {
        "methods": {
            "pavimentum": {
                "ts": { "template": "Math.floor(§)", "params": ["x"] },
                "py": { "template": "math.floor(§)", "params": ["x"] },
                "rs": { "template": "§.floor()", "params": ["x"] },
                "cpp": { "template": "std::floor(§)", "params": ["x"] },
                "zig": { "template": "@floor(§)", "params": ["x"] }
            },
            "tectum": {
                "ts": { "template": "Math.ceil(§)", "params": ["x"] },
                "py": { "template": "math.ceil(§)", "params": ["x"] },
                "rs": { "template": "§.ceil()", "params": ["x"] },
                "cpp": { "template": "std::ceil(§)", "params": ["x"] },
                "zig": { "template": "@ceil(§)", "params": ["x"] }
            },
            "rotundum": {
                "ts": { "template": "Math.round(§)", "params": ["x"] },
                "py": { "template": "round(§)", "params": ["x"] },
                "rs": { "template": "§.round()", "params": ["x"] },
                "cpp": { "template": "std::round(§)", "params": ["x"] },
                "zig": { "template": "@round(§)", "params": ["x"] }
            },
            "truncatum": {
                "ts": { "template": "Math.trunc(§)", "params": ["x"] },
                "py": { "template": "math.trunc(§)", "params": ["x"] },
                "rs": { "template": "§.trunc()", "params": ["x"] },
                "cpp": { "template": "std::trunc(§)", "params": ["x"] },
                "zig": { "template": "@trunc(§)", "params": ["x"] }
            },
            "radix": {
                "ts": { "template": "Math.sqrt(§)", "params": ["x"] },
                "py": { "template": "math.sqrt(§)", "params": ["x"] },
                "rs": { "template": "§.sqrt()", "params": ["x"] },
                "cpp": { "template": "std::sqrt(§)", "params": ["x"] },
                "zig": { "template": "@sqrt(§)", "params": ["x"] }
            },
            "potentia": {
                "ts": { "template": "Math.pow(§, §)", "params": ["base", "exp"] },
                "py": { "template": "math.pow(§, §)", "params": ["base", "exp"] },
                "rs": { "template": "§.powf(§)", "params": ["base", "exp"] },
                "cpp": { "template": "std::pow(§, §)", "params": ["base", "exp"] },
                "zig": { "template": "std.math.pow(§, §)", "params": ["base", "exp"] }
            },
            "logarithmus": {
                "ts": { "template": "Math.log(§)", "params": ["x"] },
                "py": { "template": "math.log(§)", "params": ["x"] },
                "rs": { "template": "§.ln()", "params": ["x"] },
                "cpp": { "template": "std::log(§)", "params": ["x"] },
                "zig": { "template": "@log(§)", "params": ["x"] }
            },
            "logarithmus10": {
                "ts": { "template": "Math.log10(§)", "params": ["x"] },
                "py": { "template": "math.log10(§)", "params": ["x"] },
                "rs": { "template": "§.log10()", "params": ["x"] },
                "cpp": { "template": "std::log10(§)", "params": ["x"] },
                "zig": { "template": "std.math.log10(§)", "params": ["x"] }
            },
            "exponens": {
                "ts": { "template": "Math.exp(§)", "params": ["x"] },
                "py": { "template": "math.exp(§)", "params": ["x"] },
                "rs": { "template": "§.exp()", "params": ["x"] },
                "cpp": { "template": "std::exp(§)", "params": ["x"] },
                "zig": { "template": "@exp(§)", "params": ["x"] }
            },
            "sinus": {
                "ts": { "template": "Math.sin(§)", "params": ["x"] },
                "py": { "template": "math.sin(§)", "params": ["x"] },
                "rs": { "template": "§.sin()", "params": ["x"] },
                "cpp": { "template": "std::sin(§)", "params": ["x"] },
                "zig": { "template": "@sin(§)", "params": ["x"] }
            },
            "cosinus": {
                "ts": { "template": "Math.cos(§)", "params": ["x"] },
                "py": { "template": "math.cos(§)", "params": ["x"] },
                "rs": { "template": "§.cos()", "params": ["x"] },
                "cpp": { "template": "std::cos(§)", "params": ["x"] },
                "zig": { "template": "@cos(§)", "params": ["x"] }
            },
            "tangens": {
                "ts": { "template": "Math.tan(§)", "params": ["x"] },
                "py": { "template": "math.tan(§)", "params": ["x"] },
                "rs": { "template": "§.tan()", "params": ["x"] },
                "cpp": { "template": "std::tan(§)", "params": ["x"] },
                "zig": { "template": "@tan(§)", "params": ["x"] }
            },
            "absolutum": {
                "ts": { "template": "Math.abs(§)", "params": ["x"] },
                "py": { "template": "abs(§)", "params": ["x"] },
                "rs": { "template": "§.abs()", "params": ["x"] },
                "cpp": { "template": "std::abs(§)", "params": ["x"] },
                "zig": { "template": "@abs(§)", "params": ["x"] }
            },
            "signum": {
                "ts": { "template": "Math.sign(§)", "params": ["x"] },
                "py": { "template": "(1 if §0 > 0 else (-1 if §0 < 0 else 0))", "params": ["x"] },
                "rs": { "template": "§.signum()", "params": ["x"] },
                "cpp": { "template": "((§0 > 0) - (§0 < 0))", "params": ["x"] },
                "zig": { "template": "std.math.sign(§)", "params": ["x"] }
            },
            "minimus": {
                "ts": { "template": "Math.min(§, §)", "params": ["a", "b"] },
                "py": { "template": "min(§, §)", "params": ["a", "b"] },
                "rs": { "template": "§.min(§)", "params": ["a", "b"] },
                "cpp": { "template": "std::min(§, §)", "params": ["a", "b"] },
                "zig": { "template": "@min(§, §)", "params": ["a", "b"] }
            },
            "maximus": {
                "ts": { "template": "Math.max(§, §)", "params": ["a", "b"] },
                "py": { "template": "max(§, §)", "params": ["a", "b"] },
                "rs": { "template": "§.max(§)", "params": ["a", "b"] },
                "cpp": { "template": "std::max(§, §)", "params": ["a", "b"] },
                "zig": { "template": "@max(§, §)", "params": ["a", "b"] }
            },
            "constringens": {
                "ts": { "template": "Math.min(Math.max(§, §), §)", "params": ["x", "lo", "hi"] },
                "py": { "template": "max(§1, min(§0, §2))", "params": ["x", "lo", "hi"] },
                "rs": { "template": "§.clamp(§, §)", "params": ["x", "lo", "hi"] },
                "cpp": { "template": "std::clamp(§, §, §)", "params": ["x", "lo", "hi"] },
                "zig": { "template": "std.math.clamp(§, §, §)", "params": ["x", "lo", "hi"] }
            },
            "PI": {
                "ts": { "template": "Math.PI", "params": [] },
                "py": { "template": "math.pi", "params": [] },
                "rs": { "template": "std::f64::consts::PI", "params": [] },
                "cpp": { "template": "M_PI", "params": [] },
                "zig": { "template": "std.math.pi", "params": [] }
            },
            "E": {
                "ts": { "template": "Math.E", "params": [] },
                "py": { "template": "math.e", "params": [] },
                "rs": { "template": "std::f64::consts::E", "params": [] },
                "cpp": { "template": "M_E", "params": [] },
                "zig": { "template": "std.math.e", "params": [] }
            },
            "TAU": {
                "ts": { "template": "(Math.PI * 2)", "params": [] },
                "py": { "template": "(math.pi * 2)", "params": [] },
                "rs": { "template": "std::f64::consts::TAU", "params": [] },
                "cpp": { "template": "(M_PI * 2)", "params": [] },
                "zig": { "template": "(std.math.pi * 2)", "params": [] }
            }
        }
    },
    "aleator": {
        "methods": {
            "fractus": {
                "ts": { "template": "Math.random()", "params": [] },
                "py": { "template": "random.random()", "params": [] },
                "rs": { "template": "rand::random::<f64>()", "params": [] },
                "cpp": { "template": "[&]{ std::random_device rd; std::mt19937 gen(rd()); std::uniform_real_distribution<> dis(0.0, 1.0); return dis(gen); }()", "params": [] },
                "zig": { "template": "blk: { var seed: u64 = undefined; std.crypto.random.bytes(std.mem.asBytes(&seed)); var prng = std.rand.DefaultPrng.init(seed); break :blk prng.random().float(f64); }", "params": [] }
            },
            "inter": {
                "ts": { "template": "Math.floor(Math.random() * (§1 - §0 + 1)) + §0", "params": ["min", "max"] },
                "py": { "template": "random.randint(§0, §1)", "params": ["min", "max"] },
                "rs": { "template": "rand::thread_rng().gen_range(§0..=§1)", "params": ["min", "max"] },
                "cpp": { "template": "[&]{ std::random_device rd; std::mt19937 gen(rd()); std::uniform_int_distribution<> dis(§0, §1); return dis(gen); }()", "params": ["min", "max"] },
                "zig": { "template": "blk: { var seed: u64 = undefined; std.crypto.random.bytes(std.mem.asBytes(&seed)); var prng = std.rand.DefaultPrng.init(seed); break :blk prng.random().intRangeAtMost(i64, §0, §1); }", "params": ["min", "max"] }
            },
            "octeti": {
                "ts": { "template": "crypto.getRandomValues(new Uint8Array(§))", "params": ["n"] },
                "py": { "template": "secrets.token_bytes(§)", "params": ["n"] },
                "rs": { "template": "{ let mut bytes = vec![0u8; §]; rand::thread_rng().fill(&mut bytes[..]); bytes }", "params": ["n"] },
                "cpp": { "template": "[&]{ std::vector<uint8_t> bytes(§); std::random_device rd; for (auto& b : bytes) b = static_cast<uint8_t>(rd()); return bytes; }()", "params": ["n"] },
                "zig": { "template": "blk: { var buf = §1.alloc(u8, §0) catch unreachable; std.crypto.random.bytes(buf); break :blk buf; }", "params": ["n", "alloc"] }
            },
            "uuid": {
                "ts": { "template": "crypto.randomUUID()", "params": [] },
                "py": { "template": "str(uuid.uuid4())", "params": [] },
                "rs": { "template": "uuid::Uuid::new_v4().to_string()", "params": [] },
                "cpp": { "template": "[&]{ std::random_device rd; std::mt19937 gen(rd()); std::uniform_int_distribution<> dis(0, 15); auto hex = [](int n) { return \"0123456789abcdef\"[n]; }; std::string uuid; for (int i = 0; i < 36; ++i) { if (i == 8 || i == 13 || i == 18 || i == 23) uuid += '-'; else if (i == 14) uuid += '4'; else if (i == 19) uuid += hex((dis(gen) & 0x3) | 0x8); else uuid += hex(dis(gen)); } return uuid; }()", "params": [] },
                "zig": { "template": "blk: { var buf: [36]u8 = undefined; var bytes: [16]u8 = undefined; std.crypto.random.bytes(&bytes); bytes[6] = (bytes[6] & 0x0f) | 0x40; bytes[8] = (bytes[8] & 0x3f) | 0x80; const hex = \"0123456789abcdef\"; var i: usize = 0; for (bytes, 0..) |b, j| { if (j == 4 or j == 6 or j == 8 or j == 10) { buf[i] = '-'; i += 1; } buf[i] = hex[b >> 4]; buf[i + 1] = hex[b & 0x0f]; i += 2; } break :blk buf; }", "params": [] }
            },
            "selige": {
                "ts": { "template": "§0[Math.floor(Math.random() * §0.length)]", "params": ["lista"] },
                "py": { "template": "random.choice(§0)", "params": ["lista"] },
                "rs": { "template": "§0.choose(&mut rand::thread_rng()).unwrap().clone()", "params": ["lista"] },
                "cpp": { "template": "[&]{ std::random_device rd; std::mt19937 gen(rd()); std::uniform_int_distribution<size_t> dis(0, §0.size() - 1); return §0[dis(gen)]; }()", "params": ["lista"] },
                "zig": { "template": "blk: { var seed: u64 = undefined; std.crypto.random.bytes(std.mem.asBytes(&seed)); var prng = std.rand.DefaultPrng.init(seed); break :blk §0[prng.random().uintLessThan(usize, §0.len)]; }", "params": ["lista"] }
            },
            "miscita": {
                "ts": { "template": "(() => { const a = [...§0]; for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; } return a; })()", "params": ["lista"] },
                "py": { "template": "random.sample(§0, len(§0))", "params": ["lista"] },
                "rs": { "template": "{ let mut v = §0.clone(); v.shuffle(&mut rand::thread_rng()); v }", "params": ["lista"] },
                "cpp": { "template": "[&]{ auto v = §0; std::random_device rd; std::mt19937 gen(rd()); std::ranges::shuffle(v, gen); return v; }()", "params": ["lista"] },
                "zig": { "template": "blk: { var seed: u64 = undefined; std.crypto.random.bytes(std.mem.asBytes(&seed)); var prng = std.rand.DefaultPrng.init(seed); var copy = §1.dupe(@TypeOf(§0[0]), §0) catch unreachable; prng.random().shuffle(@TypeOf(copy[0]), copy); break :blk copy; }", "params": ["lista", "alloc"] }
            },
            "semen": {
                "ts": { "template": "undefined /* JS Math.random is not seedable */", "params": ["n"] },
                "py": { "template": "random.seed(§)", "params": ["n"] },
                "rs": { "template": "/* seed(§) - use rand::SeedableRng for reproducible results */", "params": ["n"] },
                "cpp": { "template": "/* seed(§) - C++ requires explicit generator management */", "params": ["n"] },
                "zig": { "template": "@compileLog(\"seed(§) - Zig requires explicit PRNG state management\")", "params": ["n"] }
            }
        }
    },
    "solum": {
        "methods": {
            "legens": {
                "ts": { "template": "fs.createReadStream(§)", "params": ["path"] },
                "py": { "template": "open(§, 'rb')", "params": ["path"] },
                "zig": { "template": "solum.legens(§)", "params": ["path"] }
            },
            "leget": {
                "ts": { "template": "fs.promises.readFile(§, 'utf-8')", "params": ["path"] },
                "py": { "template": "aiofiles.open(§).read()", "params": ["path"] },
                "zig": { "template": "solum.leget(§1, §0)", "params": ["path", "alloc"] }
            },
            "lege": {
                "ts": { "template": "fs.readFileSync(§, 'utf-8')", "params": ["path"] },
                "py": { "template": "open(§).read()", "params": ["path"] },
                "zig": { "template": "solum.lege(§1, §0)", "params": ["path", "alloc"] }
            },
            "ausculta": {
                "ts": { "template": "readline.createInterface({ input: process.stdin })", "params": [] },
                "py": { "template": "sys.stdin", "params": [] },
                "zig": { "template": "solum.ausculta()", "params": [] }
            },
            "hauri": {
                "ts": { "template": "fs.readFileSync(0, 'utf-8')", "params": [] },
                "py": { "template": "sys.stdin.read()", "params": [] },
                "zig": { "template": "solum.hauri(§)", "params": ["alloc"] }
            },
            "scribens": {
                "ts": { "template": "fs.createWriteStream(§)", "params": ["path"] },
                "py": { "template": "open(§, 'wb')", "params": ["path"] },
                "zig": { "template": "solum.scribens(§)", "params": ["path"] }
            },
            "scribet": {
                "ts": { "template": "fs.promises.writeFile(§, §)", "params": ["path", "data"] },
                "py": { "template": "aiofiles.open(§, 'w').write(§)", "params": ["path", "data"] },
                "zig": { "template": "solum.scribet(§, §)", "params": ["path", "data"] }
            },
            "inscribe": {
                "ts": { "template": "fs.writeFileSync(§, §)", "params": ["path", "data"] },
                "py": { "template": "open(§, 'w').write(§)", "params": ["path", "data"] },
                "zig": { "template": "solum.inscribe(§, §)", "params": ["path", "data"] }
            },
            "apponet": {
                "ts": { "template": "fs.promises.appendFile(§, §)", "params": ["path", "data"] },
                "py": { "template": "aiofiles.open(§, 'a').write(§)", "params": ["path", "data"] },
                "zig": { "template": "solum.apponet(§, §)", "params": ["path", "data"] }
            },
            "appone": {
                "ts": { "template": "fs.appendFileSync(§, §)", "params": ["path", "data"] },
                "py": { "template": "open(§, 'a').write(§)", "params": ["path", "data"] },
                "zig": { "template": "solum.appone(§, §)", "params": ["path", "data"] }
            },
            "exstat": {
                "ts": { "template": "fs.existsSync(§)", "params": ["path"] },
                "py": { "template": "os.path.exists(§)", "params": ["path"] },
                "zig": { "template": "solum.exstat(§)", "params": ["path"] }
            },
            "inspice": {
                "ts": { "template": "fs.promises.stat(§)", "params": ["path"] },
                "py": { "template": "os.stat(§)", "params": ["path"] },
                "zig": { "template": "solum.inspice(§)", "params": ["path"] }
            },
            "dele": {
                "ts": { "template": "fs.promises.unlink(§)", "params": ["path"] },
                "py": { "template": "os.remove(§)", "params": ["path"] },
                "zig": { "template": "solum.dele(§)", "params": ["path"] }
            },
            "duplica": {
                "ts": { "template": "fs.promises.copyFile(§, §)", "params": ["src", "dest"] },
                "py": { "template": "shutil.copy2(§, §)", "params": ["src", "dest"] },
                "zig": { "template": "solum.duplica(§, §)", "params": ["src", "dest"] }
            },
            "move": {
                "ts": { "template": "fs.promises.rename(§, §)", "params": ["src", "dest"] },
                "py": { "template": "shutil.move(§, §)", "params": ["src", "dest"] },
                "zig": { "template": "solum.move(§, §)", "params": ["src", "dest"] }
            },
            "trunca": {
                "ts": { "template": "fs.promises.truncate(§, §)", "params": ["path", "size"] },
                "py": { "template": "os.truncate(§, §)", "params": ["path", "size"] },
                "zig": { "template": "solum.trunca(§, §)", "params": ["path", "size"] }
            },
            "tange": {
                "ts": { "template": "fs.promises.utimes(§, Date.now(), Date.now())", "params": ["path"] },
                "py": { "template": "pathlib.Path(§).touch()", "params": ["path"] },
                "zig": { "template": "solum.tange(§)", "params": ["path"] }
            },
            "crea": {
                "ts": { "template": "fs.promises.mkdir(§, { recursive: true })", "params": ["path"] },
                "py": { "template": "os.makedirs(§, exist_ok=True)", "params": ["path"] },
                "zig": { "template": "solum.crea(§)", "params": ["path"] }
            },
            "elenca": {
                "ts": { "template": "fs.promises.readdir(§)", "params": ["path"] },
                "py": { "template": "os.listdir(§)", "params": ["path"] },
                "zig": { "template": "solum.elenca(§1, §0)", "params": ["path", "alloc"] }
            },
            "ambula": {
                "ts": { "template": "glob.stream(§ + '/**/*')", "params": ["path"] },
                "py": { "template": "os.walk(§)", "params": ["path"] },
                "zig": { "template": "solum.ambula(§)", "params": ["path"] }
            },
            "vacua": {
                "ts": { "template": "fs.promises.rmdir(§)", "params": ["path"] },
                "py": { "template": "os.rmdir(§)", "params": ["path"] },
                "zig": { "template": "solum.vacua(§)", "params": ["path"] }
            },
            "deleArborem": {
                "ts": { "template": "fs.promises.rm(§, { recursive: true })", "params": ["path"] },
                "py": { "template": "shutil.rmtree(§)", "params": ["path"] },
                "zig": { "template": "solum.deleArborem(§)", "params": ["path"] }
            },
            "iunge": {
                "ts": { "template": "path.join(...§)", "params": ["parts"] },
                "py": { "template": "os.path.join(*§)", "params": ["parts"] },
                "zig": { "template": "solum.iunge(§)", "params": ["parts"] }
            },
            "dir": {
                "ts": { "template": "path.dirname(§)", "params": ["path"] },
                "py": { "template": "os.path.dirname(§)", "params": ["path"] },
                "zig": { "template": "solum.dir(§)", "params": ["path"] }
            },
            "basis": {
                "ts": { "template": "path.basename(§)", "params": ["path"] },
                "py": { "template": "os.path.basename(§)", "params": ["path"] },
                "zig": { "template": "solum.basis(§)", "params": ["path"] }
            },
            "extensio": {
                "ts": { "template": "path.extname(§)", "params": ["path"] },
                "py": { "template": "os.path.splitext(§)[1]", "params": ["path"] },
                "zig": { "template": "solum.extensio(§)", "params": ["path"] }
            },
            "resolve": {
                "ts": { "template": "path.resolve(§)", "params": ["path"] },
                "py": { "template": "os.path.abspath(§)", "params": ["path"] },
                "zig": { "template": "solum.resolve(§1, §0)", "params": ["path", "alloc"] }
            },
            "domus": {
                "ts": { "template": "os.homedir()", "params": [] },
                "py": { "template": "os.path.expanduser('~')", "params": [] },
                "zig": { "template": "solum.domus()", "params": [] }
            }
        }
    },
    "caelum": {
        "methods": {
            "pete": {
                "ts": { "template": "caelum.pete(§)", "params": ["url"] },
                "py": { "template": "caelum.pete(§)", "params": ["url"] },
                "rs": { "template": "caelum::pete(§)", "params": ["url"] },
                "cpp": { "template": "caelum::pete(§)", "params": ["url"] },
                "zig": { "template": "caelum.pete(§)", "params": ["url"] }
            },
            "mitte": {
                "ts": { "template": "caelum.mitte(§, §)", "params": ["url", "corpus"] },
                "py": { "template": "caelum.mitte(§, §)", "params": ["url", "corpus"] },
                "rs": { "template": "caelum::mitte(§, §)", "params": ["url", "corpus"] },
                "cpp": { "template": "caelum::mitte(§, §)", "params": ["url", "corpus"] },
                "zig": { "template": "caelum.mitte(§, §)", "params": ["url", "corpus"] }
            },
            "pone": {
                "ts": { "template": "caelum.pone(§, §)", "params": ["url", "corpus"] },
                "py": { "template": "caelum.pone(§, §)", "params": ["url", "corpus"] },
                "rs": { "template": "caelum::pone(§, §)", "params": ["url", "corpus"] },
                "cpp": { "template": "caelum::pone(§, §)", "params": ["url", "corpus"] },
                "zig": { "template": "caelum.pone(§, §)", "params": ["url", "corpus"] }
            },
            "dele": {
                "ts": { "template": "caelum.dele(§)", "params": ["url"] },
                "py": { "template": "caelum.dele(§)", "params": ["url"] },
                "rs": { "template": "caelum::dele(§)", "params": ["url"] },
                "cpp": { "template": "caelum::dele(§)", "params": ["url"] },
                "zig": { "template": "caelum.dele(§)", "params": ["url"] }
            },
            "muta": {
                "ts": { "template": "caelum.muta(§, §)", "params": ["url", "corpus"] },
                "py": { "template": "caelum.muta(§, §)", "params": ["url", "corpus"] },
                "rs": { "template": "caelum::muta(§, §)", "params": ["url", "corpus"] },
                "cpp": { "template": "caelum::muta(§, §)", "params": ["url", "corpus"] },
                "zig": { "template": "caelum.muta(§, §)", "params": ["url", "corpus"] }
            },
            "roga": {
                "ts": { "template": "caelum.roga(§, §, §, §)", "params": ["modus", "url", "capita", "corpus"] },
                "py": { "template": "caelum.roga(§, §, §, §)", "params": ["modus", "url", "capita", "corpus"] },
                "rs": { "template": "caelum::roga(§, §, §, §)", "params": ["modus", "url", "capita", "corpus"] },
                "cpp": { "template": "caelum::roga(§, §, §, §)", "params": ["modus", "url", "capita", "corpus"] },
                "zig": { "template": "caelum.roga(§, §, §, §)", "params": ["modus", "url", "capita", "corpus"] }
            },
            "exspecta": {
                "ts": { "template": "caelum.exspecta(§, §)", "params": ["handler", "portus"] },
                "py": { "template": "caelum.exspecta(§, §)", "params": ["handler", "portus"] },
                "rs": { "template": "caelum::exspecta(§, §)", "params": ["handler", "portus"] },
                "cpp": { "template": "caelum::exspecta(§, §)", "params": ["handler", "portus"] },
                "zig": { "template": "caelum.exspecta(§, §)", "params": ["handler", "portus"] }
            },
            "siste": {
                "ts": { "template": "§.siste()", "params": ["s"] },
                "py": { "template": "§.siste()", "params": ["s"] },
                "rs": { "template": "§.siste()", "params": ["s"] },
                "cpp": { "template": "§.siste()", "params": ["s"] },
                "zig": { "template": "§.siste()", "params": ["s"] }
            },
            "replicatio": {
                "ts": { "template": "caelum.replicatio(§, §, §)", "params": ["status", "capita", "corpus"] },
                "py": { "template": "caelum.replicatio(§, §, §)", "params": ["status", "capita", "corpus"] },
                "rs": { "template": "caelum::replicatio(§, §, §)", "params": ["status", "capita", "corpus"] },
                "cpp": { "template": "caelum::replicatio(§, §, §)", "params": ["status", "capita", "corpus"] },
                "zig": { "template": "caelum.replicatio(§, §, §)", "params": ["status", "capita", "corpus"] }
            }
        }
    },
    "tabula": {
        "methods": {
            "pone": {
                "ts": { "method": "set" },
                "py": { "template": "§0[§1] = §2", "params": ["ego", "k", "v"] },
                "rs": { "template": "§0.insert(§1, §2)", "params": ["ego", "k", "v"] },
                "cpp": { "template": "§0.insert_or_assign(§1, §2)", "params": ["ego", "k", "v"] },
                "zig": { "template": "§0.pone(§3, §1, §2)", "params": ["ego", "k", "v", "alloc"] }
            },
            "accipe": {
                "ts": { "method": "get" },
                "py": { "template": "§0.get(§1)", "params": ["ego", "k"] },
                "rs": { "template": "§0.get(&§1)", "params": ["ego", "k"] },
                "cpp": { "template": "§0.at(§1)", "params": ["ego", "k"] },
                "zig": { "template": "§0.accipe(§1)", "params": ["ego", "k"] }
            },
            "accipeAut": {
                "ts": { "template": "(§0.get(§1) ?? §2)", "params": ["ego", "k", "def"] },
                "py": { "template": "§0.get(§1, §2)", "params": ["ego", "k", "def"] },
                "rs": { "template": "§0.get(&§1).cloned().unwrap_or(§2)", "params": ["ego", "k", "def"] },
                "cpp": { "template": "(§0.contains(§1) ? §0.at(§1) : §2)", "params": ["ego", "k", "def"] },
                "zig": { "template": "§0.accipeAut(§1, §2)", "params": ["ego", "k", "def"] }
            },
            "habet": {
                "ts": { "method": "has" },
                "py": { "template": "(§1 in §0)", "params": ["ego", "k"] },
                "rs": { "template": "§0.contains_key(&§1)", "params": ["ego", "k"] },
                "cpp": { "template": "§0.contains(§1)", "params": ["ego", "k"] },
                "zig": { "template": "§0.habet(§1)", "params": ["ego", "k"] }
            },
            "dele": {
                "ts": { "method": "delete" },
                "py": { "template": "del §0[§1]", "params": ["ego", "k"] },
                "rs": { "template": "§0.remove(&§1)", "params": ["ego", "k"] },
                "cpp": { "template": "§0.erase(§1)", "params": ["ego", "k"] },
                "zig": { "template": "_ = §0.dele(§1)", "params": ["ego", "k"] }
            },
            "longitudo": {
                "ts": { "template": "§.size", "params": ["ego"] },
                "py": { "template": "len(§)", "params": ["ego"] },
                "rs": { "template": "§.len()", "params": ["ego"] },
                "cpp": { "template": "§.size()", "params": ["ego"] },
                "zig": { "template": "§.longitudo()", "params": ["ego"] }
            },
            "vacua": {
                "ts": { "template": "§.size === 0", "params": ["ego"] },
                "py": { "template": "len(§) == 0", "params": ["ego"] },
                "rs": { "template": "§.is_empty()", "params": ["ego"] },
                "cpp": { "template": "§.empty()", "params": ["ego"] },
                "zig": { "template": "§.vacua()", "params": ["ego"] }
            },
            "purga": {
                "ts": { "method": "clear" },
                "py": { "method": "clear" },
                "rs": { "method": "clear" },
                "cpp": { "method": "clear" },
                "zig": { "template": "§.purga()", "params": ["ego"] }
            },
            "claves": {
                "ts": { "method": "keys" },
                "py": { "method": "keys" },
                "rs": { "template": "§.keys()", "params": ["ego"] },
                "cpp": { "template": "§ | std::views::keys", "params": ["ego"] },
                "zig": { "template": "§.claves()", "params": ["ego"] }
            },
            "valores": {
                "ts": { "method": "values" },
                "py": { "method": "values" },
                "rs": { "template": "§.values()", "params": ["ego"] },
                "cpp": { "template": "§ | std::views::values", "params": ["ego"] },
                "zig": { "template": "§.valores()", "params": ["ego"] }
            },
            "paria": {
                "ts": { "method": "entries" },
                "py": { "method": "items" },
                "rs": { "template": "§.iter()", "params": ["ego"] },
                "cpp": { "template": "§", "params": ["ego"] },
                "zig": { "template": "§.paria()", "params": ["ego"] }
            },
            "selecta": {
                "ts": { "template": "new Map([...§0].filter(([k]) => [§1].flat().includes(k)))", "params": ["ego", "claves"] },
                "py": { "template": "{k: v for k, v in §0.items() if k in [§1]}", "params": ["ego", "claves"] },
                "rs": { "template": "faber::tabula_selecta(&§0, &§1)", "params": ["ego", "claves"] },
                "cpp": { "template": "faber::tabula_selecta(§0, §1)", "params": ["ego", "claves"] },
                "zig": { "template": "@compileError(\"selecta not implemented for Zig - use explicit loop\")", "params": ["ego", "claves"] }
            },
            "omissa": {
                "ts": { "template": "new Map([...§0].filter(([k]) => ![§1].flat().includes(k)))", "params": ["ego", "claves"] },
                "py": { "template": "{k: v for k, v in §0.items() if k not in [§1]}", "params": ["ego", "claves"] },
                "rs": { "template": "faber::tabula_omissa(&§0, &§1)", "params": ["ego", "claves"] },
                "cpp": { "template": "faber::tabula_omissa(§0, §1)", "params": ["ego", "claves"] },
                "zig": { "template": "@compileError(\"omissa not implemented for Zig - use explicit loop\")", "params": ["ego", "claves"] }
            },
            "conflata": {
                "ts": { "template": "new Map([...§0, ...§1])", "params": ["ego", "alia"] },
                "py": { "template": "{**§0, **§1}", "params": ["ego", "alia"] },
                "rs": { "template": "faber::tabula_conflata(&§0, &§1)", "params": ["ego", "alia"] },
                "cpp": { "template": "faber::tabula_conflata(§0, §1)", "params": ["ego", "alia"] },
                "zig": { "template": "§0.conflata(&§1)", "params": ["ego", "alia"] }
            },
            "inversa": {
                "ts": { "template": "new Map([...§].map(([k, v]) => [v, k]))", "params": ["ego"] },
                "py": { "template": "{v: k for k, v in §.items()}", "params": ["ego"] },
                "rs": { "template": "faber::tabula_inversa(&§)", "params": ["ego"] },
                "cpp": { "template": "faber::tabula_inversa(§)", "params": ["ego"] },
                "zig": { "template": "@compileError(\"inversa not implemented for Zig - use explicit loop\")", "params": ["ego"] }
            },
            "mappaValores": {
                "ts": { "template": "new Map([...§0].map(([k, v]) => [k, (§1)(v)]))", "params": ["ego", "fn"] },
                "py": { "template": "{k: (§1)(v) for k, v in §0.items()}", "params": ["ego", "fn"] },
                "zig": { "template": "@compileError(\"mappaValores not implemented for Zig - use explicit loop\")", "params": ["ego", "fn"] }
            },
            "mappaClaves": {
                "ts": { "template": "new Map([...§0].map(([k, v]) => [(§1)(k), v]))", "params": ["ego", "fn"] },
                "py": { "template": "{(§1)(k): v for k, v in §0.items()}", "params": ["ego", "fn"] },
                "zig": { "template": "@compileError(\"mappaClaves not implemented for Zig - use explicit loop\")", "params": ["ego", "fn"] }
            },
            "inLista": {
                "ts": { "template": "[...§]", "params": ["ego"] },
                "py": { "template": "list(§.items())", "params": ["ego"] },
                "rs": { "template": "faber::tabula_in_lista(&§)", "params": ["ego"] },
                "cpp": { "template": "faber::tabula_in_lista(§)", "params": ["ego"] },
                "zig": { "template": "§.inLista(§)", "params": ["ego", "alloc"] }
            },
            "inObjectum": {
                "ts": { "template": "Object.fromEntries(§)", "params": ["ego"] },
                "py": { "template": "dict(§)", "params": ["ego"] },
                "zig": { "template": "@compileError(\"inObjectum not implemented for Zig - Zig has no object type\")", "params": ["ego"] }
            }
        }
    },
    "numerus": {
        "methods": {
            "absolutum": {
                "ts": { "template": "Math.abs(§)", "params": ["ego"] },
                "py": { "template": "abs(§)", "params": ["ego"] },
                "rs": { "template": "§.abs()", "params": ["ego"] },
                "cpp": { "template": "std::abs(§)", "params": ["ego"] },
                "zig": { "template": "@intCast(@abs(§))", "params": ["ego"] }
            },
            "signum": {
                "ts": { "template": "Math.sign(§)", "params": ["ego"] },
                "py": { "template": "((§0>0)-(§0<0))", "params": ["ego"] },
                "rs": { "template": "§.signum()", "params": ["ego"] },
                "cpp": { "template": "((§0 > 0) - (§0 < 0))", "params": ["ego"] },
                "zig": { "template": "std.math.sign(§)", "params": ["ego"] }
            },
            "minimus": {
                "ts": { "template": "Math.min(§, §)", "params": ["ego", "other"] },
                "py": { "template": "min(§, §)", "params": ["ego", "other"] },
                "rs": { "template": "std::cmp::min(§, §)", "params": ["ego", "other"] },
                "cpp": { "template": "std::min(§, §)", "params": ["ego", "other"] },
                "zig": { "template": "@min(§, §)", "params": ["ego", "other"] }
            },
            "maximus": {
                "ts": { "template": "Math.max(§, §)", "params": ["ego", "other"] },
                "py": { "template": "max(§, §)", "params": ["ego", "other"] },
                "rs": { "template": "std::cmp::max(§, §)", "params": ["ego", "other"] },
                "cpp": { "template": "std::max(§, §)", "params": ["ego", "other"] },
                "zig": { "template": "@max(§, §)", "params": ["ego", "other"] }
            }
        }
    },
    "fractus": {
        "methods": {
            "absolutum": {
                "ts": { "template": "Math.abs(§)", "params": ["ego"] },
                "py": { "template": "abs(§)", "params": ["ego"] },
                "rs": { "template": "§.abs()", "params": ["ego"] },
                "cpp": { "template": "std::abs(§)", "params": ["ego"] },
                "zig": { "template": "@abs(§)", "params": ["ego"] }
            },
            "signum": {
                "ts": { "template": "Math.sign(§)", "params": ["ego"] },
                "py": { "template": "math.copysign(1, §)", "params": ["ego"] },
                "rs": { "template": "§.signum()", "params": ["ego"] },
                "cpp": { "template": "std::copysign(1.0, §)", "params": ["ego"] },
                "zig": { "template": "std.math.sign(§)", "params": ["ego"] }
            },
            "minimus": {
                "ts": { "template": "Math.min(§, §)", "params": ["ego", "other"] },
                "py": { "template": "min(§, §)", "params": ["ego", "other"] },
                "rs": { "template": "§.min(§)", "params": ["ego", "other"] },
                "cpp": { "template": "std::min(§, §)", "params": ["ego", "other"] },
                "zig": { "template": "@min(§, §)", "params": ["ego", "other"] }
            },
            "maximus": {
                "ts": { "template": "Math.max(§, §)", "params": ["ego", "other"] },
                "py": { "template": "max(§, §)", "params": ["ego", "other"] },
                "rs": { "template": "§.max(§)", "params": ["ego", "other"] },
                "cpp": { "template": "std::max(§, §)", "params": ["ego", "other"] },
                "zig": { "template": "@max(§, §)", "params": ["ego", "other"] }
            },
            "rotunda": {
                "ts": { "template": "Math.round(§)", "params": ["ego"] },
                "py": { "template": "round(§)", "params": ["ego"] },
                "rs": { "template": "§.round() as i64", "params": ["ego"] },
                "cpp": { "template": "static_cast<int64_t>(std::round(§))", "params": ["ego"] },
                "zig": { "template": "@intFromFloat(@round(§))", "params": ["ego"] }
            },
            "pavimentum": {
                "ts": { "template": "Math.floor(§)", "params": ["ego"] },
                "py": { "template": "math.floor(§)", "params": ["ego"] },
                "rs": { "template": "§.floor() as i64", "params": ["ego"] },
                "cpp": { "template": "static_cast<int64_t>(std::floor(§))", "params": ["ego"] },
                "zig": { "template": "@intFromFloat(@floor(§))", "params": ["ego"] }
            },
            "tectum": {
                "ts": { "template": "Math.ceil(§)", "params": ["ego"] },
                "py": { "template": "math.ceil(§)", "params": ["ego"] },
                "rs": { "template": "§.ceil() as i64", "params": ["ego"] },
                "cpp": { "template": "static_cast<int64_t>(std::ceil(§))", "params": ["ego"] },
                "zig": { "template": "@intFromFloat(@ceil(§))", "params": ["ego"] }
            },
            "trunca": {
                "ts": { "template": "Math.trunc(§)", "params": ["ego"] },
                "py": { "template": "math.trunc(§)", "params": ["ego"] },
                "rs": { "template": "§.trunc() as i64", "params": ["ego"] },
                "cpp": { "template": "static_cast<int64_t>(std::trunc(§))", "params": ["ego"] },
                "zig": { "template": "@intFromFloat(@trunc(§))", "params": ["ego"] }
            }
        }
    },
    "textus": {
        "methods": {
            "longitudo": {
                "ts": { "template": "§.length", "params": ["ego"] },
                "py": { "template": "len(§)", "params": ["ego"] },
                "rs": { "template": "§.len()", "params": ["ego"] },
                "cpp": { "template": "§.length()", "params": ["ego"] },
                "zig": { "template": "§.len", "params": ["ego"] }
            },
            "sectio": {
                "ts": { "method": "slice" },
                "py": { "template": "§[§:§]", "params": ["ego", "start", "end"] },
                "rs": { "template": "&§[§..§]", "params": ["ego", "start", "end"] },
                "cpp": { "template": "§.substr(§, § - §)", "params": ["ego", "start", "end"] },
                "zig": { "template": "§[§..§]", "params": ["ego", "start", "end"] }
            },
            "continet": {
                "ts": { "method": "includes" },
                "py": { "template": "§ in §", "params": ["ego", "sub"] },
                "rs": { "method": "contains" },
                "cpp": { "template": "(§.find(§) != std::string::npos)", "params": ["ego", "sub"] },
                "zig": { "template": "(std.mem.indexOf(u8, §, §) != null)", "params": ["ego", "sub"] }
            },
            "initium": {
                "ts": { "method": "startsWith" },
                "py": { "method": "startswith" },
                "rs": { "method": "starts_with" },
                "cpp": { "template": "(§.rfind(§, 0) == 0)", "params": ["ego", "prefix"] },
                "zig": { "template": "std.mem.startsWith(u8, §, §)", "params": ["ego", "prefix"] }
            },
            "finis": {
                "ts": { "method": "endsWith" },
                "py": { "method": "endswith" },
                "rs": { "method": "ends_with" },
                "cpp": { "template": "(§.size() >= §.size() && §.compare(§.size() - §.size(), §.size(), §) == 0)", "params": ["ego", "suffix"] },
                "zig": { "template": "std.mem.endsWith(u8, §, §)", "params": ["ego", "suffix"] }
            },
            "maiuscula": {
                "ts": { "method": "toUpperCase" },
                "py": { "method": "upper" },
                "rs": { "method": "to_uppercase" },
                "cpp": { "template": "[&]{ auto s = §; std::transform(s.begin(), s.end(), s.begin(), ::toupper); return s; }()", "params": ["ego"] },
                "zig": { "template": "std.ascii.upperString(§)", "params": ["ego"] }
            },
            "minuscula": {
                "ts": { "method": "toLowerCase" },
                "py": { "method": "lower" },
                "rs": { "method": "to_lowercase" },
                "cpp": { "template": "[&]{ auto s = §; std::transform(s.begin(), s.end(), s.begin(), ::tolower); return s; }()", "params": ["ego"] },
                "zig": { "template": "std.ascii.lowerString(§)", "params": ["ego"] }
            },
            "recide": {
                "ts": { "method": "trim" },
                "py": { "method": "strip" },
                "rs": { "method": "trim" },
                "cpp": { "template": "[&]{ auto s = §; s.erase(0, s.find_first_not_of(\" \\t\\n\\r\")); s.erase(s.find_last_not_of(\" \\t\\n\\r\") + 1); return s; }()", "params": ["ego"] },
                "zig": { "template": "std.mem.trim(u8, §, \" \\t\\n\\r\")", "params": ["ego"] }
            },
            "divide": {
                "ts": { "method": "split" },
                "py": { "method": "split" },
                "rs": { "template": "§.split(§).collect::<Vec<_>>()", "params": ["ego", "sep"] },
                "cpp": { "template": "@compileError(\"No single-expression split in C++ - use manual loop\")", "params": ["ego", "sep"] },
                "zig": { "template": "@compileError(\"Use std.mem.splitSequence for Zig\")", "params": ["ego", "sep"] }
            },
            "muta": {
                "ts": { "method": "replaceAll" },
                "py": { "method": "replace" },
                "rs": { "method": "replace" },
                "cpp": { "template": "std::regex_replace(§, std::regex(§), §)", "params": ["ego", "old", "new"] },
                "zig": { "template": "@compileError(\"Use std.mem.replace for Zig\")", "params": ["ego", "old", "new"] }
            }
        }
    },
    "copia": {
        "methods": {
            "adde": {
                "ts": { "method": "add" },
                "py": { "method": "add" },
                "rs": { "method": "insert" },
                "cpp": { "method": "insert" },
                "zig": { "template": "§0.adde(§2, §1)", "params": ["ego", "elem", "alloc"] }
            },
            "habet": {
                "ts": { "method": "has" },
                "py": { "template": "(§1 in §0)", "params": ["ego", "elem"] },
                "rs": { "template": "§0.contains(&§1)", "params": ["ego", "elem"] },
                "cpp": { "template": "§0.contains(§1)", "params": ["ego", "elem"] },
                "zig": { "template": "§0.habet(§1)", "params": ["ego", "elem"] }
            },
            "dele": {
                "ts": { "method": "delete" },
                "py": { "method": "discard" },
                "rs": { "template": "§0.remove(&§1)", "params": ["ego", "elem"] },
                "cpp": { "template": "§0.erase(§1)", "params": ["ego", "elem"] },
                "zig": { "template": "_ = §0.dele(§1)", "params": ["ego", "elem"] }
            },
            "longitudo": {
                "ts": { "template": "§.size", "params": ["ego"] },
                "py": { "template": "len(§)", "params": ["ego"] },
                "rs": { "template": "§.len()", "params": ["ego"] },
                "cpp": { "template": "§.size()", "params": ["ego"] },
                "zig": { "template": "§.longitudo()", "params": ["ego"] }
            },
            "vacua": {
                "ts": { "template": "§.size === 0", "params": ["ego"] },
                "py": { "template": "len(§) == 0", "params": ["ego"] },
                "rs": { "template": "§.is_empty()", "params": ["ego"] },
                "cpp": { "template": "§.empty()", "params": ["ego"] },
                "zig": { "template": "§.vacua()", "params": ["ego"] }
            },
            "purga": {
                "ts": { "method": "clear" },
                "py": { "method": "clear" },
                "rs": { "method": "clear" },
                "cpp": { "method": "clear" },
                "zig": { "template": "§.purga()", "params": ["ego"] }
            },
            "valores": {
                "ts": { "method": "values" },
                "py": { "template": "iter(§)", "params": ["ego"] },
                "rs": { "template": "§.iter()", "params": ["ego"] },
                "cpp": { "template": "§", "params": ["ego"] },
                "zig": { "template": "§.valores()", "params": ["ego"] }
            },
            "perambula": {
                "ts": { "method": "forEach" },
                "py": { "template": "[(§1)(x) for x in §0]", "params": ["ego", "fn"] },
                "rs": { "template": "§0.iter().for_each(§1)", "params": ["ego", "fn"] },
                "cpp": { "template": "std::ranges::for_each(§0, §1)", "params": ["ego", "fn"] },
                "zig": { "template": "@compileError(\"perambula not implemented for Zig - use 'ex set.valores() pro item { ... }' loop\")", "params": ["ego", "fn"] }
            },
            "unio": {
                "ts": { "template": "new Set([...§0, ...§1])", "params": ["ego", "alia"] },
                "py": { "template": "§0 | §1", "params": ["ego", "alia"] },
                "rs": { "template": "faber::copia_unio(&§0, &§1)", "params": ["ego", "alia"] },
                "cpp": { "template": "faber::copia_unio(§0, §1)", "params": ["ego", "alia"] },
                "zig": { "template": "@compileError(\"unio not implemented for Zig - use explicit loop to merge sets\")", "params": ["ego", "alia"] }
            },
            "intersectio": {
                "ts": { "template": "new Set([...§0].filter(x => §1.has(x)))", "params": ["ego", "alia"] },
                "py": { "template": "§0 & §1", "params": ["ego", "alia"] },
                "rs": { "template": "faber::copia_intersectio(&§0, &§1)", "params": ["ego", "alia"] },
                "cpp": { "template": "faber::copia_intersectio(§0, §1)", "params": ["ego", "alia"] },
                "zig": { "template": "@compileError(\"intersectio not implemented for Zig - use explicit loop\")", "params": ["ego", "alia"] }
            },
            "differentia": {
                "ts": { "template": "new Set([...§0].filter(x => !§1.has(x)))", "params": ["ego", "alia"] },
                "py": { "template": "§0 - §1", "params": ["ego", "alia"] },
                "rs": { "template": "faber::copia_differentia(&§0, &§1)", "params": ["ego", "alia"] },
                "cpp": { "template": "faber::copia_differentia(§0, §1)", "params": ["ego", "alia"] },
                "zig": { "template": "@compileError(\"differentia not implemented for Zig - use explicit loop\")", "params": ["ego", "alia"] }
            },
            "symmetrica": {
                "ts": { "template": "new Set([...[...§0].filter(x => !§1.has(x)), ...[...§1].filter(x => !§0.has(x))])", "params": ["ego", "alia"] },
                "py": { "template": "§0 ^ §1", "params": ["ego", "alia"] },
                "rs": { "template": "faber::copia_symmetrica(&§0, &§1)", "params": ["ego", "alia"] },
                "cpp": { "template": "faber::copia_symmetrica(§0, §1)", "params": ["ego", "alia"] },
                "zig": { "template": "@compileError(\"symmetrica not implemented for Zig - use explicit loop\")", "params": ["ego", "alia"] }
            },
            "subcopia": {
                "ts": { "template": "[...§0].every(x => §1.has(x))", "params": ["ego", "alia"] },
                "py": { "template": "§0 <= §1", "params": ["ego", "alia"] },
                "rs": { "template": "§0.is_subset(&§1)", "params": ["ego", "alia"] },
                "cpp": { "template": "faber::copia_subcopia(§0, §1)", "params": ["ego", "alia"] },
                "zig": { "template": "@compileError(\"subcopia not implemented for Zig - use explicit loop\")", "params": ["ego", "alia"] }
            },
            "supercopia": {
                "ts": { "template": "[...§1].every(x => §0.has(x))", "params": ["ego", "alia"] },
                "py": { "template": "§0 >= §1", "params": ["ego", "alia"] },
                "rs": { "template": "§0.is_superset(&§1)", "params": ["ego", "alia"] },
                "cpp": { "template": "faber::copia_supercopia(§0, §1)", "params": ["ego", "alia"] },
                "zig": { "template": "@compileError(\"supercopia not implemented for Zig - use explicit loop\")", "params": ["ego", "alia"] }
            },
            "inLista": {
                "ts": { "template": "[...§]", "params": ["ego"] },
                "py": { "template": "list(§)", "params": ["ego"] },
                "rs": { "template": "faber::copia_in_lista(&§)", "params": ["ego"] },
                "cpp": { "template": "faber::copia_in_lista(§)", "params": ["ego"] },
                "zig": { "template": "@compileError(\"inLista not implemented for Zig - iterate with ex...pro into ArrayList\")", "params": ["ego"] }
            }
        }
    },
    "lista": {
        "methods": {
            "adde": {
                "ts": { "method": "push" },
                "py": { "method": "append" },
                "rs": { "method": "push" },
                "cpp": { "method": "push_back" },
                "zig": { "template": "§0.adde(§2, §1)", "params": ["ego", "elem", "alloc"] }
            },
            "addita": {
                "ts": { "template": "[...§, §]", "params": ["ego", "elem"] },
                "py": { "template": "[*§, §]", "params": ["ego", "elem"] },
                "rs": { "template": "faber::lista_addita(&§0, §1)", "params": ["ego", "elem"] },
                "cpp": { "template": "faber::lista_addita(§0, §1)", "params": ["ego", "elem"] },
                "zig": { "template": "§0.addita(§2, §1)", "params": ["ego", "elem", "alloc"] }
            },
            "praepone": {
                "ts": { "method": "unshift" },
                "py": { "template": "§.insert(0, §)", "params": ["ego", "elem"] },
                "rs": { "template": "§.insert(0, §)", "params": ["ego", "elem"] },
                "cpp": { "template": "§.insert(§.begin(), §)", "params": ["ego", "elem"] },
                "zig": { "template": "§0.praepone(§2, §1)", "params": ["ego", "elem", "alloc"] }
            },
            "praeposita": {
                "ts": { "template": "[§1, ...§0]", "params": ["ego", "elem"] },
                "py": { "template": "[§1, *§0]", "params": ["ego", "elem"] },
                "rs": { "template": "faber::lista_praeposita(&§0, §1)", "params": ["ego", "elem"] },
                "cpp": { "template": "faber::lista_praeposita(§0, §1)", "params": ["ego", "elem"] },
                "zig": { "template": "§0.praeposita(§2, §1)", "params": ["ego", "elem", "alloc"] }
            },
            "remove": {
                "ts": { "method": "pop" },
                "py": { "method": "pop" },
                "rs": { "template": "§.pop()", "params": ["ego"] },
                "cpp": { "template": "faber::lista_remove(§0)", "params": ["ego"] },
                "zig": { "template": "§.remove()", "params": ["ego"] }
            },
            "remota": {
                "ts": { "template": "§.slice(0, -1)", "params": ["ego"] },
                "py": { "template": "§[:-1]", "params": ["ego"] },
                "rs": { "template": "§0[..§0.len().saturating_sub(1)].to_vec()", "params": ["ego"] },
                "cpp": { "template": "std::vector(§0.begin(), §0.end() - 1)", "params": ["ego"] },
                "zig": { "template": "§.remota(§)", "params": ["ego", "alloc"] }
            },
            "decapita": {
                "ts": { "method": "shift" },
                "py": { "template": "§.pop(0)", "params": ["ego"] },
                "rs": { "template": "§.remove(0)", "params": ["ego"] },
                "cpp": { "template": "faber::lista_decapita(§0)", "params": ["ego"] },
                "zig": { "template": "§.decapita()", "params": ["ego"] }
            },
            "decapitata": {
                "ts": { "template": "§.slice(1)", "params": ["ego"] },
                "py": { "template": "§[1:]", "params": ["ego"] },
                "rs": { "template": "§[1..].to_vec()", "params": ["ego"] },
                "cpp": { "template": "std::vector(§0.begin() + 1, §0.end())", "params": ["ego"] },
                "zig": { "template": "§.decapitata(§)", "params": ["ego", "alloc"] }
            },
            "purga": {
                "ts": { "template": "§.length = 0", "params": ["ego"] },
                "py": { "method": "clear" },
                "rs": { "method": "clear" },
                "cpp": { "method": "clear" },
                "zig": { "template": "§.purga()", "params": ["ego"] }
            },
            "primus": {
                "ts": { "template": "§[0]", "params": ["ego"] },
                "py": { "template": "§[0]", "params": ["ego"] },
                "rs": { "template": "§.first()", "params": ["ego"] },
                "cpp": { "template": "§.front()", "params": ["ego"] },
                "zig": { "template": "§.primus()", "params": ["ego"] }
            },
            "ultimus": {
                "ts": { "template": "§.at(-1)", "params": ["ego"] },
                "py": { "template": "§[-1]", "params": ["ego"] },
                "rs": { "template": "§.last()", "params": ["ego"] },
                "cpp": { "template": "§.back()", "params": ["ego"] },
                "zig": { "template": "§.ultimus()", "params": ["ego"] }
            },
            "accipe": {
                "ts": { "template": "§[§]", "params": ["ego", "idx"] },
                "py": { "template": "§[§]", "params": ["ego", "idx"] },
                "rs": { "template": "§.get(§)", "params": ["ego", "idx"] },
                "cpp": { "template": "§.at(§)", "params": ["ego", "idx"] },
                "zig": { "template": "§.accipe(§)", "params": ["ego", "idx"] }
            },
            "longitudo": {
                "ts": { "template": "§.length", "params": ["ego"] },
                "py": { "template": "len(§)", "params": ["ego"] },
                "rs": { "template": "§.len()", "params": ["ego"] },
                "cpp": { "template": "§.size()", "params": ["ego"] },
                "zig": { "template": "§.longitudo()", "params": ["ego"] }
            },
            "vacua": {
                "ts": { "template": "§.length === 0", "params": ["ego"] },
                "py": { "template": "len(§) == 0", "params": ["ego"] },
                "rs": { "template": "§.is_empty()", "params": ["ego"] },
                "cpp": { "template": "§.empty()", "params": ["ego"] },
                "zig": { "template": "§.vacua()", "params": ["ego"] }
            },
            "continet": {
                "ts": { "method": "includes" },
                "py": { "template": "(§1 in §0)", "params": ["ego", "elem"] },
                "rs": { "template": "§0.contains(&§1)", "params": ["ego", "elem"] },
                "cpp": { "template": "(std::find(§0.begin(), §0.end(), §1) != §0.end())", "params": ["ego", "elem"] },
                "zig": { "template": "§.continet(§)", "params": ["ego", "elem"] }
            },
            "indiceDe": {
                "ts": { "method": "indexOf" },
                "py": { "template": "§0.index(§1)", "params": ["ego", "elem"] },
                "rs": { "template": "§0.iter().position(|e| e == &§1)", "params": ["ego", "elem"] },
                "cpp": { "template": "faber::lista_indice_de(§0, §1)", "params": ["ego", "elem"] },
                "zig": { "template": "§.indiceDe(§)", "params": ["ego", "elem"] }
            },
            "inveni": {
                "ts": { "method": "find" },
                "py": { "template": "next(filter(§1, §0), None)", "params": ["ego", "pred"] },
                "rs": { "template": "§0.iter().find(§1)", "params": ["ego", "pred"] },
                "cpp": { "template": "*std::find_if(§0.begin(), §0.end(), §1)", "params": ["ego", "pred"] },
                "zig": { "template": "§.inveni(§)", "params": ["ego", "pred"] }
            },
            "inveniIndicem": {
                "ts": { "method": "findIndex" },
                "py": { "template": "next((i for i, x in enumerate(§0) if (§1)(x)), -1)", "params": ["ego", "pred"] },
                "rs": { "template": "§0.iter().position(§1)", "params": ["ego", "pred"] },
                "cpp": { "template": "faber::lista_inveni_indicem(§0, §1)", "params": ["ego", "pred"] },
                "zig": { "template": "§.inveniIndicem(§)", "params": ["ego", "pred"] }
            },
            "omnes": {
                "ts": { "method": "every" },
                "py": { "template": "all(map(§, §))", "params": ["ego", "pred"] },
                "rs": { "template": "§.iter().all(§)", "params": ["ego", "pred"] },
                "cpp": { "template": "std::ranges::all_of(§, §)", "params": ["ego", "pred"] },
                "zig": { "template": "§.omnes(§)", "params": ["ego", "pred"] }
            },
            "aliquis": {
                "ts": { "method": "some" },
                "py": { "template": "any(map(§, §))", "params": ["ego", "pred"] },
                "rs": { "template": "§.iter().any(§)", "params": ["ego", "pred"] },
                "cpp": { "template": "std::ranges::any_of(§, §)", "params": ["ego", "pred"] },
                "zig": { "template": "§.aliquis(§)", "params": ["ego", "pred"] }
            },
            "filtrata": {
                "ts": { "method": "filter" },
                "py": { "template": "list(filter(§, §))", "params": ["ego", "pred"] },
                "rs": { "template": "§.iter().filter(§).cloned().collect::<Vec<_>>()", "params": ["ego", "pred"] },
                "cpp": { "template": "(§ | std::views::filter(§) | std::ranges::to<std::vector>())", "params": ["ego", "pred"] },
                "zig": { "template": "§0.filtrata(§2, §1)", "params": ["ego", "pred", "alloc"] }
            },
            "mappata": {
                "ts": { "method": "map" },
                "py": { "template": "list(map(§, §))", "params": ["ego", "fn"] },
                "rs": { "template": "§.iter().map(§).collect::<Vec<_>>()", "params": ["ego", "fn"] },
                "cpp": { "template": "(§ | std::views::transform(§) | std::ranges::to<std::vector>())", "params": ["ego", "fn"] },
                "zig": { "template": "§0.mappata(§2, §1)", "params": ["ego", "fn", "alloc"] }
            },
            "explanata": {
                "ts": { "method": "flatMap" },
                "py": { "template": "[y for x in § for y in (§)(x)]", "params": ["ego", "fn"] },
                "rs": { "template": "§.iter().flat_map(§).collect::<Vec<_>>()", "params": ["ego", "fn"] },
                "cpp": { "template": "(§ | std::views::transform(§) | std::views::join | std::ranges::to<std::vector>())", "params": ["ego", "fn"] }
            },
            "plana": {
                "ts": { "method": "flat" },
                "py": { "template": "[y for x in § for y in x]", "params": ["ego"] },
                "rs": { "template": "§.iter().flatten().cloned().collect::<Vec<_>>()", "params": ["ego"] },
                "cpp": { "template": "(§ | std::views::join | std::ranges::to<std::vector>())", "params": ["ego"] }
            },
            "inversa": {
                "ts": { "template": "[...§].reverse()", "params": ["ego"] },
                "py": { "template": "§[::-1]", "params": ["ego"] },
                "rs": { "template": "§.iter().rev().cloned().collect::<Vec<_>>()", "params": ["ego"] },
                "cpp": { "template": "faber::lista_inversa(§)", "params": ["ego"] },
                "zig": { "template": "§.inversa(§)", "params": ["ego", "alloc"] }
            },
            "ordinata": {
                "ts": { "template": "[...§].sort()", "params": ["ego"] },
                "py": { "template": "sorted(§)", "params": ["ego"] },
                "rs": { "template": "faber::lista_ordinata(&§)", "params": ["ego"] },
                "cpp": { "template": "faber::lista_ordinata(§)", "params": ["ego"] },
                "zig": { "template": "§.ordinata(§)", "params": ["ego", "alloc"] }
            },
            "sectio": {
                "ts": { "method": "slice" },
                "py": { "template": "§[§:§]", "params": ["ego", "start", "end"] },
                "rs": { "template": "§[§..§].to_vec()", "params": ["ego", "start", "end"] },
                "cpp": { "template": "std::vector(§0.begin() + §1, §0.begin() + §2)", "params": ["ego", "start", "end"] },
                "zig": { "template": "§0.sectio(§3, §1, §2)", "params": ["ego", "start", "end", "alloc"] }
            },
            "prima": {
                "ts": { "template": "§.slice(0, §)", "params": ["ego", "n"] },
                "py": { "template": "§[:§]", "params": ["ego", "n"] },
                "rs": { "template": "§.iter().take(§).cloned().collect::<Vec<_>>()", "params": ["ego", "n"] },
                "cpp": { "template": "(§ | std::views::take(§) | std::ranges::to<std::vector>())", "params": ["ego", "n"] },
                "zig": { "template": "§0.prima(§2, §1)", "params": ["ego", "n", "alloc"] }
            },
            "ultima": {
                "ts": { "template": "§.slice(-§)", "params": ["ego", "n"] },
                "py": { "template": "§[-§:]", "params": ["ego", "n"] },
                "rs": { "template": "faber::lista_ultima(&§0, §1)", "params": ["ego", "n"] },
                "cpp": { "template": "faber::lista_ultima(§0, §1)", "params": ["ego", "n"] },
                "zig": { "template": "§0.ultima(§2, §1)", "params": ["ego", "n", "alloc"] }
            },
            "omissa": {
                "ts": { "template": "§.slice(§)", "params": ["ego", "n"] },
                "py": { "template": "§[§:]", "params": ["ego", "n"] },
                "rs": { "template": "§.iter().skip(§).cloned().collect::<Vec<_>>()", "params": ["ego", "n"] },
                "cpp": { "template": "(§ | std::views::drop(§) | std::ranges::to<std::vector>())", "params": ["ego", "n"] },
                "zig": { "template": "§0.omissa(§2, §1)", "params": ["ego", "n", "alloc"] }
            },
            "reducta": {
                "ts": { "method": "reduce" },
                "py": { "template": "functools.reduce(§, §, §)", "params": ["ego", "fn", "init"] },
                "rs": { "template": "§.iter().fold(§, §)", "params": ["ego", "fn", "init"] },
                "cpp": { "template": "std::ranges::fold_left(§, §, §)", "params": ["ego", "fn", "init"] },
                "zig": { "template": "§.reducta(§, §)", "params": ["ego", "fn", "init"] }
            },
            "filtra": {
                "ts": { "template": "(() => { for (let i = §.length - 1; i >= 0; i--) { if (!(§)(§[i])) §.splice(i, 1); } })()", "params": ["ego", "pred"] },
                "py": { "template": "§[:] = [x for x in § if (§)(x)]", "params": ["ego", "pred"] },
                "cpp": { "template": "§0.erase(std::remove_if(§0.begin(), §0.end(), [&](auto& x) { return !(§1)(x); }), §0.end())", "params": ["ego", "pred"] }
            },
            "ordina": {
                "ts": { "template": "§.sort()", "params": ["ego"] },
                "py": { "template": "§.sort()", "params": ["ego"] },
                "rs": { "template": "§.sort()", "params": ["ego"] },
                "cpp": { "template": "std::ranges::sort(§)", "params": ["ego"] },
                "zig": { "template": "§.ordina()", "params": ["ego"] }
            },
            "inverte": {
                "ts": { "method": "reverse" },
                "py": { "template": "§.reverse()", "params": ["ego"] },
                "rs": { "template": "§.reverse()", "params": ["ego"] },
                "cpp": { "template": "std::ranges::reverse(§)", "params": ["ego"] },
                "zig": { "template": "§.inverte()", "params": ["ego"] }
            },
            "perambula": {
                "ts": { "method": "forEach" },
                "py": { "template": "[(§)(x) for x in §]", "params": ["ego", "fn"] },
                "rs": { "template": "§.iter().for_each(§)", "params": ["ego", "fn"] },
                "cpp": { "template": "std::ranges::for_each(§, §)", "params": ["ego", "fn"] },
                "zig": { "template": "§.perambula(§)", "params": ["ego", "fn"] }
            },
            "coniunge": {
                "ts": { "method": "join" },
                "py": { "template": "§.join(§)", "params": ["ego", "sep"] },
                "rs": { "template": "§.join(§)", "params": ["ego", "sep"] },
                "cpp": { "template": "faber::lista_coniunge(§0, §1)", "params": ["ego", "sep"] }
            },
            "summa": {
                "ts": { "template": "§.reduce((a, b) => a + b, 0)", "params": ["ego"] },
                "py": { "template": "sum(§)", "params": ["ego"] },
                "rs": { "template": "§.iter().sum::<i64>()", "params": ["ego"] },
                "cpp": { "template": "std::accumulate(§0.begin(), §0.end(), 0)", "params": ["ego"] },
                "zig": { "template": "§.summa()", "params": ["ego"] }
            },
            "medium": {
                "ts": { "template": "(§0.reduce((a, b) => a + b, 0) / §0.length)", "params": ["ego"] },
                "py": { "template": "(sum(§0) / len(§0))", "params": ["ego"] },
                "rs": { "template": "(§0.iter().sum::<i64>() as f64 / §0.len() as f64)", "params": ["ego"] },
                "cpp": { "template": "(std::accumulate(§0.begin(), §0.end(), 0.0) / §0.size())", "params": ["ego"] },
                "zig": { "template": "§.medium()", "params": ["ego"] }
            },
            "minimus": {
                "ts": { "template": "Math.min(...§)", "params": ["ego"] },
                "py": { "template": "min(§)", "params": ["ego"] },
                "rs": { "template": "§.iter().min()", "params": ["ego"] },
                "cpp": { "template": "*std::ranges::min_element(§)", "params": ["ego"] },
                "zig": { "template": "§.minimus()", "params": ["ego"] }
            },
            "maximus": {
                "ts": { "template": "Math.max(...§)", "params": ["ego"] },
                "py": { "template": "max(§)", "params": ["ego"] },
                "rs": { "template": "§.iter().max()", "params": ["ego"] },
                "cpp": { "template": "*std::ranges::max_element(§)", "params": ["ego"] },
                "zig": { "template": "§.maximus()", "params": ["ego"] }
            },
            "minimusPer": {
                "ts": { "template": "§.reduce((min, x) => (§)(x) < (§)(min) ? x : min)", "params": ["ego", "fn"] },
                "rs": { "template": "§.iter().min_by_key(§)", "params": ["ego", "fn"] },
                "cpp": { "template": "*std::ranges::min_element(§, [&](auto& a, auto& b) { return (§)(a) < (§)(b); })", "params": ["ego", "fn"] }
            },
            "maximusPer": {
                "ts": { "template": "§.reduce((max, x) => (§)(x) > (§)(max) ? x : max)", "params": ["ego", "fn"] },
                "rs": { "template": "§.iter().max_by_key(§)", "params": ["ego", "fn"] },
                "cpp": { "template": "*std::ranges::max_element(§, [&](auto& a, auto& b) { return (§)(a) < (§)(b); })", "params": ["ego", "fn"] }
            },
            "numera": {
                "ts": { "template": "§.filter(§).length", "params": ["ego", "pred"] },
                "py": { "template": "sum(1 for x in § if (§)(x))", "params": ["ego", "pred"] },
                "rs": { "template": "§.iter().filter(§).count()", "params": ["ego", "pred"] },
                "cpp": { "template": "std::ranges::count_if(§, §)", "params": ["ego", "pred"] },
                "zig": { "template": "§.numera(§)", "params": ["ego", "pred"] }
            },
            "congrega": {
                "ts": { "template": "Object.groupBy(§, §)", "params": ["ego", "fn"] },
                "py": { "template": "{k: list(g) for k, g in itertools.groupby(sorted(§, key=§), key=§)}", "params": ["ego", "fn"] },
                "rs": { "template": "faber::lista_congrega(&§0, §1)", "params": ["ego", "fn"] },
                "cpp": { "template": "faber::lista_congrega(§0, §1)", "params": ["ego", "fn"] }
            },
            "unica": {
                "ts": { "template": "[...new Set(§)]", "params": ["ego"] },
                "py": { "template": "list(dict.fromkeys(§))", "params": ["ego"] },
                "rs": { "template": "faber::lista_unica(&§)", "params": ["ego"] },
                "cpp": { "template": "faber::lista_unica(§)", "params": ["ego"] }
            },
            "planaOmnia": {
                "ts": { "template": "§.flat(Infinity)", "params": ["ego"] },
                "cpp": { "template": "(§ | std::views::join | std::ranges::to<std::vector>())", "params": ["ego"] }
            },
            "fragmenta": {
                "ts": { "template": "Array.from({ length: Math.ceil(§.length / §) }, (_, i) => §.slice(i * §, i * § + §))", "params": ["ego", "n"] },
                "py": { "template": "[§[i:i+§] for i in range(0, len(§), §)]", "params": ["ego", "n"] },
                "rs": { "template": "§.chunks(§).map(|c| c.to_vec()).collect::<Vec<_>>()", "params": ["ego", "n"] },
                "cpp": { "template": "faber::lista_fragmenta(§0, §1)", "params": ["ego", "n"] }
            },
            "densa": {
                "ts": { "template": "§.filter(Boolean)", "params": ["ego"] },
                "py": { "template": "[x for x in § if x]", "params": ["ego"] },
                "cpp": { "template": "(§ | std::views::filter([](auto& x) { return static_cast<bool>(x); }) | std::ranges::to<std::vector>())", "params": ["ego"] }
            },
            "partire": {
                "ts": { "template": "§.reduce(([t, f], x) => (§)(x) ? [[...t, x], f] : [t, [...f, x]], [[], []])", "params": ["ego", "pred"] },
                "py": { "template": "[[x for x in § if (§)(x)], [x for x in § if not (§)(x)]]", "params": ["ego", "pred"] },
                "rs": { "template": "faber::lista_partire(&§0, §1)", "params": ["ego", "pred"] },
                "cpp": { "template": "faber::lista_partire(§0, §1)", "params": ["ego", "pred"] }
            },
            "miscita": {
                "ts": { "template": "(() => { const a = [...§]; for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; } return a; })()", "params": ["ego"] },
                "py": { "template": "random.shuffle(§)", "params": ["ego"] },
                "cpp": { "template": "faber::lista_miscita(§)", "params": ["ego"] }
            },
            "specimen": {
                "ts": { "template": "§0[Math.floor(Math.random() * §0.length)]", "params": ["ego"] },
                "py": { "template": "random.choice(§)", "params": ["ego"] },
                "cpp": { "template": "faber::lista_specimen(§0)", "params": ["ego"] }
            },
            "specimina": {
                "ts": { "template": "(() => { const a = [...§]; for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; } return a.slice(0, §); })()", "params": ["ego", "n"] },
                "py": { "template": "random.sample(§, §)", "params": ["ego", "n"] },
                "cpp": { "template": "faber::lista_specimina(§0, §1)", "params": ["ego", "n"] }
            }
        }
    }
};

# Lookup translation for target/collection/method
@ publica
functio getNormaTranslation(textus target, textus collection, textus method) fit VerteTranslation? {
    fixum coll = norma[collection]
    si coll == nihil reddit nihil

    fixum methodMap = coll.methods[method]
    si methodMap == nihil reddit nihil

    redde methodMap[target]
}
