# TypeScript Expression Generator - Scriptum (Format Strings)
#
# Generates template literals with interpolation.
#
# TRANSFORMS:
#   scriptum("Hello §!", name)      -> `Hello ${name}!`
#   scriptum("x = §", x)            -> `x = ${x}`
#   scriptum("§1 before §0", a, b)  -> `${b} before ${a}` (indexed)
#   scriptum("no args")             -> "no args"

importa ex "../../../ast/expressia" privata Expressia
importa ex "../nucleus" privata TsGenerator

# External declaration - implementation lives in index.fab
importa ex "./index" privata genExpressia

# Generate scriptum (format string) expression
# Supports both § (positional) and §0, §1, etc. (indexed) placeholders
@ publica
functio genScriptum(in TsGenerator g, de textus exemplar, de lista<Expressia> argumenta) -> textus {
    # WHY: No-arg scriptum should emit a plain string literal (no template).
    si argumenta.longitudo() == 0 {
        redde scriptum("\"§\"", exemplar)
    }

    # Convert scriptum("Hello, !", name) to template literal
    varia result = "`"
    varia implicitIdx = 0
    varia i = 0

    dum i < exemplar.longitudo() {
        fixum c = exemplar[i]
        si c == "§" {
            # Check for explicit index (§0, §1, etc.)
            varia explicitIdxNum = 0
            varia hasExplicitIdx = falsum
            dum i + 1 < exemplar.longitudo() {
                fixum nextChar = exemplar[i + 1]
                si nextChar >= "0" et nextChar <= "9" {
                    # WHY: Build number digit by digit: explicitIdxNum * 10 + digit
                    fixum digit = nextChar.charCodeAt(0) - 48  # '0' is char code 48
                    explicitIdxNum = explicitIdxNum * 10 + digit
                    hasExplicitIdx = verum
                    i += 1
                } secus {
                    rumpe
                }
            }

            # Use explicit index if provided, otherwise implicit
            fixum idx = hasExplicitIdx sic explicitIdxNum secus implicitIdx
            si non hasExplicitIdx {
                implicitIdx += 1
            }

            fixum arg = (idx < argumenta.longitudo()) sic genExpressia(g, argumenta[idx]) secus "undefined"
            result = result + "${" + arg + "}"
        } secus {
            si c == "`" {
                result = result + "\\`"
            } sin c == "$" {
                result = result + "\\$"
            } secus {
                result = result + c
            }
        }
        i += 1
    }

    result = result + "`"
    redde result
}
