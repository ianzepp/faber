# TypeScript Expression Generator - Dispatch
#
# Routes expression AST nodes to their specific generators.

§ ex "../../../ast/expressia" importa Expressia, LitteraGenus, ObiectumProprietas, ClausuraParametrum, MorphologiaInvocatio, ClausuraCorpus
§ ex "../../../ast/expressia" importa AbFiltrum, CatenaGradus, AssignatioExpressia, MembrumExpressia
§ ex "../../../ast/expressia" importa InnatumExpressia, ObiectumExpressia, SeriesExpressia, Nomen, AmbitusExpressia
§ ex "../../../ast/expressia" importa Littera, UnariaExpressia
§ ex "../../../ast/sententia" importa Sententia, VariaGenus
§ ex "../../../ast/typus" importa TypusAnnotatio, TypusParametrum, Typus
§ ex "../nucleus" importa TsGenerator
§ ex "../typus" importa genTypus
§ ex "../../../parser/morphologia" importa parseMethodum
§ ex "../../radices" importa generaListaMethodum
§ ex "../../innatum" importa getInnatumTranslation, InnatumTranslation
§ ex "./littera" importa genLittera, genLitteraExemplar
§ ex "./scriptum" importa genScriptum
§ ex "./ambitus" importa genAmbitusExpressia
§ ex "./est" importa genEstExpressia, genEstExpressiaNegata
§ ex "./obiectum" importa genObiectum
§ ex "./ab" importa genAbExpressia, applicaCatenaGradus
# =============================================================================
# EXPRESSION DISPATCH
# =============================================================================

# Generate TypeScript code for an expression
@ publica
functio genExpressia(in TsGenerator g, de Expressia expr) -> textus {
    discerne expr {
        # Identifiers
        casu Nomen ut e {
            si g.inAbUbi {
                redde scriptum("§.§", g.abUbiParam, e.valor)
            }
            redde e.valor qua textus
        }

        casu EgoExpressia {
            redde "this"
        }

        # Literals
        casu Littera ut e {
            redde genLittera(e.species qua LitteraGenus, e.crudus qua textus)
        }

        casu LitteraExemplar ut e {
            redde genLitteraExemplar(g, e.partes qua lista<textus>, e.expressiae qua lista<Expressia>)
        }

        casu LitteraRegex ut e {
            g.requisita.usesRegex = verum
            # Extract inline flags (e.g., "(?i)pattern" -> flags="i", pattern="pattern")
            # JS doesn't support inline flags natively, so we extract and append them.
            fixum parts = extractInlineFlags(e.forma)
            fixum flags = parts[0]
            fixum rawPattern = parts[1]
            fixum pattern = escapaRegex(rawPattern)
            redde scriptum("/§/§", pattern, flags)
        }

        # Binary and unary
        casu BinariaExpressia ut e {
            fixum sinister = genExpressia(g, e.sinister)
            fixum dexter = genExpressia(g, e.dexter)
            varia signum = e.signum qua textus

            # WHY: Normalize keyword operators to JS equivalents.
            elige signum {
                casu "et" { signum = "&&" }
                casu "aut" { signum = "||" }
                casu "vel" { signum = "??" }
            }

            # WHY: Range containment has target-specific lowering.
            si signum == "intra" {
                discerne e.dexter {
                    casu AmbitusExpressia ut r {
                        fixum initium = genExpressia(g, r.initium)
                        fixum finis = genExpressia(g, r.finis)
                        fixum op = (r.inclusivum qua bivalens) sic "<=" secus "<"
                        redde scriptum("(§ >= § && § § §)", sinister, initium, sinister, op, finis)
                    }
                    casu _ tacet
                }
                redde scriptum("(§ intra §)", sinister, dexter)
            }

            # WHY: Set membership lowers to includes() in TS.
            si signum == "inter" {
                redde scriptum("§.includes(§)", dexter, sinister)
            }

            redde scriptum("(§ § §)", sinister, signum, dexter)
        }

        casu UnariaExpressia ut e {
            fixum arg = genExpressia(g, e.argumentum)

            # WHY: Null/empty checks are language-level operators, not JS prefixes.
            elige e.signum qua textus {
                casu "nulla" {
                    redde scriptum("(§ == null || (Array.isArray(§) || typeof § === 'string' ? §.length === 0 : typeof § === 'object' ? Object.keys(§).length === 0 : !§))", arg, arg, arg, arg, arg, arg, arg)
                }
                casu "nonnulla" {
                    redde scriptum("(§ != null && (Array.isArray(§) || typeof § === 'string' ? §.length > 0 : typeof § === 'object' ? Object.keys(§).length > 0 : Boolean(§)))", arg, arg, arg, arg, arg, arg, arg)
                }
                casu "nihil" {
                    redde scriptum("(§ == null)", arg)
                }
                casu "nonnihil" {
                    redde scriptum("(§ != null)", arg)
                }
                casu "negativum" {
                    redde scriptum("(§ < 0)", arg)
                }
                casu "positivum" {
                    redde scriptum("(§ > 0)", arg)
                }
                casu "verum" {
                    redde scriptum("(§ === true)", arg)
                }
                casu "falsum" {
                    redde scriptum("(§ === false)", arg)
                }
            }

            # WHY: Preserve correct precedence for negated est checks.
            si e.signum == "!" {
                discerne e.argumentum {
                    casu EstExpressia ut est {
                        redde genEstExpressiaNegata(g, est.expressia, est.scopus novum TypusAnnotatio)
                    }
                    casu _ tacet
                }
            }

            redde scriptum("§§", e.signum, arg)
        }

        casu AssignatioExpressia ut e {
            fixum tabulaRes = genTabulaAssignatio(g, e)
            si nonnihil tabulaRes { redde tabulaRes }

            redde scriptum("§ § §", genExpressia(g, e.sinister), e.signum, genNudaExpressia(g, e.dexter))
        }

        casu CondicioExpressia ut e {
            redde scriptum("§ ? § : §", genExpressia(g, e.condicio), genExpressia(g, e.consequens), genExpressia(g, e.alternans))
        }

        casu AmbitusExpressia ut e {
            redde genAmbitusExpressia(g, e)
        }

        casu QuaExpressia ut e {
            redde scriptum("(§ as §)", genExpressia(g, e.expressia), genTypus(g, e.scopus novum TypusAnnotatio))
        }

        casu PostfixNovumExpressia ut e {
            redde scriptum("new §(§)", genTypus(g, e.scopus novum TypusAnnotatio), genExpressia(g, e.expressia))
        }

        casu InnatumExpressia ut e {
            fixum typusNomen = (e.scopus novum TypusAnnotatio).nomen qua textus

            si typusNomen == "tabula" { redde genInnatumTabula(g, e) }
            si typusNomen == "lista" { redde genInnatumLista(g, e) }
            si typusNomen == "copia" { redde genInnatumCopia(g, e) }

            mori scriptum("Codegen error: innatum only supports tabula, lista, copia - got '§'", typusNomen)
        }

        casu EstExpressia ut e {
            redde genEstExpressia(g, e.expressia, e.scopus novum TypusAnnotatio)
        }

        casu PraefixumExpressia ut e {
            discerne e.corpus {
                casu Massa ut m {
                    discerne m.valor {
                        casu MassaSententia ut body {
                            g.intraProfundum()
                            fixum rendered = genPraefixumMassa(g, body.corpus)
                            g.exiProfundum()
                            redde scriptum("(() => {\n§\n§})()", rendered, g.ind())
                        }
                        casu _ tacet
                    }
                }
                casu Expr ut expr {
                    redde scriptum("(§)", genExpressia(g, expr.valor))
                }
            }
            # Fallback: expression form.
            redde scriptum("(§)", genExpressia(g, finge Littera { locus: e.locus, species: LitteraGenus.Nihil, crudus: "nihil" } qua Expressia))
        }

        # Calls and member access
        casu VocatioExpressia ut e {
            varia args = [] innatum lista<textus>
            ex (e.argumenta qua lista<Expressia>) fixum arg {
                args.appende(genExpressia(g, arg))
            }

            # WHY: Check for stdlib method translation via norma-registry.
            # This handles lista, tabula, copia, textus, etc. method calls.
            discerne e.vocatum {
                casu MembrumExpressia ut m {
                    si non (m.computatum qua bivalens) {
                        discerne m.proprietas {
                            casu Nomen ut prop {
                                fixum methodNomen = prop.valor qua textus
                                fixum obj = genExpressia(g, m.obiectum)

                                # WHY: Try innatum translation for builtin types.
                                si nonnihil e.morphologia {
                                    fixum recipiens = (e.morphologia novum MorphologiaInvocatio).recipiens
                                    fixum translation = getInnatumTranslation("ts", recipiens, methodNomen)

                                    si nonnihil translation {
                                        # Simple method rename: use translated method name
                                        si nonnihil translation.method {
                                            fixum optMark = (e.optivum qua bivalens) sic "?." secus ""
                                            redde scriptum("§§.§(§)", obj, optMark, translation.method, args.coniunge(", "))
                                        }

                                        # Template-based translation
                                        si nonnihil translation.template et nonnihil translation.params {
                                            redde applyInnatumTemplate(translation.template qua textus, translation.params qua lista<textus>, obj, args)
                                        }
                                    }

                                    # Fallback: generaListaMethodum for lista morphology patterns
                                    fixum parsed = parseMethodum(methodNomen)
                                    si nonnihil parsed et recipiens == "lista" {
                                        fixum result = generaListaMethodum((e.morphologia novum MorphologiaInvocatio).radix, obj, args, parsed.flagga)
                                        si nonnihil result {
                                            redde result
                                        }
                                    }
                                }
                            }
                            casu _ tacet
                        }
                    }
                }
                casu _ tacet
            }

            # Default: pass through as-is
            fixum optMark = (e.optivum qua bivalens) sic "?." secus ""
            redde scriptum("§§(§)", genExpressia(g, e.vocatum), optMark, args.coniunge(", "))
        }

        casu MembrumExpressia ut e {
            fixum obj = genExpressia(g, e.obiectum)
            si e.computatum qua bivalens {
                discerne e.proprietas {
                    casu AmbitusExpressia ut a {
                        redde genSectioAccess(g, obj, a, e.optivum qua bivalens, e.nonNullum qua bivalens)
                    }
                    casu _ tacet
                }

                fixum idx = genNudaExpressia(g, e.proprietas)

                fixum tabulaNomen = invenitTabulaNomen(e.obiectum, g)
                si nonnihil tabulaNomen {
                    redde genTabulaGet(obj, idx, e.optivum qua bivalens, e.nonNullum qua bivalens)
                }

                si estNegativusIndex(e.proprietas) {
                    redde genNegativusAccess(obj, idx, e.optivum qua bivalens, e.nonNullum qua bivalens)
                }

                si e.optivum qua bivalens {
                    redde scriptum("§?.[§]", obj, idx)
                }
                si e.nonNullum qua bivalens {
                    redde scriptum("§![§]", obj, idx)
                }
                redde scriptum("§[§]", obj, idx)
            }
            # Dot access
            fixum prop = genExpressia(g, e.proprietas)
            si e.optivum qua bivalens {
                redde scriptum("§?.§", obj, prop)
            }
            si e.nonNullum qua bivalens {
                redde scriptum("§!.§", obj, prop)
            }
            redde scriptum("§.§", obj, prop)
        }

        casu NovumExpressia ut e {
            varia args = [] innatum lista<textus>
            ex (e.argumenta qua lista<Expressia>) fixum arg {
                args.appende(genExpressia(g, arg))
            }
            # WHY: novum supports optional override object as a final argument.
            si nonnihil e.initor {
                args.appende(genExpressia(g, e.initor))
            }
            redde scriptum("new §(§)", genExpressia(g, e.vocatum), args.coniunge(", "))
        }

        casu CedeExpressia ut e {
            # cede maps to yield in generators, await in async functions
            si g.inFiunt {
                redde scriptum("yield respond.item(§)", genExpressia(g, e.argumentum))
            }
            si g.inFient {
                redde scriptum("yield respond.item(await §)", genExpressia(g, e.argumentum))
            }
            si g.inCursore {
                redde scriptum("yield §", genExpressia(g, e.argumentum))
            }
            redde scriptum("await §", genExpressia(g, e.argumentum))
        }

        casu ScriptumExpressia ut e {
            redde genScriptum(g, e.exemplar qua textus, e.argumenta qua lista<Expressia>)
        }

        casu LegeExpressia ut e {
            si (e.modus qua textus) == "line" {
                # WHY: Match faber output; Bun needs readline for single-line input.
                redde "(await (async () => { const rl = require(\"readline\").createInterface({ input: process.stdin }); for await (const line of rl) { rl.close(); return line; } return \"\"; })())"
            }
            # WHY: Bun stdin reads all input via text().
            redde "await Bun.stdin.text()"
        }

        casu AbExpressia ut e {
            redde genAbExpressia(e.fons, e.negata qua bivalens, g, e.filtrum, e.gradus)
        }

        # Collections
        casu SeriesExpressia ut e {
            varia items = [] innatum lista<textus>
            ex (e.elementa qua lista<Expressia>) fixum elem {
                items.appende(genExpressia(g, elem))
            }
            redde scriptum("[§]", items.coniunge(", "))
        }

        casu ObiectumExpressia ut e {
            redde genObiectum(g, e.proprietates qua lista<ObiectumProprietas>)
        }

        casu DispersioElementum ut e {
            redde scriptum("...§", genExpressia(g, e.argumentum))
        }

        # Clausura
        casu ClausuraExpressia ut e {
            varia params = [] innatum lista<textus>
            ex (e.parametra qua lista<ClausuraParametrum>) fixum p {
                si nonnihil p.typus {
                    params.appende(scriptum("§: §", p.nomen, genTypus(g, p.typus novum TypusAnnotatio)))
                } secus {
                    params.appende(p.nomen)
                }
            }
            varia retType = ""
            si nonnihil e.typusReditus {
                retType = scriptum(": §", genTypus(g, e.typusReditus novum TypusAnnotatio))
            }
            discerne e.corpus {
                casu Massa ut m {
                    discerne m.valor {
                        casu MassaSententia ut body {
                            g.intraProfundum()
                            fixum rendered = genPraefixumMassa(g, body.corpus)
                            g.exiProfundum()
                            si rendered == "" {
                                redde scriptum("(§)§ => {}", params.coniunge(", "), retType)
                            }
                            redde scriptum("(§)§ => {\n§\n§}", params.coniunge(", "), retType, rendered, g.ind())
                        }
                        casu _ tacet
                    }
                }
                casu Expr ut expr {
                    redde scriptum("(§)§ => §", params.coniunge(", "), retType, genExpressia(g, expr.valor))
                }
            }
            redde scriptum("(§)§ => §", params.coniunge(", "), retType, genExpressia(g, finge Littera { locus: e.locus, species: LitteraGenus.Nihil, crudus: "nihil" } qua Expressia))
        }

        # Discretio construction
        casu FingeExpressia ut e {
            # finge Click { x: 10 } qua Event -> { tag: 'Click', x: 10 }
            varia props = [] innatum lista<textus>
            props.appende(scriptum("tag: '§'", e.variansNomen))
            ex (e.campi qua lista<ObiectumProprietas>) fixum campo {
                fixum key = genExpressia(g, campo.clavis)
                fixum val = genExpressia(g, campo.valor)
                props.appende(scriptum("§: §", key, val))
            }
            redde scriptum("{ § }", props.coniunge(", "))
        }

        # Type conversion
        casu ConversioExpressia ut conv {
            fixum src = genExpressia(g, conv.expressia)

            elige conv.signum qua textus {
                casu "numeratum" {
                    # Determine radix: Hex=16, Oct=8, Bin=2, Dec/default=10
                    varia radixNum = "10"
                    si nonnihil conv.radix {
                        elige conv.radix qua textus {
                            casu "Hex" { radixNum = "16" }
                            casu "Oct" { radixNum = "8" }
                            casu "Bin" { radixNum = "2" }
                        }
                    }

                    si nonnihil conv.fallback {
                        fixum fb = genExpressia(g, conv.fallback qua Expressia)
                        redde scriptum("(parseInt(§, §) || §)", src, radixNum, fb)
                    }
                    redde scriptum("parseInt(§, §)", src, radixNum)
                }

                casu "fractatum" {
                    si nonnihil conv.fallback {
                        fixum fb = genExpressia(g, conv.fallback qua Expressia)
                        redde scriptum("(parseFloat(§) || §)", src, fb)
                    }
                    redde scriptum("parseFloat(§)", src)
                }

                casu "textatum" {
                    redde scriptum("String(§)", src)
                }

                casu "bivalentum" {
                    redde scriptum("Boolean(§)", src)
                }
            }

            redde scriptum("/* unknown conversion: § */", conv.signum)
        }

        # Bit shift expression
        casu TranslatioExpressia ut t {
            fixum shifted = genExpressia(g, t.expressia)
            fixum amount = genExpressia(g, t.quantitas)
            fixum op = ((t.directio qua textus) == "dextratum") sic ">>" secus "<<"
            redde scriptum("(§ § §)", shifted, op, amount)
        }
    }

    # Fallback - should not reach here
    mori "Codegen error: unhandled expression type in genExpressia"
}

# =============================================================================
# REGEX/STRING HELPERS
# =============================================================================

# Escape forward slashes for JS regex literals.
functio escapaRegex(de textus pattern) -> textus {
    varia result = ""
    varia i = 0
    dum i < pattern.longitudo() {
        fixum c = pattern[i]
        si c == "/" {
            result = result + "\\/"
        } secus {
            result = result + c
        }
        i += 1
    }
    redde result
}

# Extract inline flags from regex pattern.
# Patterns like "(?i)test" or "(?im)test" have flags at the start.
# Returns [flags, remaining_pattern]. JS doesn't support inline flags natively.
functio extractInlineFlags(de textus pattern) -> lista<textus> {
    # Check for inline flag prefix: (?flags)
    si pattern.longitudo() >= 3 et pattern[0] == "(" et pattern[1] == "?" {
        varia i = 2
        varia flags = ""

        # Collect flag characters until we hit ')'
        dum i < pattern.longitudo() {
            fixum c = pattern[i]
            si c == ")" {
                # Found end of flags, return flags and rest of pattern
                redde [flags, pattern.sectio(i + 1, pattern.longitudo())]
            }
            # Valid regex flags: i (ignore case), m (multiline), s (dotall), g (global), u (unicode), y (sticky)
            si c inter ["i", "m", "s", "g", "u", "y"] {
                flags = flags + c
            } secus {
                # Not a simple flag group, might be a more complex construct like (?:...)
                # Return no flags, original pattern
                redde ["", pattern]
            }
            i += 1
        }
    }

    # No inline flags found
    redde ["", pattern]
}

# Minimal statement lowering for praefixum blocks (avoid codegen cycles).
functio genPraefixumMassa(in TsGenerator g, de lista<Sententia> corpus) -> textus {
    si corpus.longitudo() == 0 {
        redde ""
    }
    varia lines = [] innatum lista<textus>
    ex corpus fixum stmt {
        lines.appende(genPraefixumSententia(g, stmt))
    }
    redde lines.coniunge("\n")
}

functio genPraefixumSententia(in TsGenerator g, de Sententia stmt) -> textus {
    discerne stmt {
        casu VariaSententia ut s {
            fixum keyword = (s.species == VariaGenus.Fixum aut s.species == VariaGenus.Figendum) sic "const" secus "let"
            fixum asyncPrefix = (s.species == VariaGenus.Figendum aut s.species == VariaGenus.Variandum) sic "await " secus ""
            varia result = scriptum("§§ §", g.ind(), keyword, s.nomen)

            si nonnihil s.typus {
                result = scriptum("§: §", result, genTypus(g, s.typus novum TypusAnnotatio))
            }

            si nonnihil s.valor {
                result = scriptum("§ = §§", result, asyncPrefix, genExpressia(g, s.valor qua Expressia))
            }

            redde scriptum("§;", result)
        }

        casu ReddeSententia ut s {
            si nonnihil s.valor {
                redde scriptum("§return §;", g.ind(), genExpressia(g, s.valor qua Expressia))
            }
            redde scriptum("§return;", g.ind())
        }

        casu ExpressiaSententia ut s {
            redde scriptum("§§;", g.ind(), genExpressia(g, s.expressia))
        }

        ceterum {
            # EDGE: Unsupported statement type in praefixum block
            redde scriptum("§/* praefixum: unsupported statement */", g.ind())
        }
    }
}

functio invenitTabulaNomen(de Expressia obiectum, de TsGenerator g) -> si textus {
    discerne obiectum {
        casu Nomen ut n {
            fixum nomen = n.valor qua textus
            ex g.tabulaNominata fixum item {
                si item == nomen {
                    redde nomen
                }
            }
        }
        ceterum tacet
    }
    redde nihil
}

functio genTabulaGet(de textus obj, de textus prop, bivalens optivum, bivalens nonNullum) -> textus {
    si optivum {
        redde scriptum("§?.get(§)", obj, prop)
    }
    si nonNullum {
        redde scriptum("§!.get(§)", obj, prop)
    }
    redde scriptum("§.get(§)", obj, prop)
}

functio genTabulaSet(de textus obj, de textus prop, de textus valor, bivalens optivum, bivalens nonNullum) -> textus {
    si optivum {
        redde scriptum("§?.set(§, §)", obj, prop, valor)
    }
    si nonNullum {
        redde scriptum("§!.set(§, §)", obj, prop, valor)
    }
    redde scriptum("§.set(§, §)", obj, prop, valor)
}

functio genTabulaAssignatio(in TsGenerator g, de AssignatioExpressia e) -> si textus {
    discerne e.sinister {
        casu MembrumExpressia ut m {
            redde genTabulaAssignatioMembrum(g, e, m)
        }
        casu _ tacet
    }
    redde nihil
}

functio genTabulaAssignatioMembrum(in TsGenerator g, de AssignatioExpressia e, de MembrumExpressia m) -> si textus {
    si non (m.computatum qua bivalens) { redde nihil }

    fixum tabulaNomen = invenitTabulaNomen(m.obiectum, g)
    si nihil tabulaNomen { redde nihil }

    fixum obj = genExpressia(g, m.obiectum)
    fixum prop = genNudaExpressia(g, m.proprietas)
    fixum right = genNudaExpressia(g, e.dexter)
    fixum getExpr = genTabulaGet(obj, prop, m.optivum qua bivalens, m.nonNullum qua bivalens)
    fixum setStmt = genTabulaSet(obj, prop, "__next", m.optivum qua bivalens, m.nonNullum qua bivalens)

    si e.signum == "=" {
        redde scriptum("(() => { const __next = §; §; return __next; })()", right, setStmt)
    }

    varia op = e.signum qua textus
    si op.longitudo() > 1 et op.sectio(op.longitudo() - 1, op.longitudo()) == "=" {
        op = op.sectio(0, op.longitudo() - 1)
    }

    redde scriptum("(() => { const __next = (§ as any) § §; §; return __next; })()", getExpr, op, right, setStmt)
}

# =============================================================================
# INNATUM HELPERS
# =============================================================================

functio extractTypusParam(in TsGenerator g, numerus index, si de lista<TypusParametrum> params) -> textus {
    si nihil params { redde "unknown" }

    fixum paramLista = params qua lista<TypusParametrum>
    si paramLista.longitudo() <= index { redde "unknown" }

    discerne paramLista[index] {
        casu Typus ut t { redde genTypus(g, t.adnotatio) }
        casu _ tacet
    }

    redde "unknown"
}

functio genInnatumTabula(in TsGenerator g, de InnatumExpressia e) -> textus {
    fixum params = (e.scopus novum TypusAnnotatio).typusParametra
    fixum keyType = extractTypusParam(g, 0, params)
    fixum valueType = extractTypusParam(g, 1, params)

    # Non-empty object literal -> Map with entries
    discerne e.expressia {
        casu ObiectumExpressia ut obj {
            si (obj.proprietates qua lista<ObiectumProprietas>).longitudo() > 0 {
                redde genTabulaEntries(g, obj, keyType, valueType)
            }
        }
        casu _ tacet
    }

    redde scriptum("new Map<§, §>()", keyType, valueType)
}

functio genTabulaEntries(in TsGenerator g, de ObiectumExpressia obj, de textus keyType, de textus valueType) -> textus {
    varia entries = [] innatum lista<textus>
    ex (obj.proprietates qua lista<ObiectumProprietas>) fixum prop {
        fixum key = genMapKey(g, prop.clavis)
        fixum val = genExpressia(g, prop.valor)
        entries.appende(scriptum("[§, §]", key, val))
    }
    redde scriptum("new Map<§, §>([§])", keyType, valueType, entries.coniunge(", "))
}

functio genMapKey(in TsGenerator g, de Expressia clavis) -> textus {
    discerne clavis {
        casu Nomen ut n { redde scriptum("\"§\"", n.valor) }
        casu _ { redde genExpressia(g, clavis) }
    }
}

functio genInnatumLista(in TsGenerator g, de InnatumExpressia e) -> textus {
    fixum params = (e.scopus novum TypusAnnotatio).typusParametra
    fixum elemType = extractTypusParam(g, 0, params)

    # Non-empty array -> pass through
    discerne e.expressia {
        casu SeriesExpressia ut arr {
            si (arr.elementa qua lista<Expressia>).longitudo() > 0 {
                redde genExpressia(g, e.expressia)
            }
        }
        casu _ tacet
    }

    si elemType == "unknown" { redde "[]" }
    redde scriptum("([] as §[])", elemType)
}

functio genInnatumCopia(in TsGenerator g, de InnatumExpressia e) -> textus {
    fixum params = (e.scopus novum TypusAnnotatio).typusParametra
    fixum elemType = extractTypusParam(g, 0, params)

    si elemType == "unknown" { redde "new Set()" }
    redde scriptum("new Set<§>()", elemType)
}

functio estNegativusIndex(de Expressia expr) -> bivalens {
    discerne expr {
        casu UnariaExpressia ut u {
            redde (u.signum qua textus) == "-"
        }
        ceterum tacet
    }
    redde falsum
}

functio genNegativusAccess(de textus obj, de textus idx, bivalens optivum, bivalens nonNullum) -> textus {
    si optivum { redde scriptum("§?.at(§)", obj, idx) }
    si nonNullum { redde scriptum("§!.at(§)", obj, idx) }
    redde scriptum("§.at(§)", obj, idx)
}

functio genReceiverSuffix(de textus obj, bivalens optivum, bivalens nonNullum) -> textus {
    si optivum { redde scriptum("§?", obj) }
    si nonNullum { redde scriptum("§!", obj) }
    redde obj
}

functio genSectioAccess(in TsGenerator g, de textus obj, de Expressia ambitus, bivalens optivum, bivalens nonNullum) -> textus {
    discerne ambitus {
        casu AmbitusExpressia ut a {
            redde genAmbitusSlice(g, obj, a, optivum, nonNullum)
        }
        casu _ tacet
    }
    redde scriptum("§[§]", obj, genExpressia(g, ambitus))
}

functio genAmbitusSlice(in TsGenerator g, de textus obj, de AmbitusExpressia a, bivalens optivum, bivalens nonNullum) -> textus {
    fixum initium = genExpressia(g, a.initium)
    fixum finis = genExpressia(g, a.finis)
    fixum receiver = genReceiverSuffix(obj, optivum, nonNullum)

    si non (a.inclusivum qua bivalens) {
        redde scriptum("§.slice(§, §)", receiver, initium, finis)
    }

    # Inclusive range: try to optimize literal end index
    fixum literal = legeNumerusLiteralis(a.finis)
    si nihil literal { redde scriptum("§.slice(§, § + 1)", receiver, initium, finis) }

    fixum inclusive = (literal qua numerus) + 1
    si inclusive == 0 { redde scriptum("§.slice(§)", receiver, initium) }

    redde scriptum("§.slice(§, §)", receiver, initium, inclusive)
}

functio legeNumerusLiteralis(de Expressia expr) -> si numerus {
    discerne expr {
        casu Littera ut l {
            si l.species == LitteraGenus.Numerus {
                redde legeNumerusTextus(l.crudus)
            }
        }
        casu UnariaExpressia ut u {
            redde legeNegativusNumerus(u)
        }
        casu _ tacet
    }
    redde nihil
}

functio legeNegativusNumerus(de UnariaExpressia u) -> si numerus {
    si (u.signum qua textus) != "-" { redde nihil }

    discerne u.argumentum {
        casu Littera ut l {
            si l.species == LitteraGenus.Numerus {
                redde -legeNumerusTextus(l.crudus)
            }
        }
        casu _ tacet
    }
    redde nihil
}

functio legeNumerusTextus(de textus crudus) -> numerus {
    varia result = 0
    varia i = 0
    dum i < crudus.longitudo() {
        fixum c = crudus.sectio(i, i + 1)
        varia digit = 0
        elige c {
            casu "0" { digit = 0 }
            casu "1" { digit = 1 }
            casu "2" { digit = 2 }
            casu "3" { digit = 3 }
            casu "4" { digit = 4 }
            casu "5" { digit = 5 }
            casu "6" { digit = 6 }
            casu "7" { digit = 7 }
            casu "8" { digit = 8 }
            casu "9" { digit = 9 }
        }
        result = result * 10 + digit
        i += 1
    }
    redde result
}

# =============================================================================
# NORMA TRANSLATION HELPERS
# =============================================================================

# Apply a norma template translation with parameter substitution.
#
# WHY: § was chosen as the placeholder sigil because:
#   - It's visually distinct from any target language syntax (unlike $ or %)
#   - It doesn't conflict with template literals, regex, or shell expansion
#   - It's a single Unicode codepoint, making parsing unambiguous
#   - Latin "sectio" evokes "section/segment" - a placeholder for content
#
# WHY: Dual addressing modes (implicit § vs explicit §0, §1):
#   - Implicit § enables terse templates when order matches params
#   - Explicit §0, §1 allows reordering or reusing values
#   - Mixed usage is valid: "§.map(§1)" uses implicit then explicit
#
# WHY: 'ego' maps to receiver, others consume args in declaration order:
#   - Latin "ego" = "I/self" - the receiver in method context
#   - Params declared in norma.json determine the values array layout
#   - This separates template authoring from call-site argument order
#
# Edge cases:
#   - §N where N >= values.length returns empty string (silent fallback)
#   - Implicit § continues incrementing even after explicit §N
#   - No escaping mechanism for literal § (not needed in practice)
functio applyInnatumTemplate(de textus template, de lista<textus> params, de textus obj, de lista<textus> args) -> textus {
    # Build values array: ego -> obj, other params -> args
    varia values = [] innatum lista<textus>
    varia argIdx = 0
    ex params fixum param {
        si param == "ego" {
            values.appende(obj)
        } secus {
            si argIdx < args.longitudo() {
                values.appende(args[argIdx])
                argIdx += 1
            } secus {
                values.appende("")
            }
        }
    }

    # Replace § placeholders
    varia result = ""
    varia i = 0
    varia implicitIdx = 0

    dum i < template.longitudo() {
        fixum c = template[i]
        si c == "§" {
            # Check for explicit index (§0, §1, etc.)
            si i + 1 < template.longitudo() {
                fixum next = template[i + 1]
                si next >= "0" et next <= "9" {
                    # Parse the index
                    varia idxStr = ""
                    varia j = i + 1
                    dum j < template.longitudo() {
                        fixum digit = template[j]
                        si digit >= "0" et digit <= "9" {
                            idxStr = idxStr + digit
                            j += 1
                        } secus {
                            rumpe
                        }
                    }
                    fixum idx = legeNumerusTextus(idxStr)
                    si idx < values.longitudo() {
                        result = result + values[idx]
                    }
                    i = j
                    perge
                }
            }
            # Implicit positional: plain §
            si implicitIdx < values.longitudo() {
                result = result + values[implicitIdx]
            }
            implicitIdx += 1
            i += 1
        } secus {
            result = result + c
            i += 1
        }
    }

    redde result
}

@ publica
functio genNudaExpressia(in TsGenerator g, de Expressia expr) -> textus {
    # WHY: Flatten binary expressions when outer parens are unnecessary.
    discerne expr {
        casu BinariaExpressia ut e {
            fixum sin = genNudaExpressia(g, e.sinister)
            fixum dex = genNudaExpressia(g, e.dexter)
            varia signum = e.signum qua textus
            elige signum {
                casu "et" { signum = "&&" }
                casu "aut" { signum = "||" }
                casu "vel" { signum = "??" }
            }
            redde scriptum("§ § §", sin, signum, dex)
        }
        ceterum tacet
    }

    redde genExpressia(g, expr)
}
