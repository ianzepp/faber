# TypeScript Statement Generator - Iteration Loops
#
# Generates for-of/for-in loops with range optimization.
#
# TRANSFORMS:
#   per x de lista { ... }  -> for (const x in lista) { ... }
#   per x de tabula { ... } -> for (const x of tabula.keys()) { ... }
#   per x ex lista { ... }  -> for (const x of lista) { ... }
#   per x ex 0..10 { ... }  -> for (let x = 0; x < 10; x++) { ... }

ex "../../../ast/sententia" importa Sententia, IteratioGenus, CapeClausula
ex "../../../ast/expressia" importa Expressia
ex "../nucleus" importa TsGenerator

# External declarations - implementations live in index.fab
ex "../expressia/index" importa genExpressia
ex "./index" importa genSententia

# Check if expression is a known tabula variable name
functio estTabula(Expressia expr, TsGenerator g) -> bivalens {
    discerne expr {
        casu Nomen ut n {
            fixum nomen = n.valor qua textus
            ex g.tabulaNominata pro item {
                si item == nomen {
                    redde verum
                }
            }
        }
        ceterum { }
    }
    redde falsum
}

@ publica
functio genIteratio(IteratioGenus species, textus variabilis, Expressia iterabile, Sententia corpus, bivalens asynca, ignotum cape, TsGenerator g) -> textus {
    # WHY: JavaScript Maps don't support for-in iteration.
    #      When iterating keys with 'de tabula pro key', we must use .keys() method.
    varia keyword = "of"
    varia iterStr = genExpressia(iterabile, g)

    si species == IteratioGenus.De {
        si estTabula(iterabile, g) {
            # tabula: use for-of with .keys()
            iterStr = scriptum("§.keys()", iterStr)
        } secus {
            # Regular object: use for-in
            keyword = "in"
        }
    }

    fixum asyncPrefix = asynca sic "await " secus ""

    g.intraProfundum()
    fixum body = genSententia(corpus, g)
    g.exiProfundum()

    # WHY: Ranges become traditional for loops for efficiency.
    discerne iterabile {
        casu AmbitusExpressia ut a {
            fixum initium = genExpressia(a.initium, g)
            fixum finis = genExpressia(a.finis, g)
            fixum op = (a.inclusivum qua bivalens) sic "<=" secus "<"

            varia incrementum = scriptum("§++", variabilis)
            si nonnihil a.gradus {
                incrementum = scriptum("§ += §", variabilis, genExpressia(a.gradus qua Expressia, g))
            }

            fixum header = scriptum("for §(let § = §; § § §; §)", asyncPrefix, variabilis, initium, variabilis, op, finis, incrementum)
            fixum loop = scriptum("§§ {\n§\n§}", g.ind(), header, body, g.ind())

            si nonnihil cape {
                fixum c = cape qua CapeClausula
                redde scriptum("§try {\n§\n§} catch (§) §", g.ind(), loop, g.ind(), c.param, genSententia(c.corpus, g))
            }

            redde loop
        }
        ceterum { }
    }

    fixum loop = scriptum("§for §(const § § §) {\n§\n§}", g.ind(), asyncPrefix, variabilis, keyword, iterStr, body, g.ind())

    si nonnihil cape {
        fixum c = cape qua CapeClausula
        redde scriptum("§try {\n§\n§} catch (§) §", g.ind(), loop, g.ind(), c.param, genSententia(c.corpus, g))
    }

    redde loop
}
