# TypeScript Statement Generator - Iteration Loops
#
# Generates for-of/for-in loops with range optimization.
#
# TRANSFORMS:
#   per x de lista { ... }  -> for (const x in lista) { ... }
#   per x de tabula { ... } -> for (const x of tabula.keys()) { ... }
#   per x ex lista { ... }  -> for (const x of lista) { ... }
#   per x ex 0..10 { ... }  -> for (let x = 0; x < 10; x++) { ... }

§ ex "../../../ast/sententia" importa Sententia, IteratioGenus, CapeClausula
§ ex "../../../ast/expressia" importa Expressia
§ ex "../nucleus" importa TsGenerator
§ ex "../../shared/syntaxis" importa SYNTAXIS_TS
§ ex "../../shared/iteratio" importa genAmbitusIteratio
§ ex "../revocata" importa creaTsRevocata

# External declarations
§ ex "../expressia/index" importa genExpressia
§ ex "./index" importa genSententia

# Check if expression is a known tabula variable name
functio estTabula(Expressia expr, TsGenerator g) -> bivalens {
    discerne expr {
        casu Nomen ut n {
            fixum nomen = n.valor qua textus
            ex g.tabulaNominata pro item {
                si item == nomen {
                    redde verum
                }
            }
        }
        ceterum { }
    }
    redde falsum
}

@ publica
functio genIteratio(IteratioGenus species, textus variabilis, Expressia iterabile, Sententia corpus, bivalens asynca, ignotum cape, TsGenerator g) -> textus {
    fixum rev = creaTsRevocata()

    # Check for range expression - use shared handler
    discerne iterabile {
        casu AmbitusExpressia ut a {
            g.intraProfundum()
            fixum body = genSententia(corpus, g)
            g.exiProfundum()

            fixum initium = genExpressia(a.initium, g)
            fixum finis = genExpressia(a.finis, g)

            redde genAmbitusIteratio(
                variabilis,
                initium,
                finis,
                a.inclusivum qua bivalens,
                a.gradus,
                body,
                asynca,
                cape,
                g,
                SYNTAXIS_TS,
                rev
            )
        }
        ceterum { }
    }

    # Regular iteration - TS-specific for-of/for-in handling
    varia keyword = "of"
    varia iterStr = genExpressia(iterabile, g)

    si species == IteratioGenus.De {
        si estTabula(iterabile, g) {
            # tabula: use for-of with .keys()
            iterStr = scriptum("§.keys()", iterStr)
        } secus {
            # Regular object: use for-in
            keyword = "in"
        }
    }

    fixum asyncPrefix = asynca sic "await " secus ""

    g.intraProfundum()
    fixum body = genSententia(corpus, g)
    g.exiProfundum()

    fixum loop = scriptum("§for §(const § § §) {\n§\n§}", g.ind(), asyncPrefix, variabilis, keyword, iterStr, body, g.ind())

    si nonnihil cape {
        fixum c = cape qua CapeClausula
        redde scriptum("§try {\n§\n§} catch (§) §", g.ind(), loop, g.ind(), c.param, genSententia(c.corpus, g))
    }

    redde loop
}
