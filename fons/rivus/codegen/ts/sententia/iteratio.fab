# TypeScript Statement Generator - Iteration Loops
#
# Generates for-of/for-in loops with range optimization.
#
# TRANSFORMS:
#   per x de lista { ... }  -> for (const x in lista) { ... }
#   per x de tabula { ... } -> for (const x of tabula.keys()) { ... }
#   per x ex lista { ... }  -> for (const x of lista) { ... }
#   per x ex 0..10 { ... }  -> for (let x = 0; x < 10; x++) { ... }

§ ex "../../../ast/sententia" importa Sententia, IteratioGenus, CapeClausula, IteratioVariabilis
§ ex "../../../ast/expressia" importa Expressia
§ ex "../nucleus" importa TsGenerator
§ ex "../../shared/syntaxis" importa SYNTAXIS_TS
§ ex "../../shared/iteratio" importa genAmbitusIteratio
§ ex "../revocata" importa creaTsRevocata

# External declarations
§ ex "../expressia/index" importa genExpressia
§ ex "./index" importa genSententia

# Check if expression is a known tabula variable name
functio estTabula(de Expressia expr, de TsGenerator g) -> bivalens {
    discerne expr {
        casu Nomen ut n {
            fixum nomen = n.valor qua textus
            ex g.tabulaNominata fixum item {
                si item == nomen {
                    redde verum
                }
            }
        }
        ceterum { }
    }
    redde falsum
}

@ publica
functio genIteratio(IteratioGenus species, de IteratioVariabilis variabilis, de Expressia iterabile, de Sententia corpus, bivalens asynca, bivalens mutabilis, de ignotum cape, in TsGenerator g) -> textus {
    fixum rev = creaTsRevocata()

    # Convert IteratioVariabilis to string representation
    fixum varStr = genLoopVariable(variabilis)

    # Determine binding keyword based on mutability
    fixum bindKeyword = mutabilis sic "let" secus "const"

    # Check for range expression - use shared handler (only for simple identifier)
    discerne variabilis {
        casu Nomen ut n {
            discerne iterabile {
                casu AmbitusExpressia ut a {
                    g.intraProfundum()
                    fixum body = genSententia(corpus, g)
                    g.exiProfundum()

                    fixum initium = genExpressia(a.initium, g)
                    fixum finis = genExpressia(a.finis, g)

                    redde genAmbitusIteratio(
                        n.valor,
                        initium,
                        finis,
                        a.inclusivum qua bivalens,
                        a.gradus,
                        body,
                        asynca,
                        cape,
                        g,
                        SYNTAXIS_TS,
                        rev
                    )
                }
                ceterum { }
            }
        }
        ceterum { }
    }

    # Regular iteration - TS-specific for-of/for-in handling
    varia keyword = "of"
    varia iterStr = genExpressia(iterabile, g)

    si species == IteratioGenus.De {
        si estTabula(iterabile, g) {
            # tabula: use for-of with .keys()
            iterStr = scriptum("§.keys()", iterStr)
        } secus {
            # Regular object: use for-in
            keyword = "in"
        }
    }

    fixum asyncPrefix = asynca sic "await " secus ""

    g.intraProfundum()
    fixum body = genSententia(corpus, g)
    g.exiProfundum()

    fixum loop = scriptum("§for §(§ § § §) {\n§\n§}", g.ind(), asyncPrefix, bindKeyword, varStr, keyword, iterStr, body, g.ind())

    si nonnihil cape {
        fixum c = cape novum CapeClausula
        redde scriptum("§try {\n§\n§} catch (§) §", g.ind(), loop, g.ind(), c.param, genSententia(c.corpus, g))
    }

    redde loop
}

# Convert loop variable binding to string
functio genLoopVariable(de IteratioVariabilis variabilis) -> textus {
    discerne variabilis {
        casu Nomen ut n {
            redde n.valor
        }
        casu Series ut s {
            varia parts = [] innatum lista<textus>
            ex s.elementa fixum elem {
                si elem.omissum {
                    parts.adde("")
                } sin elem.residuum et nonnihil elem.nomen {
                    parts.adde(scriptum("...§", elem.nomen))
                } sin nonnihil elem.nomen {
                    parts.adde(elem.nomen qua textus)
                } secus {
                    parts.adde("")
                }
            }
            redde scriptum("[§]", parts.coniunge(", "))
        }
    }
}
