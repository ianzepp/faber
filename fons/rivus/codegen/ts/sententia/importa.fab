# TypeScript Statement Generator - Import and Destructuring
#
# TRANSFORMS (new syntax):
#   importa ex "fs" privata readFile          -> import { readFile } from "fs";
#   importa ex "fs" privata readFile ut rf    -> import { readFile as rf } from "fs";
#   importa ex "fs" privata * ut fs           -> import * as fs from "fs";
#   importa ex "fs" publica readFile          -> export { readFile } from "fs";
#   ex obj fixum { a, b }                     -> const { a, b } = obj;
#   fixum [a, , b] = arr                      -> const [a, , b] = arr;

importa ex "../../../ast/sententia" privata ImportaSpecificator
importa ex "../../../ast/sententia" privata VariaGenus
importa ex "../../../ast/sententia" privata SeriesDestructuraElementum
importa ex "../../../ast/expressia" privata Expressia
importa ex "../nucleus" privata TsGenerator
importa ex "../nucleus" privata resolveNormaHal
importa ex "../../../semantic/modulus" privata estNormaImportum

# External declaration - implementation lives in index.fab
importa ex "../expressia/index" privata genExpressia

@ publica
functio genImporta(in TsGenerator g, de textus fons, si de textus importatum, de textus locale, bivalens totum, bivalens publica) -> textus {
    # Skip norma imports (norma/ prefix) - they are compiler intrinsics, not real modules
    si estNormaImportum(fons) {
        redde ""
    }

    # Resolve norma:* imports to HAL paths
    varia importPath = fons
    si fons.initium("norma:") {
        fixum resolved = resolveNormaHal(fons, g.viaFons)
        si nonnihil resolved {
            importPath = resolved
        }
    }

    varia lines = [] innatum lista<textus>

    # Wildcard import: * ut alias
    si totum {
        lines.appende(scriptum("§import * as § from \"§\";", g.ind(), locale, importPath))
        si publica {
            lines.appende(scriptum("§export { § };", g.ind(), locale))
        }
        redde lines.coniunge("\n")
    }

    # Named import with optional alias
    si nonnihil importatum {
        si importatum == locale {
            lines.appende(scriptum("§import { § } from \"§\";", g.ind(), importatum, importPath))
            si publica {
                lines.appende(scriptum("§export { § };", g.ind(), locale))
            }
        } secus {
            lines.appende(scriptum("§import { § as § } from \"§\";", g.ind(), importatum, locale, importPath))
            si publica {
                # Re-export under original name
                lines.appende(scriptum("§export { § as § };", g.ind(), locale, importatum))
            }
        }
        redde lines.coniunge("\n")
    }

    # Fallback (shouldn't happen with valid AST)
    redde scriptum("§import \"§\";", g.ind(), importPath)
}

@ publica
functio genDestructura(in TsGenerator g, de Expressia fons, VariaGenus species, de lista<ImportaSpecificator> specificatores) -> textus {
    fixum keyword = (species == VariaGenus.Fixum aut species == VariaGenus.Figendum) sic "const" secus "let"
    fixum asyncPrefix = (species == VariaGenus.Figendum aut species == VariaGenus.Variandum) sic "await " secus ""

    varia specs = [] innatum lista<textus>
    ex specificatores fixum spec {
        si spec.residuum {
            specs.appende(scriptum("...§", spec.locale))
        } sin spec.importatum == spec.locale {
            specs.appende(spec.importatum)
        } secus {
            specs.appende(scriptum("§: §", spec.importatum, spec.locale))
        }
    }

    redde scriptum("§§ { § } = §§;", g.ind(), keyword, specs.coniunge(", "), asyncPrefix, genExpressia(g, fons))
}

@ publica
functio genSeriesDestructura(in TsGenerator g, de lista<SeriesDestructuraElementum> elementa, de Expressia fons, VariaGenus species) -> textus {
    fixum keyword = (species == VariaGenus.Fixum aut species == VariaGenus.Figendum) sic "const" secus "let"
    fixum asyncPrefix = (species == VariaGenus.Figendum aut species == VariaGenus.Variandum) sic "await " secus ""

    varia items = [] innatum lista<textus>
    ex elementa fixum elem {
        si elem.omissum {
            items.appende("")
        } sin elem.residuum {
            items.appende(scriptum("...§", elem.nomen))
        } secus {
            items.appende(elem.nomen)
        }
    }

    redde scriptum("§§ [§] = §§;", g.ind(), keyword, items.coniunge(", "), asyncPrefix, genExpressia(g, fons))
}
