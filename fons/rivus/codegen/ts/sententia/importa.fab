# TypeScript Statement Generator - Import and Destructuring
#
# TRANSFORMS:
#   ex "fs" importa readFile       -> import { readFile } from "fs";
#   ex "fs" importa *              -> import "fs";  (side-effect only)
#   ex "fs" importa * ut fs        -> import * as fs from "fs";
#   ex obj importa { a, b }        -> const { a, b } = obj;
#   ex arr importa [a, , b]        -> const [a, , b] = arr;

importa ex "../../../ast/sententia" privata ImportaSpecificator
importa ex "../../../ast/sententia" privata VariaGenus
importa ex "../../../ast/sententia" privata SeriesDestructuraElementum
importa ex "../../../ast/expressia" privata Expressia
importa ex "../nucleus" privata TsGenerator
importa ex "../nucleus" privata resolveNormaHal
importa ex "../../../semantic/modulus" privata estNormaImportum

# External declaration - implementation lives in index.fab
importa ex "../expressia/index" privata genExpressia

@ publica
functio genImporta(in TsGenerator g, de textus fons, de lista<ImportaSpecificator> specificatores, bivalens totum, de ignotum totumAlias) -> textus {
    # Skip norma imports (norma/ prefix) - they are compiler intrinsics, not real modules
    si estNormaImportum(fons) {
        redde ""
    }

    # Resolve norma:* imports to HAL paths
    varia importPath = fons
    si fons.initium("norma:") {
        fixum resolved = resolveNormaHal(fons, g.viaFons)
        si nonnihil resolved {
            importPath = resolved
        }
    }

    si totum {
        si nonnihil totumAlias {
            redde scriptum("§import * as § from \"§\";", g.ind(), totumAlias qua textus, importPath)
        }
        # No alias - side-effect import only
        redde scriptum("§import \"§\";", g.ind(), importPath)
    }

    varia specs = [] innatum lista<textus>
    ex specificatores fixum spec {
        si spec.importatum == spec.locale {
            specs.appende(spec.importatum)
        } secus {
            specs.appende(scriptum("§ as §", spec.importatum, spec.locale))
        }
    }

    redde scriptum("§import { § } from \"§\";", g.ind(), specs.coniunge(", "), importPath)
}

@ publica
functio genDestructura(in TsGenerator g, de Expressia fons, VariaGenus species, de lista<ImportaSpecificator> specificatores) -> textus {
    fixum keyword = (species == VariaGenus.Fixum aut species == VariaGenus.Figendum) sic "const" secus "let"
    fixum asyncPrefix = (species == VariaGenus.Figendum aut species == VariaGenus.Variandum) sic "await " secus ""

    varia specs = [] innatum lista<textus>
    ex specificatores fixum spec {
        si spec.residuum {
            specs.appende(scriptum("...§", spec.locale))
        } sin spec.importatum == spec.locale {
            specs.appende(spec.importatum)
        } secus {
            specs.appende(scriptum("§: §", spec.importatum, spec.locale))
        }
    }

    redde scriptum("§§ { § } = §§;", g.ind(), keyword, specs.coniunge(", "), asyncPrefix, genExpressia(g, fons))
}

@ publica
functio genSeriesDestructura(in TsGenerator g, de lista<SeriesDestructuraElementum> elementa, de Expressia fons, VariaGenus species) -> textus {
    fixum keyword = (species == VariaGenus.Fixum aut species == VariaGenus.Figendum) sic "const" secus "let"
    fixum asyncPrefix = (species == VariaGenus.Figendum aut species == VariaGenus.Variandum) sic "await " secus ""

    varia items = [] innatum lista<textus>
    ex elementa fixum elem {
        si elem.omissum {
            items.appende("")
        } sin elem.residuum {
            items.appende(scriptum("...§", elem.nomen))
        } secus {
            items.appende(elem.nomen)
        }
    }

    redde scriptum("§§ [§] = §§;", g.ind(), keyword, items.coniunge(", "), asyncPrefix, genExpressia(g, fons))
}
