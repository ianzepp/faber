# TypeScript Statement Generator - Discriminated Union Types
#
# Generates TypeScript tagged union types.
#
# TRANSFORMS:
#   discretio Result { Ok, Err } -> type Result = { tag: 'Ok'; ... } | { tag: 'Err'; ... }
#   @ publica discretio X { ... } -> export type X = ...

§ ex "../../../ast/sententia" importa VariansDeclaratio, Visibilitas
§ ex "../nucleus" importa TsGenerator
§ ex "../typus" importa genTypus

@ publica
functio genDiscretio(textus nomen, ignotum generaParametra, lista<VariansDeclaratio> variantes, ignotum visibilitas, TsGenerator g) -> textus {
    # TS: prefer inline union members so tests can match exact fragments.

    # Module-level: export when public
    varia exportPrefix = ""
    si nonnihil visibilitas {
        fixum vis = visibilitas qua Visibilitas
        si vis == Visibilitas.Publica {
            exportPrefix = "export "
        }
    }

    varia params = ""
    si nonnihil generaParametra {
        fixum p = generaParametra qua lista<textus>
        params = scriptum("<§>", p.coniunge(", "))
    }

    # Emit each variant as a named type, then build the union from those.
    # WHY: `Extract<Union, ...>` aliases become circular when variants reference
    #      sibling variants (Union -> VariantAlias -> Union).
    varia lines = [] innatum lista<textus>

    ex variantes fixum varians {
        varia member = scriptum("{ tag: '§'", varians.nomen)
        ex varians.campi fixum campus {
            member = scriptum("§; §: §", member, campus.nomen, genTypus(campus.typus, g))
        }
        member = scriptum("§ }", member)
        lines.adde(scriptum("§§type §§ = §;", g.ind(), exportPrefix, varians.nomen, params, member))
    }

    varia unionMembers = [] innatum lista<textus>
    ex variantes fixum varians {
        unionMembers.adde(scriptum("§§", varians.nomen, params))
    }

    lines.adde(scriptum("§§type §§ = §;", g.ind(), exportPrefix, nomen, params, unionMembers.coniunge(" | ")))

    redde lines.coniunge("\n")
}
