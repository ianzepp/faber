# TypeScript Statement Generator - Discriminated Union Types
#
# Generates TypeScript tagged union types.
#
# TRANSFORMS:
#   discretio Result { Ok, Err } -> type Result = { tag: 'Ok'; ... } | { tag: 'Err'; ... }
#   @ publica discretio X { ... } -> export type X = ...

ex "../../../ast/sententia" importa VariansDeclaratio, Visibilitas
ex "../nucleus" importa TsGenerator
ex "../typus" importa genTypus

@ publica
functio genDiscretio(textus nomen, ignotum generaParametra, lista<VariansDeclaratio> variantes, ignotum visibilitas, TsGenerator g) -> textus {
    # TS: prefer inline union members so tests can match exact fragments.

    # Module-level: export when public
    varia exportPrefix = ""
    si nonnihil visibilitas {
        fixum vis = visibilitas qua Visibilitas
        si vis == Visibilitas.Publica {
            exportPrefix = "export "
        }
    }

    varia params = ""
    si nonnihil generaParametra {
        fixum p = generaParametra qua lista<textus>
        params = scriptum("<§>", p.coniunge(", "))
    }

    varia variants = [] innatum lista<textus>
    ex variantes pro varians {
        varia member = scriptum("{ tag: '§'", varians.nomen)
        ex varians.campi pro campus {
            member = scriptum("§; §: §", member, campus.nomen, genTypus(campus.typus, g))
        }
        member = scriptum("§ }", member)
        variants.adde(member)
    }

    fixum unionType = scriptum("§§type §§ = §;", g.ind(), exportPrefix, nomen, params, variants.coniunge(" | "))

    # Generate extracted variant types so they can be used as standalone types
    varia lines = [unionType] innatum lista<textus>
    ex variantes pro varians {
        lines.adde(scriptum("§§type § = Extract<§, { tag: '§' }>;", g.ind(), exportPrefix, varians.nomen, nomen, varians.nomen))
    }

    redde lines.coniunge("\n")
}
