# TypeScript Statement Generator - Test Statements
#
# Generates standalone test functions with inline harness.
#
# STANDALONE MODE (inProbaStandalone = true):
#   probandum "suite" { ... }  -> suiteStack push, generate members, pop
#   proba "case" { ... }       -> __proba_suite_case() function + registry entry
#   @ omitte proba "skip" { }  -> function marked skip in registry
#   @ futurum proba "todo"     -> function marked todo in registry
#
# LEGACY MODE (inProbaStandalone = false):
#   probandum "suite" { ... }  -> describe("suite", () => { ... })
#   proba "case" { ... }       -> test("case", () => { ... })
#
# Harness output (at end of file):
#   const __tests = [{ suite, name, fn, skip?, todo?, ... }, ...]
#   function __runTests(): number { ... }
#   if (require.main === module) process.exit(__runTests())

importa ex "../../../ast/sententia" privata Sententia
importa ex "../../../ast/sententia" privata ProbaModificator
importa ex "../../../ast/sententia" privata PraeparaTempus
importa ex "../nucleus" privata TsGenerator

# External declarations - implementations live in index.fab
importa ex "./index" privata genSententia

# =============================================================================
# HELPERS
# =============================================================================

# Sanitize name for use as identifier (replace spaces/special chars with _)
functio sanitizeNomen(de textus nomen) -> textus {
    varia textus result = nomen
    result = result.muta(" ", "_")
    result = result.muta("-", "_")
    result = result.muta(".", "_")
    result = result.muta("/", "_")
    result = result.muta("'", "")
    result = result.muta("\"", "")
    redde result
}

# Get full suite path from stack
functio getSuitePath(de TsGenerator g) -> textus {
    si g.probaSuiteStack.longitudo() == 0 {
        redde ""
    }
    redde g.probaSuiteStack.coniunge("_")
}

# =============================================================================
# PROBANDUM (TEST SUITE)
# =============================================================================

@ publica
functio genProbandum(in TsGenerator g, de textus nomen, de lista<Sententia> corpus, si bivalens ompitur, si de textus ratioOmissionis, si bivalens solum, si de lista<textus> tags) -> textus {
    # Legacy mode: generate describe()
    si non g.inProbaStandalone {
        varia lines = [] innatum lista<textus>
        lines.appende(scriptum("§describe(\"§\", () => {", g.ind(), nomen))

        g.intraProfundum()
        itera ex corpus fixum stmt {
            lines.appende(genSententia(g, stmt))
        }
        g.exiProfundum()

        lines.appende(scriptum("§});", g.ind()))
        redde lines.coniunge("\n")
    }

    # Standalone mode: push suite name, generate members, pop
    g.probaSuiteStack.appende(sanitizeNomen(nomen))

    varia lines = [] innatum lista<textus>
    lines.appende(scriptum("§// Suite: §", g.ind(), nomen))

    itera ex corpus fixum stmt {
        lines.appende(genSententia(g, stmt))
    }

    g.probaSuiteStack.remove()

    redde lines.coniunge("\n")
}

# =============================================================================
# PROBA (TEST CASE)
# =============================================================================

@ publica
functio genProba(
    in TsGenerator g,
    de textus nomen,
    de ignotum modificator,
    de Sententia corpus,
    si de textus ratioModificatoris,
    si bivalens solum,
    si de lista<textus> tags,
    si numerus temporis,
    si bivalens metior,
    si numerus repete,
    si numerus fragilis,
    si de textus requirit,
    si de textus solumIn
) -> textus {
    # Legacy mode: generate test()
    si non g.inProbaStandalone {
        varia ratio = ""
        si nonnihil ratioModificatoris {
            ratio = scriptum("§: ", ratioModificatoris)
        }

        si nonnihil modificator {
            fixum mod = modificator qua ProbaModificator
            fixum titulus = scriptum("§§", ratio, nomen)

            si mod == ProbaModificator.Omitte {
                g.intraProfundum()
                fixum body = genSententia(g, corpus)
                g.exiProfundum()
                redde scriptum("§test.skip(\"§\", () => {\n§\n§});", g.ind(), titulus, body, g.ind())
            }
            si mod == ProbaModificator.Futurum {
                redde scriptum("§test.todo(\"§\");", g.ind(), titulus)
            }
        }

        g.intraProfundum()
        fixum body = genSententia(g, corpus)
        g.exiProfundum()

        redde scriptum("§test(\"§\", () => {\n§\n§});", g.ind(), nomen, body, g.ind())
    }

    # Standalone mode: generate function + registry entry
    fixum suitePath = getSuitePath(g)
    fixum sanitizedName = sanitizeNomen(nomen)
    fixum funcName = (suitePath.longitudo() > 0) sic scriptum("__proba_§_§", suitePath, sanitizedName) secus scriptum("__proba_§", sanitizedName)
    fixum suiteDisplay = (suitePath.longitudo() > 0) sic g.probaSuiteStack.coniunge(" > ") secus ""

    # Build registry entry as plain object with bracket access
    varia entry = {
        suite: suiteDisplay,
        name: nomen,
        funcName: funcName
    } qua ignotum

    si nonnihil modificator {
        fixum mod = modificator qua ProbaModificator
        si mod == ProbaModificator.Omitte {
            entry["skip"] = verum
            si nonnihil ratioModificatoris {
                entry["skipReason"] = ratioModificatoris
            }
        }
        si mod == ProbaModificator.Futurum {
            entry["todo"] = verum
            si nonnihil ratioModificatoris {
                entry["todoReason"] = ratioModificatoris
            }
        }
    }
    si nonnihil solum et solum {
        entry["only"] = verum
    }
    si nonnulla tags {
        entry["tags"] = tags
    }
    si nonnihil temporis {
        entry["timeout"] = temporis
    }
    si nonnihil metior et metior {
        entry["benchmark"] = verum
    }
    si nonnihil repete {
        entry["repeat"] = repete
    }
    si nonnihil fragilis {
        entry["retries"] = fragilis
    }
    si nonnihil requirit {
        entry["requireEnv"] = requirit
    }
    si nonnihil solumIn {
        entry["platformOnly"] = solumIn
    }

    g.probaRegistrum.appende(entry)

    # Generate standalone function
    varia lines = [] innatum lista<textus>
    lines.appende(scriptum("§function §(): string | null {", g.ind(), funcName))
    g.intraProfundum()
    lines.appende(scriptum("§try {", g.ind()))
    g.intraProfundum()

    # Generate body
    fixum body = genSententia(g, corpus)
    si body.longitudo() > 0 {
        lines.appende(body)
    }

    lines.appende(scriptum("§return null;", g.ind()))
    g.exiProfundum()
    lines.appende(scriptum("§} catch (e) {", g.ind()))
    g.intraProfundum()
    lines.appende(scriptum("§return String(e);", g.ind()))
    g.exiProfundum()
    lines.appende(scriptum("§}", g.ind()))
    g.exiProfundum()
    lines.appende(scriptum("§}", g.ind()))

    redde lines.coniunge("\n")
}

# =============================================================================
# PRAEPARA (SETUP/TEARDOWN)
# =============================================================================

@ publica
functio genPraepara(in TsGenerator g, PraeparaTempus tempus, bivalens asynca, bivalens omnia, de Sententia corpus) -> textus {
    # In standalone mode, setup/teardown become comments (not supported in simple harness)
    si g.inProbaStandalone {
        fixum hookType = (tempus == PraeparaTempus.Praepara) sic "setup" secus "teardown"
        fixum hookScope = (omnia) sic "all" secus "each"
        redde scriptum("§// TODO: § § hook not supported in standalone mode", g.ind(), hookType, hookScope)
    }

    # Legacy mode
    varia hook = "beforeEach"
    si tempus == PraeparaTempus.Praepara {
        si omnia {
            hook = "beforeAll"
        } secus {
            hook = "beforeEach"
        }
    } secus {
        si omnia {
            hook = "afterAll"
        } secus {
            hook = "afterEach"
        }
    }

    fixum asyncPrefix = asynca sic "async " secus ""

    g.intraProfundum()
    fixum body = genSententia(g, corpus)
    g.exiProfundum()

    redde scriptum("§§(§() => {\n§\n§});", g.ind(), hook, asyncPrefix, body, g.ind())
}

# =============================================================================
# HARNESS GENERATION
# =============================================================================

# Generate the test harness (registry + runner)
# Call this after all statements have been generated
@ publica
functio genProbaHarness(in TsGenerator g) -> textus {
    si g.probaRegistrum.longitudo() == 0 {
        redde ""
    }

    varia lines = [] innatum lista<textus>
    lines.appende("")
    lines.appende("// =============================================================================")
    lines.appende("// TEST HARNESS")
    lines.appende("// =============================================================================")
    lines.appende("")

    # Generate registry type
    lines.appende("interface __TestEntry {")
    lines.appende("  suite: string;")
    lines.appende("  name: string;")
    lines.appende("  fn: () => string | null;")
    lines.appende("  skip?: boolean;")
    lines.appende("  skipReason?: string;")
    lines.appende("  todo?: boolean;")
    lines.appende("  todoReason?: string;")
    lines.appende("  only?: boolean;")
    lines.appende("  tags?: string[];")
    lines.appende("  timeout?: number;")
    lines.appende("  benchmark?: boolean;")
    lines.appende("  repeat?: number;")
    lines.appende("  retries?: number;")
    lines.appende("  requireEnv?: string;")
    lines.appende("  platformOnly?: string;")
    lines.appende("}")
    lines.appende("")

    # Generate registry (using bracket notation for plain object entries)
    lines.appende("const __tests: __TestEntry[] = [")
    itera ex g.probaRegistrum fixum entry {
        varia parts = [] innatum lista<textus>
        parts.appende(scriptum("suite: \"§\"", entry["suite"] qua textus))
        parts.appende(scriptum("name: \"§\"", entry["name"] qua textus))
        parts.appende(scriptum("fn: §", entry["funcName"] qua textus))

        si nonnihil entry["skip"] {
            parts.appende("skip: true")
            si nonnihil entry["skipReason"] {
                parts.appende(scriptum("skipReason: \"§\"", entry["skipReason"] qua textus))
            }
        }
        si nonnihil entry["todo"] {
            parts.appende("todo: true")
            si nonnihil entry["todoReason"] {
                parts.appende(scriptum("todoReason: \"§\"", entry["todoReason"] qua textus))
            }
        }
        si nonnihil entry["only"] {
            parts.appende("only: true")
        }
        si nonnihil entry["tags"] {
            fixum tagsArr = entry["tags"] qua lista<textus>
            varia tagStrs = [] innatum lista<textus>
            itera ex tagsArr fixum t {
                tagStrs.appende(scriptum("\"§\"", t))
            }
            parts.appende(scriptum("tags: [§]", tagStrs.coniunge(", ")))
        }
        si nonnihil entry["timeout"] {
            parts.appende(scriptum("timeout: §", entry["timeout"]))
        }
        si nonnihil entry["benchmark"] {
            parts.appende("benchmark: true")
        }
        si nonnihil entry["repeat"] {
            parts.appende(scriptum("repeat: §", entry["repeat"]))
        }
        si nonnihil entry["retries"] {
            parts.appende(scriptum("retries: §", entry["retries"]))
        }
        si nonnihil entry["requireEnv"] {
            parts.appende(scriptum("requireEnv: \"§\"", entry["requireEnv"] qua textus))
        }
        si nonnihil entry["platformOnly"] {
            parts.appende(scriptum("platformOnly: \"§\"", entry["platformOnly"] qua textus))
        }

        lines.appende(scriptum("  { § },", parts.coniunge(", ")))
    }
    lines.appende("];")
    lines.appende("")

    # Generate runner
    lines.appende("function __runTests(options?: { tag?: string; exclude?: string; only?: boolean }): number {")
    lines.appende("  const opts = options ?? {};")
    lines.appende("  let testsToRun = __tests;")
    lines.appende("")
    lines.appende("  // Filter by 'only' if any test has it")
    lines.appende("  if (opts.only || testsToRun.some(t => t.only)) {")
    lines.appende("    testsToRun = testsToRun.filter(t => t.only);")
    lines.appende("  }")
    lines.appende("")
    lines.appende("  // Filter by tag")
    lines.appende("  if (opts.tag) {")
    lines.appende("    testsToRun = testsToRun.filter(t => t.tags?.includes(opts.tag!));")
    lines.appende("  }")
    lines.appende("")
    lines.appende("  // Exclude by tag")
    lines.appende("  if (opts.exclude) {")
    lines.appende("    testsToRun = testsToRun.filter(t => !t.tags?.includes(opts.exclude!));")
    lines.appende("  }")
    lines.appende("")
    lines.appende("  let passed = 0, failed = 0, skipped = 0, todo = 0;")
    lines.appende("")
    lines.appende("  for (const t of testsToRun) {")
    lines.appende("    const label = t.suite ? `${t.suite} > ${t.name}` : t.name;")
    lines.appende("")
    lines.appende("    // Check platform filter")
    lines.appende("    if (t.platformOnly && process.platform !== t.platformOnly) {")
    lines.appende("      console.log(`SKIP ${label} (platform: ${t.platformOnly})`);")
    lines.appende("      skipped++;")
    lines.appende("      continue;")
    lines.appende("    }")
    lines.appende("")
    lines.appende("    // Check required env")
    lines.appende("    if (t.requireEnv && !process.env[t.requireEnv]) {")
    lines.appende("      console.log(`SKIP ${label} (missing env: ${t.requireEnv})`);")
    lines.appende("      skipped++;")
    lines.appende("      continue;")
    lines.appende("    }")
    lines.appende("")
    lines.appende("    // Skip")
    lines.appende("    if (t.skip) {")
    lines.appende("      const reason = t.skipReason ? `: ${t.skipReason}` : '';")
    lines.appende("      console.log(`SKIP ${label}${reason}`);")
    lines.appende("      skipped++;")
    lines.appende("      continue;")
    lines.appende("    }")
    lines.appende("")
    lines.appende("    // Todo")
    lines.appende("    if (t.todo) {")
    lines.appende("      const reason = t.todoReason ? `: ${t.todoReason}` : '';")
    lines.appende("      console.log(`TODO ${label}${reason}`);")
    lines.appende("      todo++;")
    lines.appende("      continue;")
    lines.appende("    }")
    lines.appende("")
    lines.appende("    // Run with retries")
    lines.appende("    const maxAttempts = t.retries ?? 1;")
    lines.appende("    const repeatCount = t.repeat ?? 1;")
    lines.appende("    let lastErr: string | null = null;")
    lines.appende("")
    lines.appende("    for (let rep = 0; rep < repeatCount; rep++) {")
    lines.appende("      for (let attempt = 0; attempt < maxAttempts; attempt++) {")
    lines.appende("        lastErr = t.fn();")
    lines.appende("        if (!lastErr) break;")
    lines.appende("      }")
    lines.appende("      if (lastErr) break;")
    lines.appende("    }")
    lines.appende("")
    lines.appende("    if (lastErr) {")
    lines.appende("      console.log(`FAIL ${label}: ${lastErr}`);")
    lines.appende("      failed++;")
    lines.appende("    } else {")
    lines.appende("      console.log(`PASS ${label}`);")
    lines.appende("      passed++;")
    lines.appende("    }")
    lines.appende("  }")
    lines.appende("")
    lines.appende("  console.log(`\\n${passed} passed, ${failed} failed, ${skipped} skipped, ${todo} todo`);")
    lines.appende("  return failed > 0 ? 1 : 0;")
    lines.appende("}")
    lines.appende("")

    # Generate entry point check
    lines.appende("// Run tests if executed directly")
    lines.appende("if (typeof require !== 'undefined' && require.main === module) {")
    lines.appende("  process.exit(__runTests());")
    lines.appende("}")

    redde lines.coniunge("\n")
}
