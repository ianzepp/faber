# TypeScript Statement Generator - Interface Declarations
#
# Generates TypeScript interface declarations with method signatures.
#
# TRANSFORMS:
#   pactum Foo { ... }            -> interface Foo { ... }
#   pactum Foo<T> { ... }         -> interface Foo<T> { ... }
#   pactum Foo { f(): T }         -> interface Foo { f(): T }
#   pactum Foo { futura f(): T }  -> interface Foo { f(): Promise<T> }
#   pactum Foo { cursore f(): T } -> interface Foo { f(): Generator<T> }
#   @ publica pactum Foo { ... }  -> export interface Foo { ... }

§ ex "../../../ast/sententia" importa Parametrum, PactumMethodus, Visibilitas
§ ex "../../../ast/typus" importa TypusAnnotatio
§ ex "../nucleus" importa TsGenerator

# External declarations - implementations live in index.fab
§ ex "./functio" importa genParametrum
§ ex "../typus" importa genTypus

@ publica
functio genPactum(in TsGenerator g, de textus nomen, de ignotum generaParametra, de lista<PactumMethodus> methodi, de ignotum visibilitas) -> textus {
    varia result = g.ind()

    # Module-level: export when public
    si nonnihil visibilitas {
        fixum vis = visibilitas qua Visibilitas
        si vis == Visibilitas.Publica {
            result = scriptum("§export ", result)
        }
    }

    result = scriptum("§interface §", result, nomen)

    si nonnihil generaParametra {
        fixum gp = generaParametra qua lista<textus>
        si gp.longitudo() > 0 {
            result = scriptum("§<§>", result, gp.coniunge(", "))
        }
    }

    result = scriptum("§ {\n", result)
    g.intraProfundum()

    ex methodi fixum methodus {
        varia params = [] innatum lista<textus>
        ex methodus.parametra fixum param {
            params.adde(genParametrum(g, param))
        }

        varia line = scriptum("§§(§)", g.ind(), methodus.nomen, params.coniunge(", "))
        varia reditus = ""
        si nonnihil methodus.typusReditus {
            reditus = genTypus(g, methodus.typusReditus novum TypusAnnotatio)
        }

        si reditus == "" et (methodus.generator aut methodus.asynca) {
            reditus = "void"
        }

        si methodus.generator {
            reditus = methodus.asynca sic scriptum("AsyncGenerator<§>", reditus) secus scriptum("Generator<§>", reditus)
        } sin methodus.asynca {
            reditus = scriptum("Promise<§>", reditus)
        }

        si reditus != "" {
            line = scriptum("§: §", line, reditus)
        }

        result = scriptum("§§;\n", result, line)
    }

    g.exiProfundum()
    result = scriptum("§§}", result, g.ind())

    redde result
}
