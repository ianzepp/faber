# TypeScript Statement Generator - Entry Points
#
# Generates program entry points (sync or async IIFE).
#
# TRANSFORMS:
#   incipit { ... }  -> (unwrapped body statements)
#   incipit argumenta args { ... } -> const args = process.argv.slice(2); (body statements)
#   incipiet { ... } -> (async () => { ... })();
#   incipiet argumenta args { ... } -> (async () => { const args = process.argv.slice(2); ... })();

importa ex "../../../ast/sententia" privata Sententia
importa ex "../nucleus" privata TsGenerator

importa ex "./index" privata genSententia

@ publica
functio genIncipit(in TsGenerator g, de ignotum corpus, de ignotum ergo, si de textus argNomen) -> textus {
    varia result = ""

    # Emit argumenta binding if present
    si nonnihil argNomen {
        result = scriptum("§const § = process.argv.slice(2);\n", g.ind(), argNomen)
    }

    si nonnihil corpus {
        result = scriptum("§§", result, genSententia(g, corpus qua Sententia))
        si nonnihil ergo {
            result = scriptum("§\n§", result, genSententia(g, ergo qua Sententia))
        }
        redde result
    }
    si nonnihil ergo {
        redde scriptum("§§", result, genSententia(g, ergo qua Sententia))
    }
    redde result
}

@ publica
functio genIncipiet(in TsGenerator g, de ignotum corpus, de ignotum ergo, si de textus argNomen) -> textus {
    g.intraProfundum()

    varia body = ""

    # Emit argumenta binding if present
    si nonnihil argNomen {
        body = scriptum("§const § = process.argv.slice(2);\n", g.ind(), argNomen)
    }

    si nonnihil corpus {
        body = scriptum("§§", body, genSententia(g, corpus qua Sententia))
    }
    g.exiProfundum()

    varia result = scriptum("§(async () => {\n§\n§})();", g.ind(), body, g.ind())

    si nonnihil ergo {
        result = scriptum("§\n§", result, genSententia(g, ergo qua Sententia))
    }

    redde result
}
