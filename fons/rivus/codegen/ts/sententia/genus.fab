# TypeScript Statement Generator - Class Declarations
#
# Generates TypeScript class declarations with inheritance and visibility.
#
# TRANSFORMS:
#   genus Foo { ... }               -> class Foo { ... }
#   genus Foo<T> { ... }            -> class Foo<T> { ... }
#   genus Foo s.extendit Bar { ... }  -> class Foo extends Bar { ... }
#   genus Foo s.implet X, Y { ... }   -> class Foo implements X, Y { ... }
#   @ s.abstractum genus Foo { ... }  -> abstract class Foo { ... }
#   @ publica genus Foo { ... }     -> export class Foo { ... }
#   campus publicus x: numerus      -> public x: number
#   campus staticus x: numerus      -> static x: number

importa ex "../../../ast/sententia" privata Sententia
importa ex "../../../ast/sententia" privata FunctioDeclaratio
importa ex "../../../ast/sententia" privata CampusDeclaratio
importa ex "../../../ast/sententia" privata Visibilitas
importa ex "../../../ast/sententia" privata GenusDeclaratio
importa ex "../../../ast/expressia" privata Expressia
importa ex "../../../ast/typus" privata TypusAnnotatio
importa ex "../nucleus" privata TsGenerator

# External declarations - implementations live in index.fab
importa ex "../expressia/index" privata genExpressia
importa ex "./index" privata genSententia
importa ex "../typus" privata genTypus

@ publica
functio genGenus(in TsGenerator g, de GenusDeclaratio s) -> textus {
    varia result = g.ind()

    # Determine class visibility for field inheritance
    varia classVisibility = Visibilitas.Privata
    si nonnihil s.visibilitas {
        classVisibility = s.visibilitas qua Visibilitas
    }

    # Module-level: export when public
    si nonnihil s.visibilitas {
        fixum vis = s.visibilitas qua Visibilitas
        si vis == Visibilitas.Publica {
            result = scriptum("§export ", result)
        }
    }

    si s.abstractum {
        result = scriptum("§abstract ", result)
    }

    result = scriptum("§class §", result, s.nomen)

    # Generics
    si nonnihil s.generaParametra {
        fixum gp = s.generaParametra qua lista<textus>
        si gp.longitudo() > 0 {
            result = scriptum("§<§>", result, gp.coniunge(", "))
        }
    }

    # Extends
    si nonnihil s.extendit {
        result = scriptum("§ extends §", result, s.extendit qua textus)
    }

    # Implements
    si nonnihil s.implet {
        fixum impl = s.implet qua lista<textus>
        si impl.longitudo() > 0 {
            result = scriptum("§ implements §", result, impl.coniunge(", "))
        }
    }

    result = scriptum("§ {\n", result)
    g.intraProfundum()
    g.inGenere = verum

    # Fields
    itera ex s.campi fixum campus {
        result = scriptum("§§\n", result, genCampus(g, campus, classVisibility))
    }

    # Split creo method from other methods
    varia creo = nihil qua si FunctioDeclaratio
    varia ceteri = [] innatum lista<FunctioDeclaratio>
    itera ex s.methodi fixum m {
        si m.structor {
            creo = m
        } secus {
            ceteri.appende(m)
        }
    }

    # Constructor (auto-merge)
    result = scriptum("§§\n", result, genAutoMergeConstructor(g, s.campi, nonnihil creo))

    # Private creo hook
    si nonnihil creo {
        result = scriptum("§§\n", result, genCreoMethod(g, creo qua Sententia))
    }

    # Methods
    itera ex ceteri fixum methodus {
        result = scriptum("§§\n", result, genSententia(g, methodus))
    }

    g.inGenere = falsum
    g.exiProfundum()
    result = scriptum("§§}", result, g.ind())

    redde result
}

functio genAutoMergeConstructor(in TsGenerator g, de lista<CampusDeclaratio> campi, bivalens hasCreo) -> textus {
    varia lines = [] innatum lista<textus>
    varia instFields = [] innatum lista<CampusDeclaratio>
    itera ex campi fixum campus {
        si non campus.staticum {
            instFields.appende(campus)
        }
    }

    varia props = [] innatum lista<textus>
    itera ex instFields fixum campus {
        props.appende(scriptum("§?: §", campus.nomen, genTypus(g, campus.typus)))
    }
    fixum overridesType = (instFields.longitudo() > 0) sic scriptum("{ § }", props.coniunge(", ")) secus "Record<string, never>"

    lines.appende(scriptum("§constructor(overrides: § = {}) {", g.ind(), overridesType))
    g.intraProfundum()

    itera ex instFields fixum campus {
        lines.appende(scriptum("§if (overrides.§ !== undefined) { this.§ = overrides.§; }", g.ind(), campus.nomen, campus.nomen, campus.nomen))
    }
    si hasCreo {
        lines.appende(scriptum("§this.creo();", g.ind()))
    }

    g.exiProfundum()
    lines.appende(scriptum("§}", g.ind()))

    redde lines.coniunge("\n")
}

functio genCreoMethod(in TsGenerator g, de Sententia creo) -> textus {
    discerne creo {
        casu FunctioDeclaratio ut f {
            varia body = "{}"
            si nonnihil f.corpus {
                g.intraProfundum()
                fixum content = genSententia(g, f.corpus)
                g.exiProfundum()
                body = scriptum("{\n§\n§}", content, g.ind())
            }
            redde scriptum("§private creo() §", g.ind(), body)
        }
        ceterum tacet
    }
    redde scriptum("§private creo() {}", g.ind())
}

@ publica
functio genCampus(in TsGenerator g, de CampusDeclaratio campus, Visibilitas classVisibility) -> textus {
    varia result = g.ind()

    # Determine effective visibility
    # HEURISTIC: For public classes, only emit explicit private/protected modifiers
    # This matches TypeScript's default where public is implicit
    varia effectiveVisibility = campus.visibilitas

    # If class is public and field would be private (default), make it public instead
    # This implements field visibility inheritance from parent class
    si classVisibility == Visibilitas.Publica et campus.visibilitas == Visibilitas.Privata {
        # Fields without explicit visibility in public classes should be public
        effectiveVisibility = Visibilitas.Publica
    }

    # Only emit modifier if private or protected (public is default in TS)
    si effectiveVisibility == Visibilitas.Privata {
        result = scriptum("§private ", result)
    } sin effectiveVisibility == Visibilitas.Protecta {
        result = scriptum("§protected ", result)
    }
    # For public visibility, emit no modifier (public is implicit in TypeScript)

    si campus.staticum {
        result = scriptum("§static ", result)
    }

    result = scriptum("§§: §", result, campus.nomen, genTypus(g, campus.typus))

    si nonnihil campus.valor {
        result = scriptum("§ = §", result, genExpressia(g, campus.valor))
    }

    redde scriptum("§;", result)
}
