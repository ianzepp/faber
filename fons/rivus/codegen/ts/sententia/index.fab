# TypeScript Statement Generator - Dispatch
#
# Routes statement AST nodes to their specific generators.
#
# WHY: Uses scriptum() for string formatting to avoid method call return type bugs.

importa ex "../../../ast/sententia" privata Sententia
importa ex "../../../ast/sententia" privata VariaGenus
importa ex "../../../ast/sententia" privata ScribeGradus
importa ex "../../../ast/sententia" privata IteratioGenus
importa ex "../../../ast/sententia" privata CuratorGenus
importa ex "../../../ast/sententia" privata Parametrum
importa ex "../../../ast/sententia" privata CampusDeclaratio
importa ex "../../../ast/sententia" privata EligeCasus
importa ex "../../../ast/sententia" privata VariansCasus
importa ex "../../../ast/sententia" privata CustodiClausula
importa ex "../../../ast/sententia" privata CapeClausula
importa ex "../../../ast/sententia" privata OrdoMembrum
importa ex "../../../ast/sententia" privata VariansDeclaratio
importa ex "../../../ast/sententia" privata ImportaSpecificator
importa ex "../../../ast/sententia" privata PactumMethodus
importa ex "../../../ast/sententia" privata TypusParametrum
importa ex "../../../ast/sententia" privata SeriesDestructuraElementum
importa ex "../../../ast/sententia" privata Visibilitas
importa ex "../../../ast/sententia" privata ProbaModificator
importa ex "../../../ast/sententia" privata PraeparaTempus
importa ex "../../../ast/sententia" privata ReddeVerbum
importa ex "../../../ast/expressia" privata Expressia
importa ex "../../../ast/expressia" privata LitteraGenus
importa ex "../../../ast/typus" privata TypusAnnotatio
importa ex "../nucleus" privata TsGenerator
importa ex "../typus" privata genTypus
importa ex "../expressia/index" privata genExpressia
importa ex "./varia" privata genVaria
importa ex "./si" privata genSi
importa ex "./importa" privata genImporta
importa ex "./importa" privata genDestructura
importa ex "./importa" privata genSeriesDestructura
importa ex "./functio" privata genFunctio
importa ex "./functio" privata genParametrum
importa ex "./genus" privata genGenus
importa ex "./genus" privata genCampus
importa ex "./pactum" privata genPactum
importa ex "./typealias" privata genTypusAlias
importa ex "./ordo" privata genOrdo
importa ex "./discretio" privata genDiscretio
importa ex "./dum" privata genDum
importa ex "./iteratio" privata genIteratio
importa ex "./elige" privata genElige
importa ex "./discerne" privata genDiscerne
importa ex "./custodi" privata genCustodi
importa ex "./tempta" privata genTempta
importa ex "./iace" privata genIace
importa ex "./fac" privata genFac
importa ex "./adfirma" privata genAdfirma
importa ex "./scribe" privata genScribe
importa ex "./redde" privata genRedde
importa ex "./incipit" privata genIncipit
importa ex "./incipit" privata genIncipiet
importa ex "./cura" privata genCura
importa ex "./proba" privata genProbandum
importa ex "./proba" privata genProba
importa ex "./proba" privata genPraepara
importa ex "./proba" privata genProbaHarness

# =============================================================================
# STATEMENT DISPATCH
# =============================================================================

# Generate TypeScript code for a statement
#
# WHY: Wraps statement generation with comment emission. Leading comments
#      appear before the statement, trailing comments on the same line.
#      Currently stubbed (returns empty strings) for bootstrap.
@ publica
functio genSententia(in TsGenerator g, de Sententia stmt) -> textus {
    fixum leading = g.notaePrae(stmt)
    fixum trailing = g.notaePost(stmt)
    fixum content = genSententiaContent(g, stmt)
    redde scriptum("§§§", leading, content, trailing)
}

# Generate statement content without comments
functio genSententiaContent(in TsGenerator g, de Sententia stmt) -> textus {
    discerne stmt {
        # Block
        casu MassaSententia ut s {
            redde genMassa(g, s.corpus qua lista<Sententia>)
        }

        # Variable declarations
        casu VariaSententia ut s {
            redde genVaria(g, s.species qua VariaGenus, s.nomen qua textus, s.typus, s.valor, s.externa qua bivalens, s.visibilitas)
        }

        casu ImportaSententia ut s {
            redde genImporta(g, s.fons qua textus, s.specificatores qua lista<ImportaSpecificator>, s.totum qua bivalens, s.totumAlias)
        }

        casu DestructuraSententia ut s {
            redde genDestructura(g, s.fons, s.species qua VariaGenus, s.specificatores qua lista<ImportaSpecificator>)
        }

        casu SeriesDestructuraSententia ut s {
            redde genSeriesDestructura(g, s.elementa qua lista<SeriesDestructuraElementum>, s.fons, s.species qua VariaGenus)
        }

        # Function declaration
        casu FunctioDeclaratio ut f {
            redde genFunctio(g, f)
        }

        # Type declarations
        casu GenusDeclaratio ut s {
            redde genGenus(g, s)
        }

        casu PactumDeclaratio ut s {
            redde genPactum(g, s.nomen qua textus, s.generaParametra, s.methodi qua lista<PactumMethodus>, s.visibilitas)
        }

        casu TypusAliasDeclaratio ut s {
            redde genTypusAlias(g, s.nomen qua textus, s.typus novum TypusAnnotatio, s.scopusNomen, s.visibilitas)
        }

        casu OrdoDeclaratio ut s {
            redde genOrdo(g, s.nomen qua textus, s.membra qua lista<OrdoMembrum>, s.visibilitas)
        }

        casu DiscretioDeclaratio ut s {
            redde genDiscretio(g, s.nomen qua textus, s.generaParametra, s.variantes qua lista<VariansDeclaratio>, s.visibilitas)
        }

        # Control flow
        casu SiSententia ut s {
            redde genSi(g, s.condicio, s.consequens qua Sententia, s.alternans, s.cape)
        }

        casu DumSententia ut s {
            redde genDum(g, s.condicio, s.corpus, s.cape)
        }

        casu IteratioSententia ut s {
            redde genIteratio(g, s.species qua IteratioGenus, s.variabilis, s.iterabile, s.corpus, s.asynca qua bivalens, s.mutabilis qua bivalens, s.cape)
        }

        casu EligeSententia ut s {
            redde genElige(g, s.discriminans, s.casus qua lista<EligeCasus>, s.praedefinitum, s.cape)
        }

        casu DiscerneSententia ut s {
            redde genDiscerne(g, s.discriminantes, s.casus qua lista<VariansCasus>)
        }

        casu CustodiSententia ut s {
            redde genCustodi(g, s.clausulae qua lista<CustodiClausula>)
        }

        # Error handling
        casu TemptaSententia ut s {
            redde genTempta(g, s.corpus, s.cape, s.demum)
        }

        casu IaceSententia ut s {
            redde genIace(g, s.fatale qua bivalens, s.argumentum)
        }

        casu FacSententia ut s {
            redde genFac(g, s.corpus, s.condicio, s.cape)
        }

        casu AdfirmaSententia ut s {
            redde genAdfirma(g, s.condicio, s.nuntius)
        }

        # Actions
        casu ScribeSententia ut s {
            redde genScribe(g, s.gradus qua ScribeGradus, s.argumenta qua lista<Expressia>)
        }

        casu ReddeSententia ut s {
            redde genRedde(g, s.valor)
        }

        casu RumpeSententia {
            redde scriptum("§break;", g.ind())
        }

        casu PergeSententia {
            redde scriptum("§continue;", g.ind())
        }

        casu TacetSententia {
            redde scriptum("§{}", g.ind())
        }

        casu ExpressiaSententia ut s {
            redde scriptum("§§;", g.ind(), genExpressia(g, s.expressia))
        }

        casu IncipitSententia ut s {
            redde genIncipit(g, s.corpus, s.ergo, s.argumenta)
        }

        casu IncipietSententia ut s {
            redde genIncipiet(g, s.corpus, s.ergo, s.argumenta)
        }

        casu CuraSententia ut s {
            redde genCura(g, s.curatorSpecies, s.res, s.vinculum qua textus, s.corpus, s.asynca qua bivalens, s.mutabilis qua bivalens, s.cape)
        }

        casu AdSententia {
            redde scriptum("§throw new Error(\"ad statement not implemented\");", g.ind())
        }

        # Tests - skip if stripTests is enabled
        casu ProbandumSententia ut s {
            si g.stripTests {
                redde ""
            }
            redde genProbandum(g, s.nomen qua textus, s.corpus qua lista<Sententia>, s.ompitur, s.ratioOmissionis, s.solum, s.tags)
        }

        casu ProbaSententia ut s {
            si g.stripTests {
                redde ""
            }
            redde genProba(g, s.nomen qua textus, s.modificator, s.corpus, s.ratioModificatoris, s.solum, s.tags, s.temporis, s.metior, s.repete, s.fragilis, s.requirit, s.solumIn)
        }

        casu PraeparaMassa ut s {
            si g.stripTests {
                redde ""
            }
            redde genPraepara(g, s.tempus qua PraeparaTempus, s.asynca qua bivalens, s.omnia qua bivalens, s.corpus)
        }
    }

    mori "Codegen error: unhandled statement type in genSententia"
}

# =============================================================================
# BLOCK
# =============================================================================

@ publica
functio genMassa(in TsGenerator g, de lista<Sententia> corpus) -> textus {
    si corpus.longitudo() == 0 {
        # WHY: Empty blocks should not stringify to undefined.
        redde ""
    }
    varia lines = [] innatum lista<textus>
    ex corpus fixum stmt {
        lines.appende(genSententia(g, stmt))
    }
    redde lines.coniunge("\n")
}
