# TypeScript Statement Generator - Dispatch
#
# Routes statement AST nodes to their specific generators.
#
# WHY: Uses scriptum() for string formatting to avoid method call return type bugs.

§ ex "../../../ast/sententia" importa Sententia, VariaGenus, ScribeGradus, IteratioGenus, CuratorGenus
§ ex "../../../ast/sententia" importa Parametrum, CampusDeclaratio, EligeCasus, VariansCasus
§ ex "../../../ast/sententia" importa CustodiClausula, CapeClausula, OrdoMembrum, VariansDeclaratio
§ ex "../../../ast/sententia" importa ImportaSpecificator, PactumMethodus, TypusParametrum
§ ex "../../../ast/sententia" importa SeriesDestructuraElementum
§ ex "../../../ast/sententia" importa Visibilitas, ProbaModificator, PraeparaTempus, ReddeVerbum
§ ex "../../../ast/expressia" importa Expressia, LitteraGenus
§ ex "../../../ast/typus" importa TypusAnnotatio
§ ex "../nucleus" importa TsGenerator
§ ex "../typus" importa genTypus
§ ex "../expressia/index" importa genExpressia
§ ex "./varia" importa genVaria
§ ex "./si" importa genSi
§ ex "./importa" importa genImporta, genDestructura, genSeriesDestructura
§ ex "./functio" importa genFunctio, genParametrum
§ ex "./genus" importa genGenus, genCampus
§ ex "./pactum" importa genPactum
§ ex "./typealias" importa genTypusAlias
§ ex "./ordo" importa genOrdo
§ ex "./discretio" importa genDiscretio
§ ex "./dum" importa genDum
§ ex "./iteratio" importa genIteratio
§ ex "./elige" importa genElige
§ ex "./discerne" importa genDiscerne
§ ex "./custodi" importa genCustodi
§ ex "./tempta" importa genTempta
§ ex "./iace" importa genIace
§ ex "./fac" importa genFac
§ ex "./adfirma" importa genAdfirma
§ ex "./scribe" importa genScribe
§ ex "./redde" importa genRedde
§ ex "./incipit" importa genIncipit, genIncipiet
§ ex "./cura" importa genCura
§ ex "./proba" importa genProbandum, genProba, genPraepara, genProbaHarness

# =============================================================================
# STATEMENT DISPATCH
# =============================================================================

# Generate TypeScript code for a statement
#
# WHY: Wraps statement generation with comment emission. Leading comments
#      appear before the statement, trailing comments on the same line.
#      Currently stubbed (returns empty strings) for bootstrap.
@ publica
functio genSententia(in TsGenerator g, de Sententia stmt) -> textus {
    fixum leading = g.notaePrae(stmt)
    fixum trailing = g.notaePost(stmt)
    fixum content = genSententiaContent(g, stmt)
    redde scriptum("§§§", leading, content, trailing)
}

# Generate statement content without comments
functio genSententiaContent(in TsGenerator g, de Sententia stmt) -> textus {
    discerne stmt {
        # Block
        casu MassaSententia ut s {
            redde genMassa(g, s.corpus qua lista<Sententia>)
        }

        # Variable declarations
        casu VariaSententia ut s {
            redde genVaria(g, s.species qua VariaGenus, s.nomen qua textus, s.typus, s.valor, s.externa qua bivalens, s.visibilitas)
        }

        casu ImportaSententia ut s {
            redde genImporta(g, s.fons qua textus, s.specificatores qua lista<ImportaSpecificator>, s.totum qua bivalens, s.totumAlias)
        }

        casu DestructuraSententia ut s {
            redde genDestructura(g, s.fons, s.species qua VariaGenus, s.specificatores qua lista<ImportaSpecificator>)
        }

        casu SeriesDestructuraSententia ut s {
            redde genSeriesDestructura(g, s.elementa qua lista<SeriesDestructuraElementum>, s.fons, s.species qua VariaGenus)
        }

        # Function declaration
        casu FunctioDeclaratio ut f {
            redde genFunctio(g, f)
        }

        # Type declarations
        casu GenusDeclaratio ut s {
            redde genGenus(g, s)
        }

        casu PactumDeclaratio ut s {
            redde genPactum(g, s.nomen qua textus, s.generaParametra, s.methodi qua lista<PactumMethodus>, s.visibilitas)
        }

        casu TypusAliasDeclaratio ut s {
            redde genTypusAlias(g, s.nomen qua textus, s.typus novum TypusAnnotatio, s.scopusNomen, s.visibilitas)
        }

        casu OrdoDeclaratio ut s {
            redde genOrdo(g, s.nomen qua textus, s.membra qua lista<OrdoMembrum>, s.visibilitas)
        }

        casu DiscretioDeclaratio ut s {
            redde genDiscretio(g, s.nomen qua textus, s.generaParametra, s.variantes qua lista<VariansDeclaratio>, s.visibilitas)
        }

        # Control flow
        casu SiSententia ut s {
            redde genSi(g, s.condicio, s.consequens qua Sententia, s.alternans, s.cape)
        }

        casu DumSententia ut s {
            redde genDum(g, s.condicio, s.corpus, s.cape)
        }

        casu IteratioSententia ut s {
            redde genIteratio(g, s.species qua IteratioGenus, s.variabilis, s.iterabile, s.corpus, s.asynca qua bivalens, s.mutabilis qua bivalens, s.cape)
        }

        casu EligeSententia ut s {
            redde genElige(g, s.discriminans, s.casus qua lista<EligeCasus>, s.praedefinitum, s.cape)
        }

        casu DiscerneSententia ut s {
            redde genDiscerne(g, s.discriminantes, s.casus qua lista<VariansCasus>)
        }

        casu CustodiSententia ut s {
            redde genCustodi(g, s.clausulae qua lista<CustodiClausula>)
        }

        # Error handling
        casu TemptaSententia ut s {
            redde genTempta(g, s.corpus, s.cape, s.demum)
        }

        casu IaceSententia ut s {
            redde genIace(g, s.fatale qua bivalens, s.argumentum)
        }

        casu FacSententia ut s {
            redde genFac(g, s.corpus, s.condicio, s.cape)
        }

        casu AdfirmaSententia ut s {
            redde genAdfirma(g, s.condicio, s.nuntius)
        }

        # Actions
        casu ScribeSententia ut s {
            redde genScribe(g, s.gradus qua ScribeGradus, s.argumenta qua lista<Expressia>)
        }

        casu ReddeSententia ut s {
            redde genRedde(g, s.valor)
        }

        casu RumpeSententia {
            redde scriptum("§break;", g.ind())
        }

        casu PergeSententia {
            redde scriptum("§continue;", g.ind())
        }

        casu TacetSententia {
            redde scriptum("§{}", g.ind())
        }

        casu ExpressiaSententia ut s {
            redde scriptum("§§;", g.ind(), genExpressia(g, s.expressia))
        }

        casu IncipitSententia ut s {
            redde genIncipit(g, s.corpus, s.ergo, s.argumenta)
        }

        casu IncipietSententia ut s {
            redde genIncipiet(g, s.corpus, s.ergo, s.argumenta)
        }

        casu CuraSententia ut s {
            redde genCura(g, s.curatorSpecies, s.res, s.vinculum qua textus, s.corpus, s.asynca qua bivalens, s.mutabilis qua bivalens, s.cape)
        }

        casu AdSententia {
            redde scriptum("§throw new Error(\"ad statement not implemented\");", g.ind())
        }

        # Tests - skip if stripTests is enabled
        casu ProbandumSententia ut s {
            si g.stripTests {
                redde ""
            }
            redde genProbandum(g, s.nomen qua textus, s.corpus qua lista<Sententia>, s.ompitur, s.ratioOmissionis, s.solum, s.tags)
        }

        casu ProbaSententia ut s {
            si g.stripTests {
                redde ""
            }
            redde genProba(g, s.nomen qua textus, s.modificator, s.corpus, s.ratioModificatoris, s.solum, s.tags, s.temporis, s.metior, s.repete, s.fragilis, s.requirit, s.solumIn)
        }

        casu PraeparaMassa ut s {
            si g.stripTests {
                redde ""
            }
            redde genPraepara(g, s.tempus qua PraeparaTempus, s.asynca qua bivalens, s.omnia qua bivalens, s.corpus)
        }
    }

    mori "Codegen error: unhandled statement type in genSententia"
}

# =============================================================================
# BLOCK
# =============================================================================

@ publica
functio genMassa(in TsGenerator g, de lista<Sententia> corpus) -> textus {
    si corpus.longitudo() == 0 {
        # WHY: Empty blocks should not stringify to undefined.
        redde ""
    }
    varia lines = [] innatum lista<textus>
    ex corpus fixum stmt {
        lines.appende(genSententia(g, stmt))
    }
    redde lines.coniunge("\n")
}
