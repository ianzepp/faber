# Code Generator - Public API with Target Validation
#
# Entry point for code generation with automatic target compatibility checking.
# Validates that source features are supported by the target before generating.
#
# USAGE
# =====
# fixum code = generate(corpus, "ts")           # Strict validation (default)
# fixum code = generate(corpus, "rs", POLITIA_RELAXATA)  # Allow emulated features
#
# ERRORS
# ======
# Throws if validation fails. Use validateOnly() for non-throwing checks.

importa ex "../ast/sententia" privata Sententia
importa ex "./validitor" privata validateCompatibilitatem
importa ex "./validitor" privata formatValidatioErrores
importa ex "./validitor" privata ValidatioPolitia
importa ex "./validitor" privata POLITIA_STRICTA
importa ex "./validitor" privata POLITIA_RELAXATA
importa ex "./validitor" privata validatioSuccessit
importa ex "./validitor" privata ValidatioError
importa ex "./ts/index" privata generateTs
importa ex "./ts/index" privata generateTsWithTests
importa ex "./ts/index" privata generateTsWithOptions
importa ex "./go/index" privata generateGo
importa ex "./faber/index" privata generateFaber
importa ex "./faber/index" privata generateFaberStripComments
importa ex "./glyph/index" privata generateGlyph
importa ex "./glyph/index" privata generateGlyphStripComments

# =============================================================================
# PUBLIC API
# =============================================================================

# Generate code for target with validation
# Throws if target compatibility validation fails
@ publica
functio generate(de lista<Sententia> corpus, de textus target, si de textus viaFons) -> textus {
    redde generateWithPolicy(corpus, target, POLITIA_STRICTA, viaFons)
}

# Generate code with test blocks stripped (for production builds)
@ publica
functio generateStripTests(de lista<Sententia> corpus, de textus target, si de textus viaFons) -> textus {
    redde generateWithStripping(corpus, target, verum, falsum, viaFons)
}

# Generate code with comments stripped
@ publica
functio generateStripComments(de lista<Sententia> corpus, de textus target, si de textus viaFons) -> textus {
    redde generateWithStripping(corpus, target, falsum, verum, viaFons)
}

# Generate code with optional stripping of tests and/or comments
@ publica
functio generateWithStripping(de lista<Sententia> corpus, de textus target, bivalens stripTests, bivalens stripComments, si de textus viaFons) -> textus {
    # Validate first
    fixum errores = validateCompatibilitatem(corpus, target, POLITIA_STRICTA)
    si non validatioSuccessit(errores) {
        mori formatValidatioErrores(errores, target)
    }

    elige target {
        casu "ts" { redde generateTsWithOptions(corpus, stripTests, stripComments, viaFons) }
        casu "faber" {
            si stripComments {
                redde generateFaberStripComments(corpus)
            }
            redde generateFaber(corpus)
        }
        casu "glyph" {
            si stripComments {
                redde generateGlyphStripComments(corpus)
            }
            redde generateGlyph(corpus)
        }
        ceterum {
            mori scriptum("Stripping not supported for target 'ยง'. Supported: ts, faber, glyph", target)
        }
    }
}

# Generate code with explicit policy
@ publica
functio generateWithPolicy(de lista<Sententia> corpus, de textus target, de ValidatioPolitia politia, si de textus viaFons) -> textus {
    # Validate target compatibility BEFORE codegen
    fixum errores = validateCompatibilitatem(corpus, target, politia)

    si non validatioSuccessit(errores) {
        mori formatValidatioErrores(errores, target)
    }

    # Dispatch to target-specific generator
    # NOTE: rs, zig, cpp archived until reimplemented (see archivum/rivus-codegen/)
    elige target {
        casu "ts" { redde generateTs(corpus, viaFons) }
        casu "go" { redde generateGo(corpus) }
        casu "faber" { redde generateFaber(corpus) }
        casu "glyph" { redde generateGlyph(corpus) }
        ceterum {
            mori scriptum("Unknown target 'ยง'. Supported: ts, go, faber, glyph", target)
        }
    }
}

# Generate code with standalone test harness (for `rivus test` command)
# Currently only supports TypeScript target
@ publica
functio generateWithTests(de lista<Sententia> corpus, de textus target, si de textus viaFons) -> textus {
    # Validate first
    fixum errores = validateCompatibilitatem(corpus, target, POLITIA_STRICTA)
    si non validatioSuccessit(errores) {
        mori formatValidatioErrores(errores, target)
    }

    elige target {
        casu "ts" { redde generateTsWithTests(corpus, viaFons) }
        ceterum {
            mori scriptum("Test generation not supported for target 'ยง'. Only 'ts' is supported.", target)
        }
    }
}

# Validate without generating - returns errors (empty if valid)
@ publica
functio validateOnly(de lista<Sententia> corpus, de textus target) -> lista<ValidatioError> {
    redde validateCompatibilitatem(corpus, target, POLITIA_STRICTA)
}

# Validate with explicit policy
@ publica
functio validateOnlyWithPolicy(de lista<Sententia> corpus, de textus target, de ValidatioPolitia politia) -> lista<ValidatioError> {
    redde validateCompatibilitatem(corpus, target, politia)
}

# Check if code is compatible with target (convenience function)
@ publica
functio isCompatible(de lista<Sententia> corpus, de textus target) -> bivalens {
    fixum errores = validateCompatibilitatem(corpus, target, POLITIA_STRICTA)
    redde validatioSuccessit(errores)
}

# =============================================================================
# RE-EXPORTS
# =============================================================================

# Re-export policy constants for convenience
@ publica
fixum StrictPolicy = POLITIA_STRICTA
@ publica
fixum RelaxedPolicy = POLITIA_RELAXATA
