# Code Generator - Public API with Target Validation
#
# Entry point for code generation with automatic target compatibility checking.
# Validates that source features are supported by the target before generating.
#
# USAGE
# =====
# fixum code = generate(corpus, "ts")           # Strict validation (default)
# fixum code = generate(corpus, "rs", POLITIA_RELAXATA)  # Allow emulated features
#
# ERRORS
# ======
# Throws if validation fails. Use validateOnly() for non-throwing checks.

§ ex "../ast/sententia" importa Sententia
§ ex "./validitor" importa validateCompatibilitatem, formatValidatioErrores
§ ex "./validitor" importa ValidatioPolitia, POLITIA_STRICTA, POLITIA_RELAXATA
§ ex "./validitor" importa validatioSuccessit, ValidatioError
§ ex "./ts/index" importa generateTs, generateTsWithTests, generateTsWithOptions
§ ex "./go/index" importa generateGo

# =============================================================================
# PUBLIC API
# =============================================================================

# Generate code for target with validation
# Throws if target compatibility validation fails
@ publica
functio generate(de lista<Sententia> corpus, de textus target, si de textus viaFons) -> textus {
    redde generateWithPolicy(corpus, target, POLITIA_STRICTA, viaFons)
}

# Generate code with test blocks stripped (for production builds)
@ publica
functio generateStripTests(de lista<Sententia> corpus, de textus target, si de textus viaFons) -> textus {
    redde generateWithStripping(corpus, target, verum, falsum, viaFons)
}

# Generate code with comments stripped
@ publica
functio generateStripComments(de lista<Sententia> corpus, de textus target, si de textus viaFons) -> textus {
    redde generateWithStripping(corpus, target, falsum, verum, viaFons)
}

# Generate code with optional stripping of tests and/or comments
@ publica
functio generateWithStripping(de lista<Sententia> corpus, de textus target, bivalens stripTests, bivalens stripComments, si de textus viaFons) -> textus {
    # Validate first
    fixum errores = validateCompatibilitatem(corpus, target, POLITIA_STRICTA)
    si non validatioSuccessit(errores) {
        mori formatValidatioErrores(errores, target)
    }

    elige target {
        casu "ts" { redde generateTsWithOptions(corpus, stripTests, stripComments, viaFons) }
        ceterum {
            mori scriptum("Stripping not supported for target '§'. Only 'ts' is supported.", target)
        }
    }
}

# Generate code with explicit policy
@ publica
functio generateWithPolicy(de lista<Sententia> corpus, de textus target, de ValidatioPolitia politia, si de textus viaFons) -> textus {
    # Validate target compatibility BEFORE codegen
    fixum errores = validateCompatibilitatem(corpus, target, politia)

    si non validatioSuccessit(errores) {
        mori formatValidatioErrores(errores, target)
    }

    # Dispatch to target-specific generator
    # NOTE: rs, zig, cpp archived until reimplemented (see archivum/rivus-codegen/)
    elige target {
        casu "ts" { redde generateTs(corpus, viaFons) }
        casu "go" { redde generateGo(corpus) }
        ceterum {
            mori scriptum("Unknown target '§'. Supported: ts, go", target)
        }
    }
}

# Generate code with standalone test harness (for `rivus test` command)
# Currently only supports TypeScript target
@ publica
functio generateWithTests(de lista<Sententia> corpus, de textus target, si de textus viaFons) -> textus {
    # Validate first
    fixum errores = validateCompatibilitatem(corpus, target, POLITIA_STRICTA)
    si non validatioSuccessit(errores) {
        mori formatValidatioErrores(errores, target)
    }

    elige target {
        casu "ts" { redde generateTsWithTests(corpus, viaFons) }
        ceterum {
            mori scriptum("Test generation not supported for target '§'. Only 'ts' is supported.", target)
        }
    }
}

# Validate without generating - returns errors (empty if valid)
@ publica
functio validateOnly(de lista<Sententia> corpus, de textus target) -> lista<ValidatioError> {
    redde validateCompatibilitatem(corpus, target, POLITIA_STRICTA)
}

# Validate with explicit policy
@ publica
functio validateOnlyWithPolicy(de lista<Sententia> corpus, de textus target, de ValidatioPolitia politia) -> lista<ValidatioError> {
    redde validateCompatibilitatem(corpus, target, politia)
}

# Check if code is compatible with target (convenience function)
@ publica
functio isCompatible(de lista<Sententia> corpus, de textus target) -> bivalens {
    fixum errores = validateCompatibilitatem(corpus, target, POLITIA_STRICTA)
    redde validatioSuccessit(errores)
}

# =============================================================================
# RE-EXPORTS
# =============================================================================

# Re-export policy constants for convenience
@ publica
fixum StrictPolicy = POLITIA_STRICTA
@ publica
fixum RelaxedPolicy = POLITIA_RELAXATA
