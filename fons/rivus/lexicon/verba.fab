# Verba - Latin reserved words
#
# Keyword recognition for the lexer and parser.
# Uses switch-based lookup (no heap allocation).
#
# This is the single source of truth for keyword classification.
# Parser error recovery uses these predicates to find sync points.

ex "../ast/lexema" importa VerbumId

@ publicum
ordo Dialectus {
    Latinus
    Anglicus
}

# Check if a word is a reserved keyword
#
# NOTE: This list must stay synchronized with fons/lexicon/keywords.ts
@ publica
functio estVerbum(textus v) -> bivalens {
    fixum id = verbumId(v)
    redde id != nihil
}

# Map surface keyword spelling to canonical identity
#
# WHY: Enables dialect spellings (e.g., English keywords) without changing
#      downstream parsing/codegen logic.
@ publica
functio verbumId(textus v, si Dialectus dialectus) -> VerbumId? {
    si nonnihil dialectus et dialectus === Dialectus.Anglicus {
        elige v {
            casu "becomes" { redde VerbumId.Fit }
            casu "will_become" { redde VerbumId.Fiet }
            casu "become_each" { redde VerbumId.Fiunt }
            casu "will_become_each" { redde VerbumId.Fient }
            ceterum { }
        }
    }

    elige v {
        # Imperium - control flow
        casu "si" { redde VerbumId.Si }
        casu "secus" { redde VerbumId.Secus }
        casu "sin" { redde VerbumId.Sin }
        casu "casu" { redde VerbumId.Casu }
        casu "ceterum" { redde VerbumId.Ceterum }
        casu "dum" { redde VerbumId.Dum }
        casu "fac" { redde VerbumId.Fac }
        casu "pro" { redde VerbumId.Pro }
        casu "elige" { redde VerbumId.Elige }
        casu "ergo" { redde VerbumId.Ergo }
        casu "rumpe" { redde VerbumId.Rumpe }
        casu "perge" { redde VerbumId.Perge }
        casu "redde" { redde VerbumId.Redde }
        casu "reddit" { redde VerbumId.Reddit }
        casu "custodi" { redde VerbumId.Custodi }
        casu "adfirma" { redde VerbumId.Adfirma }
        casu "discerne" { redde VerbumId.Discerne }
        casu "incipit" { redde VerbumId.Incipit }
        casu "incipiet" { redde VerbumId.Incipiet }

        # Imperium - testing
        casu "probandum" { redde VerbumId.Probandum }
        casu "proba" { redde VerbumId.Proba }
        casu "praepara" { redde VerbumId.Praepara }
        casu "praeparabit" { redde VerbumId.Praeparabit }
        casu "postpara" { redde VerbumId.Postpara }
        casu "postparabit" { redde VerbumId.Postparabit }
        casu "cura" { redde VerbumId.Cura }
        casu "arena" { redde VerbumId.Arena }
        casu "page" { redde VerbumId.Pagina }
        casu "pagina" { redde VerbumId.Pagina }
        casu "tempta" { redde VerbumId.Tempta }
        casu "cape" { redde VerbumId.Cape }
        casu "demum" { redde VerbumId.Demum }
        casu "iace" { redde VerbumId.Iace }
        casu "mori" { redde VerbumId.Mori }
        casu "scribe" { redde VerbumId.Scribe }
        casu "vide" { redde VerbumId.Vide }
        casu "mone" { redde VerbumId.Mone }
        casu "lege" { redde VerbumId.Lege }
        casu "lineam" { redde VerbumId.Lineam }
        casu "scriptum" { redde VerbumId.Scriptum }
        casu "cede" { redde VerbumId.Cede }

        # Declaratio - declarations
        casu "varia" { redde VerbumId.Varia }
        casu "fixum" { redde VerbumId.Fixum }
        casu "figendum" { redde VerbumId.Figendum }
        casu "variandum" { redde VerbumId.Variandum }
        casu "functio" { redde VerbumId.Functio }
        casu "novum" { redde VerbumId.Novum }
        casu "finge" { redde VerbumId.Finge }
        casu "importa" { redde VerbumId.Importa }
        casu "exporta" { redde VerbumId.Exporta }
        casu "typus" { redde VerbumId.Typus }
        casu "genus" { redde VerbumId.Genus }
        casu "pactum" { redde VerbumId.Pactum }
        casu "ordo" { redde VerbumId.Ordo }
        casu "discretio" { redde VerbumId.Discretio }

        # Modificator - modifiers
        casu "futura" { redde VerbumId.Futura }
        casu "prae" { redde VerbumId.Prae }
        casu "praefixum" { redde VerbumId.Praefixum }
        casu "cursor" { redde VerbumId.Cursor }
        casu "curata" { redde VerbumId.Curata }
        casu "publicus" { redde VerbumId.Publicus }
        casu "privatus" { redde VerbumId.Privatus }
        casu "generis" { redde VerbumId.Generis }
        casu "implet" { redde VerbumId.Implet }
        casu "sub" { redde VerbumId.Sub }
        casu "abstractus" { redde VerbumId.Abstractus }
        casu "protectus" { redde VerbumId.Protectus }
        casu "nexum" { redde VerbumId.Nexum }
        casu "omitte" { redde VerbumId.Omitte }
        casu "futurum" { redde VerbumId.Futurum }
        casu "omnia" { redde VerbumId.Omnia }

        # Operator - operators
        casu "et" { redde VerbumId.Et }
        casu "aut" { redde VerbumId.Aut }
        casu "non" { redde VerbumId.Non }
        casu "est" { redde VerbumId.Est }
        casu "sic" { redde VerbumId.Sic }
        casu "fit" { redde VerbumId.Fit }
        casu "fiet" { redde VerbumId.Fiet }
        casu "fiunt" { redde VerbumId.Fiunt }
        casu "fient" { redde VerbumId.Fient }
        casu "vel" { redde VerbumId.Vel }
        casu "ante" { redde VerbumId.Ante }
        casu "usque" { redde VerbumId.Usque }
        casu "intra" { redde VerbumId.Intra }
        casu "inter" { redde VerbumId.Inter }
        casu "sparge" { redde VerbumId.Sparge }
        casu "ceteri" { redde VerbumId.Ceteri }
        casu "nulla" { redde VerbumId.Nulla }
        casu "nonnulla" { redde VerbumId.Nonnulla }
        casu "nihil" { redde VerbumId.Nihil }
        casu "nonnihil" { redde VerbumId.Nonnihil }
        casu "negativum" { redde VerbumId.Negativum }
        casu "positivum" { redde VerbumId.Positivum }

        # Valor - literal values
        casu "verum" { redde VerbumId.Verum }
        casu "falsum" { redde VerbumId.Falsum }
        casu "ego" { redde VerbumId.Ego }

        # Praepositio - prepositions
        casu "de" { redde VerbumId.De }
        casu "in" { redde VerbumId.In }
        casu "ex" { redde VerbumId.Ex }
        casu "ad" { redde VerbumId.Ad }
        casu "per" { redde VerbumId.Per }
        casu "qua" { redde VerbumId.Qua }
        casu "ut" { redde VerbumId.Ut }

        # Dsl - domain specific
        casu "ab" { redde VerbumId.Ab }
        casu "ubi" { redde VerbumId.Ubi }
        casu "prima" { redde VerbumId.Prima }
        casu "ultima" { redde VerbumId.Ultima }
        casu "summa" { redde VerbumId.Summa }
        casu "ordina" { redde VerbumId.Ordina }
        casu "collige" { redde VerbumId.Collige }
        casu "grupa" { redde VerbumId.Grupa }
        casu "sed" { redde VerbumId.Sed }

        ceterum { redde nihil }
    }
}

# Check if a word starts a statement (for error recovery sync points)
#
# WHY: Parser error recovery skips tokens until hitting a statement boundary.
#      This list defines where the parser can safely resume after an error.
#      Keeping it here ensures sync points stay aligned with the grammar.
@ publica
functio estVerbumSententiae(textus v) -> bivalens {
    elige v {
        # Declarations
        casu "functio" { redde verum }
        casu "varia" { redde verum }
        casu "fixum" { redde verum }
        casu "figendum" { redde verum }
        casu "variandum" { redde verum }
        casu "typus" { redde verum }
        casu "ordo" { redde verum }
        casu "genus" { redde verum }
        casu "pactum" { redde verum }
        casu "discretio" { redde verum }

        # Control flow
        casu "si" { redde verum }
        casu "dum" { redde verum }
        casu "ex" { redde verum }
        casu "de" { redde verum }
        casu "elige" { redde verum }
        casu "discerne" { redde verum }
        casu "custodi" { redde verum }
        casu "fac" { redde verum }
        casu "in" { redde verum }

        # Actions
        casu "redde" { redde verum }
        casu "rumpe" { redde verum }
        casu "perge" { redde verum }
        casu "scribe" { redde verum }
        casu "vide" { redde verum }
        casu "mone" { redde verum }
        casu "adfirma" { redde verum }
        casu "iace" { redde verum }
        casu "mori" { redde verum }
        casu "cede" { redde verum }

        # Error handling
        casu "tempta" { redde verum }
        casu "cura" { redde verum }

        # Entry points
        casu "incipit" { redde verum }
        casu "incipiet" { redde verum }

        # Testing
        casu "probandum" { redde verum }
        casu "proba" { redde verum }
        casu "praepara" { redde verum }
        casu "postpara" { redde verum }

        ceterum { redde falsum }
    }
}

# Check if a word starts a genus member (for genus body error recovery)
#
# WHY: When parsing a genus body fails, we need to skip to the next
#      field or method declaration. This defines those boundaries.
@ publica
functio estVerbumGeneris(textus v) -> bivalens {
    elige v {
        # Method declaration
        casu "functio" { redde verum }

        # Visibility modifiers (precede fields/methods)
        casu "privatus" { redde verum }
        casu "protectus" { redde verum }

        # Static modifier
        casu "generis" { redde verum }

        # Abstract modifier
        casu "abstractus" { redde verum }

        ceterum { redde falsum }
    }
}
