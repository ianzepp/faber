# Errores - Semantic Error Catalog
#
# Defines all error codes and messages for semantic analysis.

# ============================================================================
# ERROR CODES
# ============================================================================

# Semantic error codes (S-prefix identifies semantic phase)
@ publica
ordo SemanticErrorCodice {
    UndefinedVariable       # S001: Undefined variable
    AlreadyDefined          # S002: Already defined in scope
    ImmutableAssignment     # S003: Cannot assign to immutable
    TypeMismatch            # S004: Type mismatch
    ReturnTypeMismatch      # S005: Return type mismatch
    NoTypeOrInitializer     # S006: Variable needs type or initializer
    NotExportedFromModule   # S007: Name not exported from module
    IncompatibleComparison  # S008: Cannot compare these types
    CedeOutsideAsync        # S009: cede requires async/generator
    AwaitOutsideAsync       # S010: await requires async
    DefaultWithBorrowedParam # S011: Cannot use default with borrowed param
    ModuleNotFound          # S012: Cannot find module
    CircularImport          # S013: Circular import detected
    ModuleParseError        # S014: Failed to parse module
    MissingFunctionBody     # S016: Function has no body (not @ externa)
    DuplicateModifier       # S018: Duplicate modifier
    InvalidModifierContext  # S019: Modifier not allowed in context
    NihilEqualityWarning    # S022: Use nihil/nonnihil unary operators
    EmptyCaseBlock          # S023: Empty block in casu/ceterum
}

# ============================================================================
# ERROR MESSAGE STRUCTURE
# ============================================================================

# Error message with text and help
@ publica
genus SemanticErrorNuntius {
    textus textus               # user-facing error message
    textus auxilium             # helpful guidance
}

# ============================================================================
# ERROR MESSAGE FUNCTIONS
# ============================================================================

# Undefined variable error
@ publica
functio undefinedVariableError(de textus nomen) -> SemanticErrorNuntius {
    redde {
        textus: scriptum("Undefined variable '§'", nomen),
        auxilium: "Variables must be declared with 'varia' or 'fixum' before use"
    } novum SemanticErrorNuntius
}

# Already defined error
@ publica
functio alreadyDefinedError(de textus nomen, numerus linea) -> SemanticErrorNuntius {
    redde {
        textus: scriptum("'§' is already defined at line §", nomen, linea),
        auxilium: "Each name can only be defined once in the same scope. Use a different name or assign to the existing variable."
    } novum SemanticErrorNuntius
}

# Immutable assignment error
@ publica
functio immutableAssignmentError(de textus nomen) -> SemanticErrorNuntius {
    redde {
        textus: scriptum("Cannot assign to immutable variable '§'", nomen),
        auxilium: "Variables declared with 'fixum' cannot be reassigned. Use 'varia' for mutable variables."
    } novum SemanticErrorNuntius
}

# Type mismatch error
@ publica
functio typeMismatchError(de textus sourceType, de textus targetType) -> SemanticErrorNuntius {
    redde {
        textus: scriptum("Type '§' is not assignable to type '§'", sourceType, targetType),
        auxilium: "Ensure the types are compatible. You may need a type conversion or to change the variable type."
    } novum SemanticErrorNuntius
}

# Return type mismatch error
@ publica
functio returnTypeMismatchError(de textus returnType, de textus functionType) -> SemanticErrorNuntius {
    redde {
        textus: scriptum("Return type '§' is not assignable to function return type '§'", returnType, functionType),
        auxilium: "The returned value must match the function return type annotation."
    } novum SemanticErrorNuntius
}

# No type or initializer error
@ publica
functio noTypeOrInitializerError(de textus nomen) -> SemanticErrorNuntius {
    redde {
        textus: scriptum("Variable '§' has no type annotation or initializer", nomen),
        auxilium: "Variables must have either a type annotation (e.g., 'numerus x') or an initializer (e.g., 'varia x = 5')."
    } novum SemanticErrorNuntius
}

# Not exported from module error
@ publica
functio notExportedFromModuleError(de textus nomen, de textus modulus) -> SemanticErrorNuntius {
    redde {
        textus: scriptum("'§' is not exported from '§'", nomen, modulus),
        auxilium: "Check the module documentation for available exports. You may have a typo in the import name."
    } novum SemanticErrorNuntius
}

# Incompatible comparison error
@ publica
functio incompatibleComparisonError(de textus leftType, de textus rightType, de textus operator) -> SemanticErrorNuntius {
    redde {
        textus: scriptum("Cannot compare '§' with '§' using '§'", leftType, rightType, operator),
        auxilium: "Comparison operators require operands of the same type. Both sides must be numbers or both must be strings."
    } novum SemanticErrorNuntius
}

# Cede outside async error
@ publica
functio cedeOutsideAsyncError() -> SemanticErrorNuntius {
    redde {
        textus: "'cede' requires an async or generator function context",
        auxilium: "Use 'fiet' for async functions, 'fiunt' for generators, or 'fient' for async generators."
    } novum SemanticErrorNuntius
}

# Await outside async error
@ publica
functio awaitOutsideAsyncError(de textus keyword) -> SemanticErrorNuntius {
    redde {
        textus: scriptum("'§' requires an async function context", keyword),
        auxilium: "Use 'fiet' or 'fient' to declare an async function."
    } novum SemanticErrorNuntius
}

# Default with borrowed param error
@ publica
functio defaultWithBorrowedParamError(de textus preposition) -> SemanticErrorNuntius {
    redde {
        textus: scriptum("Cannot use default value with '§' (borrowed) parameter", preposition),
        auxilium: "Default values require owned parameters. Remove the 'de' or 'in' preposition, or remove the default value."
    } novum SemanticErrorNuntius
}

# Module not found error
@ publica
functio moduleNotFoundError(de textus path) -> SemanticErrorNuntius {
    redde {
        textus: scriptum("Cannot find module '§'", path),
        auxilium: "Verify the file path is correct and the file exists. Relative paths are resolved from the importing file."
    } novum SemanticErrorNuntius
}

# Circular import error
@ publica
functio circularImportError(de textus path, de textus cycle) -> SemanticErrorNuntius {
    redde {
        textus: scriptum("Circular import detected: §", cycle),
        auxilium: "Break the cycle by restructuring your modules or using forward declarations for types."
    } novum SemanticErrorNuntius
}

# Module parse error
@ publica
functio moduleParseError(de textus path) -> SemanticErrorNuntius {
    redde {
        textus: scriptum("Failed to parse module '§'", path),
        auxilium: "Fix the syntax errors in the imported module before importing it."
    } novum SemanticErrorNuntius
}

# Missing function body error
@ publica
functio missingFunctionBodyError(de textus nomen) -> SemanticErrorNuntius {
    redde {
        textus: scriptum("Function '§' has no body", nomen),
        auxilium: "Regular functions require a body. Use '@ externa' annotation for external declarations."
    } novum SemanticErrorNuntius
}

# Duplicate modifier error
@ publica
functio duplicateModifierError(de textus nomen) -> SemanticErrorNuntius {
    redde {
        textus: scriptum("Duplicate modifier '§'", nomen),
        auxilium: "Each modifier can appear at most once in a function signature."
    } novum SemanticErrorNuntius
}

# Invalid modifier context error
@ publica
functio invalidModifierContextError(de textus nomen, de textus contextus) -> SemanticErrorNuntius {
    redde {
        textus: scriptum("Modifier '§' is only allowed on §", nomen, contextus),
        auxilium: "Remove the modifier or move it to a valid context."
    } novum SemanticErrorNuntius
}

# Morphologia stem not declared error
@ publica
functio morphologiaRadixNonDeclarataError(de textus methodus, de textus radix, de textus forma, de textus recipiens, de lista<textus> formae) -> SemanticErrorNuntius {
    fixum aux = (formae.longitudo() == 0) sic "Allowed forms for this stem: (none)" secus scriptum("Allowed forms for this stem: §", formae.coniunge(", "))
    redde {
        textus: scriptum("Morphologia stem '§' is not declared for '§' (method '§', forma '§'). §", radix, recipiens, methodus, forma, aux),
        auxilium: aux
    } novum SemanticErrorNuntius
}

# Morphologia form not permitted error
@ publica
functio morphologiaFormaNonPermissaError(de textus methodus, de textus radix, de textus forma, de textus recipiens, de lista<textus> formae) -> SemanticErrorNuntius {
    fixum aux = scriptum("Allowed forms for this stem: §", formae.coniunge(", "))
    redde {
        textus: scriptum("Morphologia forma '§' is not allowed for stem '§' on '§' (method '§'). §", forma, radix, recipiens, methodus, aux),
        auxilium: aux
    } novum SemanticErrorNuntius
}

# Nihil equality comparison warning
@ publica
functio nihilEqualityWarning(de textus signum) -> SemanticErrorNuntius {
    redde {
        textus: scriptum("Use 'nihil' or 'nonnihil' unary operators instead of '§ nihil'", signum),
        auxilium: "For null checks, prefer 'nihil x' (is null) or 'nonnihil x' (is not null) over '== nihil' or '!= nihil'."
    } novum SemanticErrorNuntius
}

# Empty case block error
@ publica
functio emptyCaseBlockError() -> SemanticErrorNuntius {
    redde {
        textus: "Empty block in casu/ceterum",
        auxilium: "Use 'tacet' for intentional no-op cases instead of empty braces."
    } novum SemanticErrorNuntius
}
