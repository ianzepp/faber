# Modulus - Module Resolution
#
# Handles resolution of local .fab file imports during semantic analysis.
# Uses norma:solum for file I/O operations.

§ ex "norma:solum" importa solum

§ ex "./typi" importa SemanticTypus, IGNOTUM, VACUUM, functioTypus, usitatumTypus, pactumTypus
§ ex "./typi" importa genusTypus, genericumTypus, primitivumTypus
§ ex "./scopus" importa SymbolumSpecies
§ ex "./nucleus" importa DiscretioDeclInfo, DiscretioVariansInfo
§ ex "./dependentia" importa Dependentia
§ ex "../ast/positio" importa Locus
§ ex "../ast/radix" importa Programma
§ ex "../ast/sententia" importa Sententia
§ ex "../ast/typus" importa TypusAnnotatio, TypusParametrum
§ ex "../lexor/index" importa lexare
§ ex "../parser/index" importa resolvere

# ============================================================================
# TYPES
# ============================================================================

# Export information extracted from a module
@ publica
genus ModulusExportum {
    textus nomen                    # exported name
    SymbolumSpecies species         # symbol kind (Functio, Genus, etc.)
    SemanticTypus typus             # type (IGNOTUM for most)
    Locus locus                     # source location
}

# Resolved module with its exports
@ publica
genus ModulusResolutum {
    tabula<textus, ModulusExportum> exporta    # map of name -> export info
    tabula<textus, DiscretioDeclInfo> discretiones # map of name -> discretio info
    textus via                                  # absolute file path
    si Programma programma                        # parsed AST (for future multi-file codegen)
}

# ============================================================================
# PATH HELPERS
# ============================================================================

# Check if import source is a local file (starts with ./ or ../)
@ publica
functio estLocaleImportum(de textus fons) -> bivalens {
    redde fons.startsWith("./") aut fons.startsWith("../")
}

# Check if import source is norma stdlib
@ publica
functio estNormaImportum(de textus fons) -> bivalens {
    redde fons == "norma" aut fons.startsWith("norma/")
}

# Check if import source is a dependentia alias import (alias:subpath)
@ publica
functio estDependentiaImportum(de textus fons) -> bivalens {
    # Has colon and doesn't start with ./ or ../
    si fons.continet(":") {
        redde non estLocaleImportum(fons)
    }
    redde falsum
}

# Resolve a dependentia import path using the registry
# Returns the constructed relative path (dep.via + subpath), or nihil if alias not found
# Does NOT resolve to absolute path - caller should use resolveModulum for that
@ publica
functio resolveDependentiaPath(
    de textus fons,
    de tabula<textus, Dependentia> registry
) -> si textus {
    # Split on colon: "alias:subpath" -> ["alias", "subpath"]
    fixum partes = fons.divide(":") qua lista<textus>
    si partes.longitudo() != 2 { redde nihil }

    fixum alias = partes[0]
    fixum subpath = partes[1]

    fixum dep = registry[alias]
    si nihil dep { redde nihil }

    # For now, only support local via paths
    si nihil dep.via { redde nihil }

    # Construct full path: dep.via + "/" + subpath
    redde dep.via + "/" + subpath
}

# Resolve import path to absolute filesystem path
# Adds .fab extension if not present, resolves relative to base path
@ publica
functio resolveViaModuli(de textus fons, de textus viaBasica) -> si textus {
    fixum baseDir = solum.directorium(viaBasica)

    # Add .fab extension if not present
    varia targetPath = fons
    si non fons.finis(".fab") {
        targetPath = fons + ".fab"
    }

    # Resolve to absolute path
    fixum absolutePath = solum.iunge([baseDir, targetPath])

    # Check if file exists
    si non solum.exstat(absolutePath) {
        redde nihil
    }

    redde absolutePath
}

# ============================================================================
# SHALLOW TYPE RESOLUTION
# ============================================================================

# Known generic collection types
fixum GENERICI = ["lista", "tabula", "copia"]

# Known primitive types
fixum PRIMITIVI = ["textus", "numerus", "fractus", "decimus", "magnus", "bivalens", "nihil", "vacuum", "octeti"]

# Resolve a type annotation to SemanticTypus without full semantic analysis.
# WHY: During export extraction we don't have a Resolvitor, but we need to
# build Genus types with proper field types so cross-module member access works.
functio resolveTypusShallow(de TypusAnnotatio annotatio) -> SemanticTypus {
    # Generic types: lista<T>, tabula<K,V>, etc.
    varia resolvedParametri = [] innatum lista<SemanticTypus>
    si nonnihil annotatio.typusParametra {
        ex (annotatio.typusParametra qua lista<TypusParametrum>) fixum p {
            discerne p {
                casu Typus ut tp {
                    resolvedParametri.appende(resolveTypusShallow(tp.adnotatio))
                }
                casu _ {
                    resolvedParametri.appende(IGNOTUM)
                }
            }
        }
    }

    si annotatio.nomen inter GENERICI {
        redde genericumTypus(annotatio.nomen, resolvedParametri, annotatio.nullabilis)
    }

    # Primitive types
    si annotatio.nomen inter PRIMITIVI {
        redde primitivumTypus(annotatio.nomen, annotatio.nullabilis)
    }

    # User-defined types - return Usitatum (type reference)
    redde usitatumTypus(annotatio.nomen, annotatio.nullabilis)
}

# ============================================================================
# EXPORT EXTRACTION
# ============================================================================

# Extract exports from a parsed program
# All top-level declarations become exports
@ publica
functio extraheExporta(de Programma programma, de textus via) -> ModulusResolutum {
    varia exporta = {} innatum tabula<textus, ModulusExportum>
    varia discretiones = {} innatum tabula<textus, DiscretioDeclInfo>

    ex programma.corpus fixum stmt {
        discerne stmt {
            casu FunctioDeclaratio ut f {
                # WHY: Resolve return type so callers can infer variable types
                # from function calls for proper norma translation.
                varia reditusTypus = VACUUM qua SemanticTypus
                si nonnihil f.typusReditus {
                    reditusTypus = resolveTypusShallow(f.typusReditus novum TypusAnnotatio)
                }

                exporta[f.nomen] = {
                    nomen: f.nomen,
                    species: SymbolumSpecies.Functio,
                    typus: functioTypus([], reditusTypus, f.asynca, falsum),
                    locus: f.locus
                } novum ModulusExportum
            }
            casu GenusDeclaratio ut g {
                # WHY: Build proper Genus type with field types so cross-module
                # member access can resolve field types for norma translation.
                varia agri = {} innatum tabula<textus, SemanticTypus>
                ex g.campi fixum campo {
                    si nonnihil campo.typus {
                        agri[campo.nomen] = resolveTypusShallow(campo.typus novum TypusAnnotatio)
                    } secus {
                        agri[campo.nomen] = IGNOTUM
                    }
                }

                # Empty maps for methods (not needed for field type resolution)
                varia methodi = {} innatum tabula<textus, SemanticTypus>
                varia agriStatici = {} innatum tabula<textus, SemanticTypus>
                varia methodiStatici = {} innatum tabula<textus, SemanticTypus>

                exporta[g.nomen] = {
                    nomen: g.nomen,
                    species: SymbolumSpecies.Genus,
                    typus: genusTypus(g.nomen, agri, methodi, agriStatici, methodiStatici, falsum),
                    locus: g.locus
                } novum ModulusExportum
            }
            casu PactumDeclaratio ut p {
                # WHY: Preserve method return types so callers can infer types from calls
                # (needed for norma translation when compiling in dependency order).
                varia methodi = {} innatum tabula<textus, SemanticTypus>
                ex p.methodi fixum methodSignum {
                    varia paramTypi = [] innatum lista<SemanticTypus>
                    ex methodSignum.parametra fixum param {
                        si nonnihil param.typus {
                            paramTypi.appende(resolveTypusShallow(param.typus novum TypusAnnotatio))
                        } secus {
                            paramTypi.appende(IGNOTUM)
                        }
                    }

                    varia reditusTypus = VACUUM qua SemanticTypus
                    si nonnihil methodSignum.typusReditus {
                        reditusTypus = resolveTypusShallow(methodSignum.typusReditus novum TypusAnnotatio)
                    }

                    methodi[methodSignum.nomen] = functioTypus(paramTypi, reditusTypus, methodSignum.asynca, falsum)
                }

                exporta[p.nomen] = {
                    nomen: p.nomen,
                    species: SymbolumSpecies.Pactum,
                    typus: pactumTypus(p.nomen, methodi, falsum),
                    locus: p.locus
                } novum ModulusExportum
            }
            casu OrdoDeclaratio ut o {
                exporta[o.nomen] = {
                    nomen: o.nomen,
                    species: SymbolumSpecies.Ordo,
                    typus: usitatumTypus(o.nomen, falsum),
                    locus: o.locus
                } novum ModulusExportum
            }
            casu DiscretioDeclaratio ut d {
                exporta[d.nomen] = {
                    nomen: d.nomen,
                    species: SymbolumSpecies.TypusAlias,
                    typus: usitatumTypus(d.nomen, falsum),
                    locus: d.locus
                } novum ModulusExportum

                varia variantInfos = [] innatum lista<DiscretioVariansInfo>
                ex d.variantes fixum variante {
                    variantInfos.appende({
                        nomen: variante.nomen,
                        locus: variante.locus
                    } novum DiscretioVariansInfo)
                }
                discretiones[d.nomen] = {
                    nomen: d.nomen,
                    locus: d.locus,
                    variantes: variantInfos
                } novum DiscretioDeclInfo

                # WHY: Pattern matching (`discerne`) expects variant types to be resolvable as
                # `DiscretioNomen.VariansNomen`, even across module boundaries.
                ex d.variantes fixum variante {
                    varia campi = {} innatum tabula<textus, SemanticTypus>
                    ex variante.campi fixum campo {
                        campi[campo.nomen] = resolveTypusShallow(campo.typus)
                    }

                    fixum variantTypus = genusTypus(
                        variante.nomen,
                        campi,
                        {} innatum tabula<textus, SemanticTypus>,
                        {} innatum tabula<textus, SemanticTypus>,
                        {} innatum tabula<textus, SemanticTypus>,
                        falsum
                    )

                    # Export both the qualified and unqualified variant names.
                    # WHY: Target codegen emits variants as standalone types, and
                    #      user code (and internal AST) frequently imports variants
                    #      directly (e.g. `ex "./sententia" importa MassaSententia`).
                    fixum qualNomen = scriptum("§.§", d.nomen, variante.nomen)
                    exporta[qualNomen] = {
                        nomen: qualNomen,
                        species: SymbolumSpecies.Genus,
                        typus: variantTypus,
                        locus: variante.locus
                    } novum ModulusExportum

                    # Avoid clobbering a pre-existing export (would be an error in TS too).
                    # EDGE: `exporta` is a reserved verb; use an alias for nil-check.
                    fixum exportaTabula = exporta
                    si nihil exportaTabula[variante.nomen] {
                        exporta[variante.nomen] = {
                            nomen: variante.nomen,
                            species: SymbolumSpecies.Genus,
                            typus: variantTypus,
                            locus: variante.locus
                        } novum ModulusExportum
                    }
                }
            }
            casu TypusAliasDeclaratio ut t {
                exporta[t.nomen] = {
                    nomen: t.nomen,
                    species: SymbolumSpecies.TypusAlias,
                    typus: usitatumTypus(t.nomen, falsum),
                    locus: t.locus
                } novum ModulusExportum
            }
            casu VariaSententia ut v {
                # VariaSententia.nomen is a string (destructuring has separate types)
                exporta[v.nomen] = {
                    nomen: v.nomen,
                    species: SymbolumSpecies.Variabilis,
                    typus: IGNOTUM,
                    locus: v.locus
                } novum ModulusExportum
            }
            casu _ tacet
        }
    }

    redde {
        exporta: exporta,
        discretiones: discretiones,
        via: via,
        programma: programma
    } novum ModulusResolutum
}

# ============================================================================
# MODULE RESOLUTION
# ============================================================================

# Main entry point: resolve and load a local module
# Handles path resolution, caching, cycle detection, parsing, and export extraction
@ publica
functio resolveModulum(
    de textus fons,
    de textus viaBasica,
    in tabula<textus, ModulusResolutum> cache,
    in copia<textus> inProgressu
) -> si ModulusResolutum {
    # Resolve to absolute path
    fixum absolutePath = resolveViaModuli(fons, viaBasica)
    si nihil absolutePath {
        redde nihil
    }

    # Check cache first
    si nonnihil cache[absolutePath] {
        redde cache[absolutePath]
    }

    # Check for cycles - return empty exports while cycle in progress
    # WHY: Circular imports are valid in JS/TS. We detect but don't error.
    # Values resolve when module finishes loading (JS module runtime model).
    si inProgressu.habet(absolutePath) {
        redde {
            exporta: {} innatum tabula<textus, ModulusExportum>,
            discretiones: {} innatum tabula<textus, DiscretioDeclInfo>,
            via: absolutePath,
            programma: nihil
        } novum ModulusResolutum
    }

    # Mark as in-progress
    inProgressu.adde(absolutePath)

    # Read the source file (sync to avoid async cascade)
    varia sourceCode = ""
    tempta {
        sourceCode = solum.lege(absolutePath)
    } cape e {
        inProgressu.dele(absolutePath)
        redde nihil
    }

    # Tokenize
    fixum lexResult = lexare(sourceCode)
    si lexResult.errores.longitudo() > 0 {
        inProgressu.dele(absolutePath)
        redde nihil
    }

    # Parse
    fixum parseResult = resolvere(lexResult.symbola)
    si parseResult.errores.longitudo() > 0 {
        inProgressu.dele(absolutePath)
        redde nihil
    }

    si nihil parseResult.programma {
        inProgressu.dele(absolutePath)
        redde nihil
    }

    # Extract exports
    fixum moduleExports = extraheExporta(parseResult.programma, absolutePath)

    # Cache the result
    cache[absolutePath] = moduleExports

    # Remove from in-progress
    inProgressu.dele(absolutePath)

    redde moduleExports
}
