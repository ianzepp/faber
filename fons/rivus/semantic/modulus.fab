# Modulus - Module Resolution for Local File Imports
#
# Handles resolution of local .fab file imports during semantic analysis.
# Provides path resolution, file loading, export extraction, and caching.
#
# Resolution rules:
# - Paths starting with "./" or "../" are local file imports
# - ".fab" extension is implicit and added automatically
# - "norma" and "norma/*" are handled as compiler intrinsics (not files)
# - Other paths pass through to target language (external packages)

ex "./typi" importa SemanticTypus, IGNOTUM, VACUUM, functioTypus, usitatumTypus, pactumTypus
ex "./typi" importa genusTypus, genericumTypus, primitivumTypus
ex "./scopus" importa SymbolumSpecies
ex "./nucleus" importa DiscretioDeclInfo, DiscretioVariansInfo
ex "../ast/positio" importa Locus
ex "../ast/radix" importa Programma
ex "../ast/sententia" importa Sententia
ex "../ast/typus" importa TypusAnnotatio, TypusParametrum
ex "../lexor/index" importa lexare, LexorResultatum
ex "../parser/index" importa resolvere, ParserResultatum

# ============================================================================
# FILE I/O DECLARATIONS (extern - implementations injected post-build)
# ============================================================================

@ externa
functio _readFileSync(textus via) -> textus

@ externa
functio _existsSync(textus via) -> bivalens

@ externa
functio _dirname(textus via) -> textus

@ externa
functio _resolve(textus basis, textus relativum) -> textus

# ============================================================================
# TYPES
# ============================================================================

# Export information extracted from a module
@ publicum
genus ModulusExportum {
    textus nomen                    # exported name
    SymbolumSpecies species         # symbol kind (Functio, Genus, etc.)
    SemanticTypus typus             # type (IGNOTUM for most)
    Locus locus                     # source location
}

# Resolved module with its exports
@ publicum
genus ModulusResolutum {
    tabula<textus, ModulusExportum> exporta    # map of name -> export info
    tabula<textus, DiscretioDeclInfo> discretiones # map of name -> discretio info
    textus via                                  # absolute file path
    Programma? programma                        # parsed AST (for future multi-file codegen)
}

# ============================================================================
# PATH HELPERS
# ============================================================================

# Check if import source is a local file (starts with ./ or ../)
@ publica
functio estLocaleImportum(textus fons) -> bivalens {
    redde fons.startsWith("./") aut fons.startsWith("../")
}

# Check if import source is norma stdlib
@ publica
functio estNormaImportum(textus fons) -> bivalens {
    redde fons == "norma" aut fons.startsWith("norma/")
}

# Resolve import path to absolute filesystem path
# Returns nihil if file doesn't exist
@ publica
functio resolveViaModuli(textus fons, textus viaBasica) -> textus? {
    # Get directory of importing file
    fixum directorium = _dirname(viaBasica)

    # Add .fab extension if missing
    varia via = fons
    si non via.endsWith(".fab") {
        via = via + ".fab"
    }

    # Resolve to absolute path
    fixum viaAbsoluta = _resolve(directorium, via)

    # Check existence
    si non _existsSync(viaAbsoluta) {
        redde nihil
    }

    redde viaAbsoluta
}

# ============================================================================
# SHALLOW TYPE RESOLUTION
# ============================================================================

# Known generic collection types
fixum GENERICI = ["lista", "tabula", "copia"]

# Known primitive types
fixum PRIMITIVI = ["textus", "numerus", "fractus", "decimus", "magnus", "bivalens", "nihil", "vacuum", "octeti"]

# Resolve a type annotation to SemanticTypus without full semantic analysis.
# WHY: During export extraction we don't have a Resolvitor, but we need to
# build Genus types with proper field types so cross-module member access works.
functio resolveTypusShallow(TypusAnnotatio annotatio) -> SemanticTypus {
    # Generic types: lista<T>, tabula<K,V>, etc.
    varia resolvedParametri = [] innatum lista<SemanticTypus>
    si nonnihil annotatio.typusParametra {
        ex (annotatio.typusParametra qua lista<TypusParametrum>) pro p {
            discerne p {
                casu Typus ut tp {
                    resolvedParametri.adde(resolveTypusShallow(tp.adnotatio))
                }
                casu _ {
                    resolvedParametri.adde(IGNOTUM)
                }
            }
        }
    }

    si annotatio.nomen inter GENERICI {
        redde genericumTypus(annotatio.nomen, resolvedParametri, annotatio.nullabilis)
    }

    # Primitive types
    si annotatio.nomen inter PRIMITIVI {
        redde primitivumTypus(annotatio.nomen, annotatio.nullabilis)
    }

    # User-defined types - return Usitatum (type reference)
    redde usitatumTypus(annotatio.nomen, annotatio.nullabilis)
}

# ============================================================================
# EXPORT EXTRACTION
# ============================================================================

# Extract exports from a parsed program
# All top-level declarations become exports
@ publica
functio extraheExporta(Programma programma, textus via) -> ModulusResolutum {
    varia exporta = {} innatum tabula<textus, ModulusExportum>
    varia discretiones = {} innatum tabula<textus, DiscretioDeclInfo>

    ex programma.corpus pro stmt {
        discerne stmt {
            casu FunctioDeclaratio ut f {
                # WHY: Resolve return type so callers can infer variable types
                # from function calls for proper norma translation.
                varia reditusTypus = VACUUM qua SemanticTypus
                si nonnihil f.typusReditus {
                    reditusTypus = resolveTypusShallow(f.typusReditus qua TypusAnnotatio)
                }

                exporta[f.nomen] = {
                    nomen: f.nomen,
                    species: SymbolumSpecies.Functio,
                    typus: functioTypus([], reditusTypus, f.asynca, falsum),
                    locus: f.locus
                } qua ModulusExportum
            }
            casu GenusDeclaratio ut g {
                # WHY: Build proper Genus type with field types so cross-module
                # member access can resolve field types for norma translation.
                varia agri = {} innatum tabula<textus, SemanticTypus>
                ex g.campi pro campo {
                    si nonnihil campo.typus {
                        agri[campo.nomen] = resolveTypusShallow(campo.typus qua TypusAnnotatio)
                    } secus {
                        agri[campo.nomen] = IGNOTUM
                    }
                }

                # Empty maps for methods (not needed for field type resolution)
                varia methodi = {} innatum tabula<textus, SemanticTypus>
                varia agriStatici = {} innatum tabula<textus, SemanticTypus>
                varia methodiStatici = {} innatum tabula<textus, SemanticTypus>

                exporta[g.nomen] = {
                    nomen: g.nomen,
                    species: SymbolumSpecies.Genus,
                    typus: genusTypus(g.nomen, agri, methodi, agriStatici, methodiStatici, falsum),
                    locus: g.locus
                } qua ModulusExportum
            }
            casu PactumDeclaratio ut p {
                # WHY: Preserve method return types so callers can infer types from calls
                # (needed for norma translation when compiling in dependency order).
                varia methodi = {} innatum tabula<textus, SemanticTypus>
                ex p.methodi pro methodSignum {
                    varia paramTypi = [] innatum lista<SemanticTypus>
                    ex methodSignum.parametra pro param {
                        si nonnihil param.typus {
                            paramTypi.adde(resolveTypusShallow(param.typus qua TypusAnnotatio))
                        } secus {
                            paramTypi.adde(IGNOTUM)
                        }
                    }

                    varia reditusTypus = VACUUM qua SemanticTypus
                    si nonnihil methodSignum.typusReditus {
                        reditusTypus = resolveTypusShallow(methodSignum.typusReditus qua TypusAnnotatio)
                    }

                    methodi[methodSignum.nomen] = functioTypus(paramTypi, reditusTypus, methodSignum.asynca, falsum)
                }

                exporta[p.nomen] = {
                    nomen: p.nomen,
                    species: SymbolumSpecies.Pactum,
                    typus: pactumTypus(p.nomen, methodi, falsum),
                    locus: p.locus
                } qua ModulusExportum
            }
            casu OrdoDeclaratio ut o {
                exporta[o.nomen] = {
                    nomen: o.nomen,
                    species: SymbolumSpecies.Ordo,
                    typus: usitatumTypus(o.nomen, falsum),
                    locus: o.locus
                } qua ModulusExportum
            }
            casu DiscretioDeclaratio ut d {
                exporta[d.nomen] = {
                    nomen: d.nomen,
                    species: SymbolumSpecies.TypusAlias,
                    typus: usitatumTypus(d.nomen, falsum),
                    locus: d.locus
                } qua ModulusExportum

                varia variantInfos = [] innatum lista<DiscretioVariansInfo>
                ex d.variantes pro variante {
                    variantInfos.adde({
                        nomen: variante.nomen,
                        locus: variante.locus
                    } qua DiscretioVariansInfo)
                }
                discretiones[d.nomen] = {
                    nomen: d.nomen,
                    locus: d.locus,
                    variantes: variantInfos
                } qua DiscretioDeclInfo

                # WHY: Pattern matching (`discerne`) expects variant types to be resolvable as
                # `DiscretioNomen.VariansNomen`, even across module boundaries.
                ex d.variantes pro variante {
                    varia campi = {} innatum tabula<textus, SemanticTypus>
                    ex variante.campi pro campo {
                        campi[campo.nomen] = resolveTypusShallow(campo.typus)
                    }

                    fixum variantTypus = genusTypus(
                        variante.nomen,
                        campi,
                        {} innatum tabula<textus, SemanticTypus>,
                        {} innatum tabula<textus, SemanticTypus>,
                        {} innatum tabula<textus, SemanticTypus>,
                        falsum
                    )

                    # Export both the qualified and unqualified variant names.
                    # WHY: Target codegen emits variants as standalone types, and
                    #      user code (and internal AST) frequently imports variants
                    #      directly (e.g. `ex "./sententia" importa MassaSententia`).
                    fixum qualNomen = scriptum("ยง.ยง", d.nomen, variante.nomen)
                    exporta[qualNomen] = {
                        nomen: qualNomen,
                        species: SymbolumSpecies.Genus,
                        typus: variantTypus,
                        locus: variante.locus
                    } qua ModulusExportum

                    # Avoid clobbering a pre-existing export (would be an error in TS too).
                    # EDGE: `exporta` is a reserved verb; use an alias for nil-check.
                    fixum exportaTabula = exporta
                    si nihil exportaTabula[variante.nomen] {
                        exporta[variante.nomen] = {
                            nomen: variante.nomen,
                            species: SymbolumSpecies.Genus,
                            typus: variantTypus,
                            locus: variante.locus
                        } qua ModulusExportum
                    }
                }
            }
            casu TypusAliasDeclaratio ut t {
                exporta[t.nomen] = {
                    nomen: t.nomen,
                    species: SymbolumSpecies.TypusAlias,
                    typus: usitatumTypus(t.nomen, falsum),
                    locus: t.locus
                } qua ModulusExportum
            }
            casu VariaSententia ut v {
                # VariaSententia.nomen is a string (destructuring has separate types)
                exporta[v.nomen] = {
                    nomen: v.nomen,
                    species: SymbolumSpecies.Variabilis,
                    typus: IGNOTUM,
                    locus: v.locus
                } qua ModulusExportum
            }
            casu _ { }
        }
    }

    redde {
        exporta: exporta,
        discretiones: discretiones,
        via: via,
        programma: programma
    } qua ModulusResolutum
}

# ============================================================================
# MODULE RESOLUTION
# ============================================================================

# Main entry point: resolve and load a local module
# Returns nihil on error (file not found, parse error, etc.)
#
# Parameters:
#   fons - import source string (e.g., "./utils")
#   viaBasica - absolute path of the importing file
#   cache - module cache (path -> resolved module)
#   inProgressu - set of paths currently being resolved (for cycle detection)
#
@ publica
functio resolveModulum(
    textus fons,
    textus viaBasica,
    tabula<textus, ModulusResolutum> cache,
    copia<textus> inProgressu
) -> ModulusResolutum? {
    # Resolve to absolute path
    fixum viaAbsoluta = resolveViaModuli(fons, viaBasica)
    si nihil viaAbsoluta {
        redde nihil  # File not found
    }

    fixum via = viaAbsoluta qua textus

    # Check cache first
    si nonnihil cache[via] {
        redde cache[via]
    }

    # Check for cycles - return empty exports (JS/TS hoisting behavior)
    si inProgressu.has(via) {
        redde {
            exporta: {} innatum tabula<textus, ModulusExportum>,
            discretiones: {} innatum tabula<textus, DiscretioDeclInfo>,
            via: via,
            programma: nihil
        } qua ModulusResolutum
    }

    # Mark as in progress
    inProgressu.add(via)

    # Load and parse
    fixum sourceCode = _readFileSync(via)
    fixum lexResult = lexare(sourceCode)
    si lexResult.errores.longitudo() > 0 {
        inProgressu.delete(via)
        redde nihil  # Lexer error
    }

    fixum parseResult = resolvere(lexResult.symbola)
    si parseResult.errores.longitudo() > 0 aut nihil parseResult.programma {
        inProgressu.delete(via)
        redde nihil  # Parse error
    }

    # Extract exports
    fixum modulus = extraheExporta(parseResult.programma qua Programma, via)

    # Cache before recursing (handles diamond dependencies)
    cache[via] = modulus

    # Recursively resolve child imports (for cycle detection)
    ex (parseResult.programma qua Programma).corpus pro stmt {
        discerne stmt {
            casu ImportaSententia ut imp {
                si estLocaleImportum(imp.fons) {
                    resolveModulum(imp.fons, via, cache, inProgressu)
                }
            }
            casu _ { }
        }
    }

    # Remove from in progress
    inProgressu.delete(via)

    redde modulus
}
