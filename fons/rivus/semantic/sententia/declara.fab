# Declaration Statement Analysis
#
# Handles: varia/fixum, functio, genus, pactum, ordo, discretio, typus

§ ex "../resolvitor" importa Resolvitor
§ ex "../typi" importa SemanticTypus, VACUUM, IGNOTUM, NIHIL, NUMERUS
§ ex "../typi" importa primitivumTypus, genericumTypus, unioTypus, ignotumTypus
§ ex "../typi" importa functioTypus, usitatumTypus, genusTypus, pactumTypus, ordoTypus
§ ex "../typi" importa formaTypum, assignabileAd
§ ex "../scopus" importa Symbolum, SymbolumSpecies, ScopusSpecies, quaereSymbolumLocale
§ ex "../nucleus" importa estGenericusTypus, DiscretioDeclInfo, DiscretioVariansInfo
§ ex "../errores" importa noTypeOrInitializerError, typeMismatchError, awaitOutsideAsyncError, missingFunctionBodyError
§ ex "../errores" importa duplicateModifierError, invalidModifierContextError
§ ex "../../ast/sententia" importa Sententia, VariaGenus, FunctioModificator, FunctioDeclaratio
§ ex "../../ast/sententia" importa ImportaSpecificator, SeriesDestructuraElementum
§ ex "../../ast/typus" importa TypusAnnotatio, TypusParametrum

@ publica
functio resolveTypusAnnotatio(Resolvitor r, TypusAnnotatio annotatio) -> SemanticTypus {
    # WHY: Self-hosting needs full type annotation resolution for the compiler itself
    # (AST nodes, generics, and nullable types).

    # Function type: (T, U) -> V
    si annotatio.nomen == "" et nonnihil annotatio.parametra et nonnihil annotatio.reditus {
        varia paramTypi = [] innatum lista<SemanticTypus>
        ex (annotatio.parametra qua lista<TypusAnnotatio>) fixum param {
            paramTypi.adde(resolveTypusAnnotatio(r, param))
        }
        fixum reditusTypus = resolveTypusAnnotatio(r, annotatio.reditus novum TypusAnnotatio)
        redde functioTypus(paramTypi, reditusTypus, falsum, falsum)
    }

    # Union type: unio<A, B>
    si nonnihil annotatio.unio {
        varia typi = [] innatum lista<SemanticTypus>
        ex (annotatio.unio qua lista<TypusAnnotatio>) fixum t {
            typi.adde(resolveTypusAnnotatio(r, t))
        }
        si annotatio.nullabilis {
            typi.adde(NIHIL)
        }
        redde unioTypus(typi)
    }

    # Generic types: lista<T>, tabula<K,V>, etc.
    varia resolvedParametri = [] innatum lista<SemanticTypus>
    si nonnihil annotatio.typusParametra {
        ex (annotatio.typusParametra qua lista<TypusParametrum>) fixum p {
            discerne p {
                casu Typus ut tp {
                    resolvedParametri.adde(resolveTypusAnnotatio(r, tp.adnotatio))
                }
                casu Littera {
                    # EDGE: Numeric literal type params are not needed for self-host yet.
                    resolvedParametri.adde(IGNOTUM)
                }
            }
        }
    }

    si estGenericusTypus(annotatio.nomen) {
        redde genericumTypus(annotatio.nomen, resolvedParametri, annotatio.nullabilis)
    }

    # Handle ignotum specially - returns Ignotum variant, not a primitive
    si annotatio.nomen == "ignotum" {
        si annotatio.nullabilis {
            redde unioTypus([ignotumTypus(nihil), NIHIL])
        }
        redde ignotumTypus(nihil)
    }

    # Primitive types
    si annotatio.nomen inter ["textus", "numerus", "fractus", "decimus", "magnus", "bivalens", "nihil", "vacuum", "octeti", "numquam", "objectum"] {
        redde primitivumTypus(annotatio.nomen, annotatio.nullabilis)
    }

    # Check if this is a type alias - if so, return the underlying type (structural aliases)
    fixum symbolum = quaereSymbolumLocale(r.analyzator().scopus, annotatio.nomen)
    si nonnihil symbolum {
        fixum sym = symbolum novum Symbolum
        si sym.species == SymbolumSpecies.TypusAlias {
            # Return the underlying type, preserving nullability
            si annotatio.nullabilis {
                # Wrap in union with nihil for nullable
                redde unioTypus([sym.semanticTypus, NIHIL])
            }
            redde sym.semanticTypus
        }
    }

    # User-defined types (genus/pactum/etc.)
    redde usitatumTypus(annotatio.nomen, annotatio.nullabilis)
}

functio validateFunctioModificatores(Resolvitor r, lista<FunctioModificator>? modificatores, bivalens immutataPermissa) -> vacuum {
    si nihil modificatores {
        redde
    }

    fixum a = r.analyzator()
    varia visa = {} innatum tabula<textus, bivalens>

    ex (modificatores qua lista<FunctioModificator>) fixum m {
        discerne m {
            casu CurataModificator ut mod {
                si nonnihil visa["curata"] {
                    fixum err = duplicateModifierError("curata")
                    a.error(err.textus, mod.locus, err.auxilium)
                } secus {
                    visa["curata"] = verum
                }
            }
            casu ErrataModificator ut mod {
                si nonnihil visa["errata"] {
                    fixum err = duplicateModifierError("errata")
                    a.error(err.textus, mod.locus, err.auxilium)
                } secus {
                    visa["errata"] = verum
                }
            }
            casu ImmutataModificator ut mod {
                si nonnihil visa["immutata"] {
                    fixum err = duplicateModifierError("immutata")
                    a.error(err.textus, mod.locus, err.auxilium)
                } secus {
                    visa["immutata"] = verum
                }
                si non immutataPermissa {
                    fixum err = invalidModifierContextError("immutata", "genus methods")
                    a.error(err.textus, mod.locus, err.auxilium)
                }
            }
            casu IacitModificator ut mod {
                si nonnihil visa["iacit"] {
                    fixum err = duplicateModifierError("iacit")
                    a.error(err.textus, mod.locus, err.auxilium)
                } secus {
                    visa["iacit"] = verum
                }
            }
            casu _ { }
        }
    }
}

# =============================================================================
# VARIABLE DECLARATION
# =============================================================================

# Analyze varia/fixum declaration
@ publica
functio analyzeVariaDeclaratio(Resolvitor r, Sententia variaStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne variaStmt {
        casu VariaSententia ut v {
            # Determine type from annotation or initializer
            varia resolvedTypus = IGNOTUM qua SemanticTypus

            si nonnihil v.typus {
                resolvedTypus = resolveTypusAnnotatio(r, v.typus novum TypusAnnotatio)
            }
            sin nonnihil v.valor {
                resolvedTypus = r.expressia(v.valor)
            }
            secus {
                # External declarations require type annotation but no initializer
                # Non-externa without type or initializer is an error
                si non v.externa {
                    fixum err = noTypeOrInitializerError(v.nomen)
                    a.error(err.textus, v.locus, err.auxilium)
                }
            }

            # Check initializer type compatibility
            si nonnihil v.typus et nonnihil v.valor {
                fixum initTypus = r.expressia(v.valor)
                si non assignabileAd(initTypus, resolvedTypus) {
                    fixum err = typeMismatchError(formaTypum(initTypus), formaTypum(resolvedTypus))
                    a.error(err.textus, v.locus, err.auxilium)
                }
            }

            si (v.species == VariaGenus.Figendum aut v.species == VariaGenus.Variandum) et non a.currentFunctioAsync {
                fixum keyword = (v.species == VariaGenus.Figendum) sic "figendum" secus "variandum"
                fixum err = awaitOutsideAsyncError(keyword)
                a.error(err.textus, v.locus, err.auxilium)
            }

            # Define in symbol table
            fixum mutabilis = (v.species == VariaGenus.Varia aut v.species == VariaGenus.Variandum)
            a.definie({
                nomen: v.nomen,
                semanticTypus: resolvedTypus,
                species: SymbolumSpecies.Variabilis,
                mutabilis: mutabilis,
                locus: v.locus
            } novum Symbolum)
        }
        casu _ { }
    }
}

# Analyze object destructuring: ex obj fixum name, age ut alias
@ publica
functio analyzeDestructuraSententia(Resolvitor r, Sententia stmt) -> vacuum {
    fixum a = r.analyzator()

    discerne stmt {
        casu DestructuraSententia ut d {
            # Analyze the source expression to get its type
            fixum fonsTypus = r.expressia(d.fons)

            # Determine mutability from species (fixum vs varia)
            fixum mutabilis = d.species == VariaGenus.Varia aut d.species == VariaGenus.Variandum

            # Register each binding from the specificatores
            ex d.specificatores fixum spec {
                # The local name is what gets bound (aliased name or original)
                fixum bindingName = spec.locale

                a.definie({
                    nomen: bindingName,
                    semanticTypus: IGNOTUM,
                    species: SymbolumSpecies.Variabilis,
                    mutabilis: mutabilis,
                    locus: spec.locus
                } novum Symbolum)
            }
        }
        casu _ { }
    }
}

# Analyze array destructuring: fixum [a, b, c] = array
@ publica
functio analyzeSeriesDestructuraSententia(Resolvitor r, Sententia stmt) -> vacuum {
    fixum a = r.analyzator()

    discerne stmt {
        casu SeriesDestructuraSententia ut s {
            # Analyze the source expression to get its type
            fixum fonsTypus = r.expressia(s.fons)

            # Determine mutability from species (fixum vs varia)
            fixum mutabilis = s.species == VariaGenus.Varia aut s.species == VariaGenus.Variandum

            # Register each binding from the elementa
            ex s.elementa fixum elem {
                # Skip placeholders (_) and elements without names
                si elem.omissum aut nihil elem.nomen {
                    perge
                }

                fixum bindingName = elem.nomen qua textus

                a.definie({
                    nomen: bindingName,
                    semanticTypus: IGNOTUM,
                    species: SymbolumSpecies.Variabilis,
                    mutabilis: mutabilis,
                    locus: elem.locus
                } novum Symbolum)
            }
        }
        casu _ { }
    }
}

# =============================================================================
# FUNCTION DECLARATION
# =============================================================================

# Analyze functio declaration
@ publica
functio analyzeFunctioDeclaratio(Resolvitor r, Sententia functioStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne functioStmt {
        casu FunctioDeclaratio ut f {
            validateFunctioModificatores(r, f.modificatores, falsum)

            # Build parameter types
            varia paramTypi = [] innatum lista<SemanticTypus>
            ex f.parametra fixum param {
                si nonnihil param.typus {
                    paramTypi.adde(resolveTypusAnnotatio(r, param.typus novum TypusAnnotatio))
                } secus {
                    paramTypi.adde(IGNOTUM)
                }
            }

            # Resolve return type
            varia reditusTypus = VACUUM qua SemanticTypus
            si nonnihil f.typusReditus {
                reditusTypus = resolveTypusAnnotatio(r, f.typusReditus novum TypusAnnotatio)
            }

            # Build function type
            fixum fnTypus = functioTypus(paramTypi, reditusTypus, f.asynca, falsum)

            # Define in symbol table (predeclare creates placeholder)
            fixum existens = quaereSymbolumLocale(a.scopus, f.nomen)
            si nonnihil existens {
                a.scopus.symbola[f.nomen].semanticTypus = fnTypus
            } secus {
                a.definie({
                    nomen: f.nomen,
                    semanticTypus: fnTypus,
                    species: SymbolumSpecies.Functio,
                    mutabilis: falsum,
                    locus: f.locus
                } novum Symbolum)
            }

            # Check for missing body (functions must have body unless @ externa or abstract)
            si nihil f.corpus et non f.externa et non f.abstracta {
                fixum err = missingFunctionBodyError(f.nomen)
                a.error(err.textus, f.locus, err.auxilium)
            }

            # Analyze body in new scope
            si nonnihil f.corpus {
                # Save function context
                fixum prevReditus = a.currentFunctioReditus
                fixum prevAsync = a.currentFunctioAsync
                fixum prevGenerator = a.currentFunctioGenerator

                a.currentFunctioReditus = reditusTypus
                a.currentFunctioAsync = f.asynca
                a.currentFunctioGenerator = f.generator

                # Enter function scope
                a.intraScopum(ScopusSpecies.Functio)

                # Define parameters
                varia i = 0
                ex f.parametra fixum param {
                    a.scopus.symbola[param.nomen] = {
                        nomen: param.nomen,
                        semanticTypus: paramTypi[i],
                        species: SymbolumSpecies.Parametrum,
                        mutabilis: falsum,
                        locus: param.locus
                    }
                    # Also register alias if present (ut syntax)
                    si nonnihil param.alias {
                        fixum aliasNomen = param.alias qua textus
                        a.scopus.symbola[aliasNomen] = {
                            nomen: aliasNomen,
                            semanticTypus: paramTypi[i],
                            species: SymbolumSpecies.Parametrum,
                            mutabilis: falsum,
                            locus: param.locus
                        }
                    }
                    i += 1
                }

            # Analyze body
            r.sententia(f.corpus)


                # Exit scope and restore context
                a.exiScopum()
                a.currentFunctioReditus = prevReditus
                a.currentFunctioAsync = prevAsync
                a.currentFunctioGenerator = prevGenerator
            }
        }
        casu _ { }
    }
}

# =============================================================================
# TYPE DECLARATIONS
# =============================================================================

# Analyze genus declaration
@ publica
functio analyzeGenusDeclaratio(Resolvitor r, Sententia genusStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne genusStmt {
        casu GenusDeclaratio ut g {
            # Build field type maps
            varia agri = {} innatum tabula<textus, SemanticTypus>
            varia agriStatici = {} innatum tabula<textus, SemanticTypus>

            ex g.campi fixum campo {
                fixum campoTypus = resolveTypusAnnotatio(r, campo.typus)
                si campo.staticum {
                    agriStatici[campo.nomen] = campoTypus
                } secus {
                    agri[campo.nomen] = campoTypus
                }
            }

            # Build method type maps
            varia methodi = {} innatum tabula<textus, SemanticTypus>
            varia methodiStatici = {} innatum tabula<textus, SemanticTypus>

            ex g.methodi fixum m {
                validateFunctioModificatores(r, m.modificatores, verum)

                # Build parameter types
                varia paramTypi = [] innatum lista<SemanticTypus>
                ex m.parametra fixum param {
                    si nonnihil param.typus {
                        paramTypi.adde(resolveTypusAnnotatio(r, param.typus novum TypusAnnotatio))
                    } secus {
                        paramTypi.adde(IGNOTUM)
                    }
                }

                # Resolve return type
                varia reditusTypus = VACUUM qua SemanticTypus
                si nonnihil m.typusReditus {
                    reditusTypus = resolveTypusAnnotatio(r, m.typusReditus novum TypusAnnotatio)
                }

                # Build function type
                fixum fnTypus = functioTypus(paramTypi, reditusTypus, m.asynca, falsum)

                # WHY: FunctioDeclaratio doesn't have staticum field (AST limitation).
                # All methods are treated as instance methods for now.
                methodi[m.nomen] = fnTypus
            }

            # Create genus type with populated maps
            fixum genTypus = genusTypus(g.nomen, agri, methodi, agriStatici, methodiStatici, falsum)

            # Define in symbol table
            a.scopus.symbola[g.nomen] = {
                nomen: g.nomen,
                semanticTypus: genTypus,
                species: SymbolumSpecies.Genus,
                mutabilis: falsum,
                locus: g.locus
            }

            # Analyze method bodies with genus context
            fixum prevGenusNomen = a.currentGenusNomen
            a.currentGenusNomen = g.nomen

            ex g.methodi fixum m {
                analyzeMethodusCorpus(r, m, methodi)
            }

            a.currentGenusNomen = prevGenusNomen
        }
        casu _ { }
    }
}

functio analyzeMethodusCorpus(Resolvitor r, FunctioDeclaratio m, tabula<textus, SemanticTypus> methodi) -> vacuum {
    si nihil m.corpus { redde }

    fixum a = r.analyzator()

    # Resolve method return type from signature
    varia methodTypus = methodi[m.nomen] vel IGNOTUM
    varia reditusTypus = VACUUM qua SemanticTypus

    discerne methodTypus {
        casu Functio ut fn { reditusTypus = fn.reditusTypus }
        casu _ { }
    }

    # Save function context
    fixum prevReditus = a.currentFunctioReditus
    fixum prevAsync = a.currentFunctioAsync
    fixum prevGenerator = a.currentFunctioGenerator

    a.currentFunctioReditus = reditusTypus
    a.currentFunctioAsync = m.asynca
    a.currentFunctioGenerator = m.generator

    # Enter method scope and define parameters
    a.intraScopum(ScopusSpecies.Functio)

    ex m.parametra fixum param {
        a.scopus.symbola[param.nomen] = {
            nomen: param.nomen,
            semanticTypus: IGNOTUM,
            species: SymbolumSpecies.Parametrum,
            mutabilis: falsum,
            locus: param.locus
        }
        # Also register alias if present (ut syntax)
        si nonnihil param.alias {
            fixum aliasNomen = param.alias qua textus
            a.scopus.symbola[aliasNomen] = {
                nomen: aliasNomen,
                semanticTypus: IGNOTUM,
                species: SymbolumSpecies.Parametrum,
                mutabilis: falsum,
                locus: param.locus
            }
        }
    }

    r.sententia(m.corpus)

    # Restore context
    a.exiScopum()
    a.currentFunctioReditus = prevReditus
    a.currentFunctioAsync = prevAsync
    a.currentFunctioGenerator = prevGenerator
}

# Analyze pactum declaration
@ publica
functio analyzePactumDeclaratio(Resolvitor r, Sententia pactumStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne pactumStmt {
        casu PactumDeclaratio ut p {
            # Build method signature map
            varia methodi = {} innatum tabula<textus, SemanticTypus>

            ex p.methodi fixum methodSignum {
                validateFunctioModificatores(r, methodSignum.modificatores, falsum)

                # Build parameter types
                varia paramTypi = [] innatum lista<SemanticTypus>
                ex methodSignum.parametra fixum param {
                    si nonnihil param.typus {
                        paramTypi.adde(resolveTypusAnnotatio(r, param.typus novum TypusAnnotatio))
                    } secus {
                        paramTypi.adde(IGNOTUM)
                    }
                }

                # Resolve return type
                varia reditusTypus = VACUUM qua SemanticTypus
                si nonnihil methodSignum.typusReditus {
                    reditusTypus = resolveTypusAnnotatio(r, methodSignum.typusReditus novum TypusAnnotatio)
                }

                # Build function type
                fixum fnTypus = functioTypus(paramTypi, reditusTypus, methodSignum.asynca, falsum)
                methodi[methodSignum.nomen] = fnTypus
            }

            # Create pactum type with populated methods
            fixum pacTypus = pactumTypus(p.nomen, methodi, falsum)

            # Define in symbol table
            a.scopus.symbola[p.nomen] = {
                nomen: p.nomen,
                semanticTypus: pacTypus,
                species: SymbolumSpecies.Pactum,
                mutabilis: falsum,
                locus: p.locus
            }
        }
        casu _ { }
    }
}

# Analyze ordo declaration
@ publica
functio analyzeOrdoDeclaratio(Resolvitor r, Sententia ordoStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne ordoStmt {
        casu OrdoDeclaratio ut o {
            # Build member type map (all members are NUMERUS for standard enums)
            varia membra = {} innatum tabula<textus, SemanticTypus>
            ex o.membra fixum membrum {
                membra[membrum.nomen] = NUMERUS
            }

            # Create ordo type with populated members
            fixum ordTypus = ordoTypus(o.nomen, membra, falsum)

            # Define in symbol table
            a.scopus.symbola[o.nomen] = {
                nomen: o.nomen,
                semanticTypus: ordTypus,
                species: SymbolumSpecies.Ordo,
                mutabilis: falsum,
                locus: o.locus
            }
        }
        casu _ { }
    }
}

# Analyze discretio declaration
@ publica
functio analyzeDiscretioDeclaratio(Resolvitor r, Sententia discretioStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne discretioStmt {
        casu DiscretioDeclaratio ut d {
            # Create user type for the discretio union itself
            fixum discTypus = usitatumTypus(d.nomen, falsum)

            # Define the discretio in symbol table
            a.scopus.symbola[d.nomen] = {
                nomen: d.nomen,
                semanticTypus: discTypus,
                species: SymbolumSpecies.TypusAlias,
                mutabilis: falsum,
                locus: d.locus
            }

            # Record declaration metadata for exhaustiveness checks
            varia variantInfos = [] innatum lista<DiscretioVariansInfo>
            ex d.variantes fixum variante {
                variantInfos.adde({
                    nomen: variante.nomen,
                    locus: variante.locus
                } novum DiscretioVariansInfo)
            }
            a.discretioIndex[d.nomen] = {
                nomen: d.nomen,
                locus: d.locus,
                variantes: variantInfos
            } novum DiscretioDeclInfo

            # Analyze and register each variant
            # WHY: Each variant is registered as a nested type (Discretio.Variant) for pattern matching
            ex d.variantes fixum variante {
                # Build variant field map (empty for unit variants)
                varia campi = {} innatum tabula<textus, SemanticTypus>
                ex variante.campi fixum campo {
                    campi[campo.nomen] = resolveTypusAnnotatio(r, campo.typus)
                }

                # Create a genus-like type for the variant (with fields as instance fields)
                fixum variantTypus = genusTypus(
                    variante.nomen,
                    campi,
                    {} innatum tabula<textus, SemanticTypus>,
                    {} innatum tabula<textus, SemanticTypus>,
                    {} innatum tabula<textus, SemanticTypus>,
                    falsum
                )

                # Register variant as DiscretioNomen.VariantNomen
                fixum qualNomen = scriptum("§.§", d.nomen, variante.nomen)
                a.scopus.symbola[qualNomen] = {
                    nomen: qualNomen,
                    semanticTypus: variantTypus,
                    species: SymbolumSpecies.Genus,
                    mutabilis: falsum,
                    locus: variante.locus
                }
            }
        }
        casu _ { }
    }
}

# Analyze typus alias declaration
@ publica
functio analyzeTypusAlias(Resolvitor r, Sententia typusStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne typusStmt {
        casu TypusAliasDeclaratio ut t {
            # Resolve the type annotation to get the aliased type
            fixum aliasTypus = resolveTypusAnnotatio(r, t.typus)

            # Define in symbol table
            a.scopus.symbola[t.nomen] = {
                nomen: t.nomen,
                semanticTypus: aliasTypus,
                species: SymbolumSpecies.TypusAlias,
                mutabilis: falsum,
                locus: t.locus
            }
        }
        casu _ { }
    }
}
