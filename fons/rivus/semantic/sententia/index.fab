# Statement Analysis - Main Dispatcher
#
# Routes statement AST nodes to their appropriate analysis functions.

importa ex "../resolvitor" privata Resolvitor
importa ex "../../ast/sententia" privata Sententia

# Import analyzers - no circular dependency since they only use Resolvitor
importa ex "./declara" privata analyzeVariaDeclaratio
importa ex "./declara" privata analyzeFunctioDeclaratio
importa ex "./declara" privata analyzeDestructuraSententia
importa ex "./declara" privata analyzeSeriesDestructuraSententia
importa ex "./declara" privata analyzeGenusDeclaratio
importa ex "./declara" privata analyzePactumDeclaratio
importa ex "./declara" privata analyzeOrdoDeclaratio
importa ex "./declara" privata analyzeDiscretioDeclaratio
importa ex "./declara" privata analyzeTypusAlias
importa ex "./imperium" privata analyzeSi
importa ex "./imperium" privata analyzeDum
importa ex "./imperium" privata analyzeIteratio
importa ex "./imperium" privata analyzeElige
importa ex "./imperium" privata analyzeDiscerne
importa ex "./imperium" privata analyzeCustodi
importa ex "./actio" privata analyzeRedde
importa ex "./actio" privata analyzeIace
importa ex "./actio" privata analyzeScribe
importa ex "./actio" privata analyzeAdfirma
importa ex "./error" privata analyzeTempta
importa ex "./error" privata analyzeFac
importa ex "./error" privata analyzeCura

# =============================================================================
# MAIN DISPATCHER
# =============================================================================

# Analyze any statement
@ publica
functio analyzeSententia(Resolvitor r, Sententia stmt) -> vacuum {
    discerne stmt {
        # Declarations
        casu VariaSententia {
            analyzeVariaDeclaratio(r, stmt)
        }

        casu DestructuraSententia {
            analyzeDestructuraSententia(r, stmt)
        }

        casu SeriesDestructuraSententia {
            analyzeSeriesDestructuraSententia(r, stmt)
        }

        casu FunctioDeclaratio {
            analyzeFunctioDeclaratio(r, stmt)
        }

        casu GenusDeclaratio {
            analyzeGenusDeclaratio(r, stmt)
        }

        casu PactumDeclaratio {
            analyzePactumDeclaratio(r, stmt)
        }

        casu OrdoDeclaratio {
            analyzeOrdoDeclaratio(r, stmt)
        }

        casu DiscretioDeclaratio {
            analyzeDiscretioDeclaratio(r, stmt)
        }

        casu TypusAliasDeclaratio {
            analyzeTypusAlias(r, stmt)
        }

        # Control flow
        casu SiSententia {
            analyzeSi(r, stmt)
        }

        casu DumSententia {
            analyzeDum(r, stmt)
        }

        casu IteratioSententia {
            analyzeIteratio(r, stmt)
        }

        casu EligeSententia {
            analyzeElige(r, stmt)
        }

        casu DiscerneSententia {
            analyzeDiscerne(r, stmt)
        }

        casu CustodiSententia {
            analyzeCustodi(r, stmt)
        }

        # Action statements
        casu ReddeSententia {
            analyzeRedde(r, stmt)
        }

        casu IaceSententia {
            analyzeIace(r, stmt)
        }

        casu ScribeSententia {
            analyzeScribe(r, stmt)
        }

        casu AdfirmaSententia {
            analyzeAdfirma(r, stmt)
        }

        # Error handling
        casu TemptaSententia {
            analyzeTempta(r, stmt)
        }

        casu FacSententia {
            analyzeFac(r, stmt)
        }

        casu CuraSententia {
            analyzeCura(r, stmt)
        }

        # Block
        casu MassaSententia ut m {
            itera ex m.corpus fixum s {
                r.sententia(s)
            }
        }

        # Entry point (incipit form)
        casu IncipitSententia ut i {
            # WHY: Recursively analyze the incipiet body so method calls get
            # their morphologia resolved for norma translation.
            si nonnihil i.corpus {
                r.sententia(i.corpus)
            }
        }

        # Entry point (incipiet form)
        casu IncipietSententia ut i {
            # WHY: Recursively analyze the incipiet body so method calls get
            # their morphologia resolved for norma translation.
            si nonnihil i.corpus {
                # WHY: incipiet is async, so cede should be allowed in body
                fixum a = r.analyzator()
                fixum prevAsync = a.currentFunctioAsync
                fixum prevGenerator = a.currentFunctioGenerator

                a.currentFunctioAsync = verum
                a.currentFunctioGenerator = falsum

                r.sententia(i.corpus)

                a.currentFunctioAsync = prevAsync
                a.currentFunctioGenerator = prevGenerator
            }
        }

        # Expression statement
        casu ExpressiaSententia ut e {
            r.expressia(e.expressia)
        }

        # Rumpe/Perge - no analysis needed
        casu RumpeSententia {
            # break - no semantic analysis needed
        }

        casu PergeSententia {
            # continue - no semantic analysis needed
        }

        # Imports - handled separately during predeclaration
        casu ImportaSententia {
            # Imports are processed in predeclaration phase
        }

        casu _ tacet
    }
}
