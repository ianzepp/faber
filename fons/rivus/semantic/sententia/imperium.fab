# Control Flow Statement Analysis
#
# Handles: si, dum, ex/de...pro, elige, discerne, custodi

§ ex "../resolvitor" importa Resolvitor
§ ex "../nucleus" importa DiscretioDeclInfo
§ ex "../typi" importa SemanticTypus, IGNOTUM
§ ex "../scopus" importa ScopusSpecies, Symbolum, SymbolumSpecies, quaereSymbolum
§ ex "../errores" importa emptyCaseBlockError
§ ex "../../ast/sententia" importa Sententia, VariansExemplar, IteratioVariabilis

# =============================================================================
# CONDITIONAL
# =============================================================================

# Analyze si (if) statement
@ publica
functio analyzeSi(Resolvitor r, Sententia siStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne siStmt {
        casu SiSententia ut s {
            # Analyze condition
            r.expressia(s.condicio)

            # Analyze consequent in its own block scope
            a.intraScopum(ScopusSpecies.Massa)
            r.sententia(s.consequens)
            a.exiScopum()

            # Analyze alternate (sin/secus) if present
            si nonnihil s.alternans {
                # Check if alternate is another si statement (chained if)
                discerne s.alternans {
                    casu SiSententia {
                        # Recursively analyze chained si
                        analyzeSi(r, s.alternans qua Sententia)
                    }
                    casu _ {
                        # else block needs its own scope
                        a.intraScopum(ScopusSpecies.Massa)
                        r.sententia(s.alternans qua Sententia)
                        a.exiScopum()
                    }
                }
            }
        }
        casu _ tacet
    }
}

# =============================================================================
# LOOPS
# =============================================================================

# Analyze dum (while) statement
@ publica
functio analyzeDum(Resolvitor r, Sententia dumStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne dumStmt {
        casu DumSententia ut d {
            # Analyze condition
            r.expressia(d.condicio)

            # Analyze body in its own block scope
            a.intraScopum(ScopusSpecies.Massa)
            r.sententia(d.corpus)
            a.exiScopum()
        }
        casu _ tacet
    }
}

# Analyze iteratio (ex/de...pro) statement
@ publica
functio analyzeIteratio(Resolvitor r, Sententia iteratioStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne iteratioStmt {
        casu IteratioSententia ut i {
            # Analyze source expression
            fixum sourceTypus = r.expressia(i.iterabile)

            # Enter block scope for loop variable
            a.intraScopum(ScopusSpecies.Massa)

            # Define loop variable(s) based on binding type
            discerne i.variabilis {
                casu Nomen ut n {
                    # Simple identifier - infer type from source
                    varia elemTypus = IGNOTUM qua SemanticTypus
                    discerne sourceTypus {
                        casu Genericum ut g {
                            si g.nomen == "lista" et g.parametri.longitudo() > 0 {
                                elemTypus = g.parametri.primus()
                            }
                        }
                        ceterum tacet
                    }

                    a.scopus.symbola[n.valor] = {
                        nomen: n.valor,
                        semanticTypus: elemTypus,
                        species: SymbolumSpecies.Variabilis,
                        mutabilis: i.mutabilis,
                        locus: i.locus
                    }
                }
                casu Series ut s {
                    # Array pattern - define each element as a binding
                    varia indice = 0
                    ex s.elementa fixum elem {
                        si elem.omissum aut nihil elem.nomen {
                            indice = indice + 1
                            perge
                        }

                        # Type inference: for tabula<K,V>, [0]=K, [1]=V
                        varia posTypus = IGNOTUM qua SemanticTypus
                        discerne sourceTypus {
                            casu Genericum ut g {
                                si g.nomen == "tabula" et g.parametri.longitudo() > 1 {
                                    si indice == 0 { posTypus = g.parametri[0] }
                                    sin indice == 1 { posTypus = g.parametri[1] }
                                } sin g.nomen == "lista" et g.parametri.longitudo() > 0 {
                                    posTypus = g.parametri[0]
                                }
                            }
                            ceterum tacet
                        }

                        a.scopus.symbola[elem.nomen qua textus] = {
                            nomen: elem.nomen qua textus,
                            semanticTypus: posTypus,
                            species: SymbolumSpecies.Variabilis,
                            mutabilis: i.mutabilis,
                            locus: elem.locus
                        }
                        indice = indice + 1
                    }
                }
            }

            # Analyze body
            r.sententia(i.corpus)

            # Exit scope
            a.exiScopum()
        }
        casu _ tacet
    }
}

# =============================================================================
# PATTERN MATCHING
# =============================================================================

# Check if a statement is an empty block (MassaSententia with no body)
# WHY: Empty blocks should use 'tacet' instead for intentional no-op.
functio estVacuaMassa(de Sententia s) -> bivalens {
    discerne s {
        casu MassaSententia ut m {
            redde m.corpus.longitudo() == 0
        }
        casu _ {
            redde falsum
        }
    }
}

# Analyze elige (switch) statement
@ publica
functio analyzeElige(Resolvitor r, Sententia eligeStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne eligeStmt {
        casu EligeSententia ut e {
            # Analyze discriminant
            r.expressia(e.discriminans)

            # Analyze each case in its own scope
            ex e.casus fixum casus {
                # Check for empty block
                si estVacuaMassa(casus.consequens) {
                    fixum err = emptyCaseBlockError()
                    a.error(err.textus, casus.locus, err.auxilium)
                }

                # Analyze case test
                r.expressia(casus.condicio)

                # Analyze case body in its own block scope
                a.intraScopum(ScopusSpecies.Massa)
                r.sententia(casus.consequens)
                a.exiScopum()
            }

            # Analyze default (aliter) if present
            si nonnihil e.praedefinitum {
                # Check for empty block in default
                si estVacuaMassa(e.praedefinitum qua Sententia) {
                    fixum err = emptyCaseBlockError()
                    a.error(err.textus, e.praedefinitum.locus, err.auxilium)
                }

                a.intraScopum(ScopusSpecies.Massa)
                r.sententia(e.praedefinitum qua Sententia)
                a.exiScopum()
            }
        }
        casu _ tacet
    }
}

# Analyze discerne (pattern match) statement
@ publica
functio analyzeDiscerne(Resolvitor r, Sententia discerneStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne discerneStmt {
        casu DiscerneSententia ut d {
            # Analyze all discriminants
            ex d.discriminantes fixum disc {
                r.expressia(disc)
            }

            # Analyze each variant case
            ex d.casus fixum casus {
                # Enter scope for pattern bindings
                a.intraScopum(ScopusSpecies.Massa)

                # Define bound variables for all patterns in this case
                # WHY: Each pattern can introduce 'ut' alias or 'pro' field bindings.
                varia patternIndex = 0
                ex casus.exemplaria fixum pattern {
                    # Skip wildcards - they have no bindings
                    si pattern.estWildcard {
                        patternIndex = patternIndex + 1
                        perge
                    }

                    # Get discriminant type for this pattern position
                    varia discriminantTypus = IGNOTUM
                    si patternIndex < d.discriminantes.longitudo() {
                        discriminantTypus = r.expressia(d.discriminantes[patternIndex])
                    }

                    # Get variant type by resolving DiscretioNomen.VariantNomen
                    varia variantTypus = IGNOTUM
                    discerne discriminantTypus {
                        casu Usitatum ut u {
                            # For discriminated union, lookup Discriminant.Variant
                            fixum qualNomen = scriptum("§.§", u.nomen, pattern.variansNomen)
                            fixum symbolum = quaereSymbolum(a.scopus, qualNomen)
                            si nonnihil symbolum {
                                variantTypus = (symbolum novum Symbolum).semanticTypus
                            }
                        }
                        casu _ {
                            # Could be other complex type, but for now handle common case
                        }
                    }

                    # Define alias if present
                    si nonnihil pattern.alias {
                        fixum alias = pattern.alias qua textus
                        a.scopus.symbola[alias] = {
                            nomen: alias,
                            semanticTypus: variantTypus,  # Inferred from discriminant.variant
                            species: SymbolumSpecies.Variabilis,
                            mutabilis: falsum,
                            locus: pattern.locus
                        }
                    }

                    # Define field bindings if present
                    varia fieldIndex = 0
                    ex pattern.vincula fixum vinculum {
                        # Extract field type from variant fields
                        varia fieldTypus = IGNOTUM
                        discerne variantTypus {
                            casu Genus ut g {
                                # Get field names from the agri map keys (since order may not be preserved in map)
                                # For now, use IGNOTUM since we need the original field order from variant declaration
                                # TODO: Need access to original VariansDeclaratio.campi to get correct positional types
                                fieldTypus = IGNOTUM
                            }
                            casu _ {
                                # Not a genus, can't extract field types
                            }
                        }

                        a.scopus.symbola[vinculum] = {
                            nomen: vinculum,
                            semanticTypus: fieldTypus,  # Inferred from variant field
                            species: SymbolumSpecies.Variabilis,
                            mutabilis: falsum,
                            locus: pattern.locus
                        }
                        fieldIndex = fieldIndex + 1
                    }

                    patternIndex = patternIndex + 1
                }

                # Check for empty block
                si estVacuaMassa(casus.consequens) {
                    fixum err = emptyCaseBlockError()
                    a.error(err.textus, casus.locus, err.auxilium)
                }

                # Analyze case body
                r.sententia(casus.consequens)

                a.exiScopum()
            }

            # Exhaustiveness check (discerne omnia only)
            si d.exhaustiva {
                # Treat all-wildcard case as catch-all (ceterum)
                varia habetWildcardCasu = falsum
                ex d.casus fixum casus {
                    varia habetExemplar = falsum
                    varia omniaWildcard = verum
                    ex casus.exemplaria fixum exemplar {
                        habetExemplar = verum
                        si non exemplar.estWildcard {
                            omniaWildcard = falsum
                            rumpe
                        }
                    }
                    si habetExemplar et omniaWildcard {
                        habetWildcardCasu = verum
                        rumpe
                    }
                }

                si d.discriminantes.longitudo() != 1 {
                    a.error("discerne omnia requires exactly one discriminant", d.locus)
                }
                sin non habetWildcardCasu {
                    # Resolve discriminant type name
                    fixum discriminantTypus = r.expressia(d.discriminantes[0])
                    varia discretioNomen = nihil qua si textus
                    discerne discriminantTypus {
                        casu Usitatum ut u {
                            discretioNomen = u.nomen
                        }
                        casu _ tacet
                    }

                    si nonnihil discretioNomen {
                        fixum info = a.discretioIndex[discretioNomen qua textus]
                        si nonnihil info {
                            varia handled = {} innatum tabula<textus, bivalens>
                            ex d.casus fixum casus {
                                varia primum = nihil qua si VariansExemplar
                                ex casus.exemplaria fixum exemplar {
                                    primum = exemplar
                                    rumpe
                                }
                                si nonnihil primum {
                                    fixum exemplar = primum novum VariansExemplar
                                    si non exemplar.estWildcard {
                                        handled[exemplar.variansNomen] = verum
                                    }
                                }
                            }

                            varia missingCount = 0
                            varia firstMissing = "" qua textus
                            varia quoted = [] innatum lista<textus>
                            ex (info novum DiscretioDeclInfo).variantes fixum variansInfo {
                                si nihil handled[variansInfo.nomen] {
                                    missingCount = missingCount + 1
                                    si missingCount == 1 {
                                        firstMissing = variansInfo.nomen
                                    }
                                    quoted.appende(scriptum("'§'", variansInfo.nomen))
                                }
                            }

                            si missingCount > 0 {
                                si missingCount == 1 {
                                    a.error(
                                        scriptum("Non-exhaustive match in discerne omnia: missing variant '§'", firstMissing),
                                        d.locus
                                    )
                                }
                                secus {
                                    a.error(
                                        scriptum("Non-exhaustive match in discerne omnia: missing variants §", quoted.coniunge(", ")),
                                        d.locus
                                    )
                                }
                            }
                        }
                    }
                }
            }
        }
        casu _ tacet
    }
}

# Analyze custodi (guard) statement
@ publica
functio analyzeCustodi(Resolvitor r, Sententia custodiStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne custodiStmt {
        casu CustodiSententia ut c {
            # Analyze each guard clause
            ex c.clausulae fixum clausula {
                # Analyze condition
                r.expressia(clausula.condicio)

                # Analyze body in its own block scope
                a.intraScopum(ScopusSpecies.Massa)
                r.sententia(clausula.consequens)
                a.exiScopum()
            }
        }
        casu _ tacet
    }
}
