# Control Flow Statement Analysis
#
# Handles: si, dum, ex/de...pro, elige, discerne, custodi

§ ex "../resolvitor" importa Resolvitor
§ ex "../nucleus" importa DiscretioDeclInfo
§ ex "../typi" importa SemanticTypus, IGNOTUM
§ ex "../scopus" importa ScopusSpecies, Symbolum, SymbolumSpecies, quaereSymbolum
§ ex "../../ast/sententia" importa Sententia, VariansExemplar

# =============================================================================
# CONDITIONAL
# =============================================================================

# Analyze si (if) statement
@ publica
functio analyzeSi(Resolvitor r, Sententia siStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne siStmt {
        casu SiSententia ut s {
            # Analyze condition
            r.expressia(s.condicio)

            # Analyze consequent in its own block scope
            a.intraScopum(ScopusSpecies.Massa)
            r.sententia(s.consequens)
            a.exiScopum()

            # Analyze alternate (sin/secus) if present
            si nonnihil s.alternans {
                # Check if alternate is another si statement (chained if)
                discerne s.alternans {
                    casu SiSententia {
                        # Recursively analyze chained si
                        analyzeSi(r, s.alternans qua Sententia)
                    }
                    casu _ {
                        # else block needs its own scope
                        a.intraScopum(ScopusSpecies.Massa)
                        r.sententia(s.alternans qua Sententia)
                        a.exiScopum()
                    }
                }
            }
        }
        casu _ { }
    }
}

# =============================================================================
# LOOPS
# =============================================================================

# Analyze dum (while) statement
@ publica
functio analyzeDum(Resolvitor r, Sententia dumStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne dumStmt {
        casu DumSententia ut d {
            # Analyze condition
            r.expressia(d.condicio)

            # Analyze body in its own block scope
            a.intraScopum(ScopusSpecies.Massa)
            r.sententia(d.corpus)
            a.exiScopum()
        }
        casu _ { }
    }
}

# Analyze iteratio (ex/de...pro) statement
@ publica
functio analyzeIteratio(Resolvitor r, Sententia iteratioStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne iteratioStmt {
        casu IteratioSententia ut i {
            # Analyze source expression
            fixum sourceTypus = r.expressia(i.iterabile)

            # Enter block scope for loop variable
            a.intraScopum(ScopusSpecies.Massa)

            # Infer loop variable type from source
            varia elemTypus = IGNOTUM qua SemanticTypus
            discerne sourceTypus {
                casu Genericum ut g {
                    si g.nomen == "lista" et g.parametri.longitudo() > 0 {
                        elemTypus = g.parametri.primus()
                    }
                }
                casu _ { }
            }

            # Define loop variable
            a.scopus.symbola[i.variabilis] = {
                nomen: i.variabilis,
                semanticTypus: elemTypus,
                species: SymbolumSpecies.Variabilis,
                mutabilis: falsum,
                locus: i.locus
            }

            # Analyze body
            r.sententia(i.corpus)

            # Exit scope
            a.exiScopum()
        }
        casu _ { }
    }
}

# =============================================================================
# PATTERN MATCHING
# =============================================================================

# Analyze elige (switch) statement
@ publica
functio analyzeElige(Resolvitor r, Sententia eligeStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne eligeStmt {
        casu EligeSententia ut e {
            # Analyze discriminant
            r.expressia(e.discriminans)

            # Analyze each case in its own scope
            ex e.casus pro casus {
                # Analyze case test
                r.expressia(casus.condicio)

                # Analyze case body in its own block scope
                a.intraScopum(ScopusSpecies.Massa)
                r.sententia(casus.consequens)
                a.exiScopum()
            }

            # Analyze default (aliter) if present
            si nonnihil e.praedefinitum {
                a.intraScopum(ScopusSpecies.Massa)
                r.sententia(e.praedefinitum qua Sententia)
                a.exiScopum()
            }
        }
        casu _ { }
    }
}

# Analyze discerne (pattern match) statement
@ publica
functio analyzeDiscerne(Resolvitor r, Sententia discerneStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne discerneStmt {
        casu DiscerneSententia ut d {
            # Analyze all discriminants
            ex d.discriminantes pro disc {
                r.expressia(disc)
            }

            # Analyze each variant case
            ex d.casus pro casus {
                # Enter scope for pattern bindings
                a.intraScopum(ScopusSpecies.Massa)

                # Define bound variables for all patterns in this case
                # WHY: Each pattern can introduce 'ut' alias or 'pro' field bindings.
                varia patternIndex = 0
                ex casus.exemplaria pro pattern {
                    # Skip wildcards - they have no bindings
                    si pattern.estWildcard {
                        patternIndex = patternIndex + 1
                        perge
                    }

                    # Get discriminant type for this pattern position
                    varia discriminantTypus = IGNOTUM
                    si patternIndex < d.discriminantes.longitudo() {
                        discriminantTypus = r.expressia(d.discriminantes[patternIndex])
                    }

                    # Get variant type by resolving DiscretioNomen.VariantNomen
                    varia variantTypus = IGNOTUM
                    discerne discriminantTypus {
                        casu Usitatum ut u {
                            # For discriminated union, lookup Discriminant.Variant
                            fixum qualNomen = scriptum("§.§", u.nomen, pattern.variansNomen)
                            fixum symbolum = quaereSymbolum(a.scopus, qualNomen)
                            si nonnihil symbolum {
                                variantTypus = (symbolum qua Symbolum).semanticTypus
                            }
                        }
                        casu _ {
                            # Could be other complex type, but for now handle common case
                        }
                    }

                    # Define alias if present
                    si nonnihil pattern.alias {
                        fixum alias = pattern.alias qua textus
                        a.scopus.symbola[alias] = {
                            nomen: alias,
                            semanticTypus: variantTypus,  # Inferred from discriminant.variant
                            species: SymbolumSpecies.Variabilis,
                            mutabilis: falsum,
                            locus: pattern.locus
                        }
                    }

                    # Define field bindings if present
                    varia fieldIndex = 0
                    ex pattern.vincula pro vinculum {
                        # Extract field type from variant fields
                        varia fieldTypus = IGNOTUM
                        discerne variantTypus {
                            casu Genus ut g {
                                # Get field names from the agri map keys (since order may not be preserved in map)
                                # For now, use IGNOTUM since we need the original field order from variant declaration
                                # TODO: Need access to original VariansDeclaratio.campi to get correct positional types
                                fieldTypus = IGNOTUM
                            }
                            casu _ {
                                # Not a genus, can't extract field types
                            }
                        }

                        a.scopus.symbola[vinculum] = {
                            nomen: vinculum,
                            semanticTypus: fieldTypus,  # Inferred from variant field
                            species: SymbolumSpecies.Variabilis,
                            mutabilis: falsum,
                            locus: pattern.locus
                        }
                        fieldIndex = fieldIndex + 1
                    }

                    patternIndex = patternIndex + 1
                }

                # Analyze case body
                r.sententia(casus.consequens)

                a.exiScopum()
            }

            # Exhaustiveness check (discerne omnia only)
            si d.exhaustiva {
                # Treat all-wildcard case as catch-all (ceterum)
                varia habetWildcardCasu = falsum
                ex d.casus pro casus {
                    varia habetExemplar = falsum
                    varia omniaWildcard = verum
                    ex casus.exemplaria pro exemplar {
                        habetExemplar = verum
                        si non exemplar.estWildcard {
                            omniaWildcard = falsum
                            rumpe
                        }
                    }
                    si habetExemplar et omniaWildcard {
                        habetWildcardCasu = verum
                        rumpe
                    }
                }

                si d.discriminantes.longitudo() != 1 {
                    a.error("discerne omnia requires exactly one discriminant", d.locus)
                }
                sin non habetWildcardCasu {
                    # Resolve discriminant type name
                    fixum discriminantTypus = r.expressia(d.discriminantes[0])
                    varia discretioNomen = nihil qua textus?
                    discerne discriminantTypus {
                        casu Usitatum ut u {
                            discretioNomen = u.nomen
                        }
                        casu _ { }
                    }

                    si nonnihil discretioNomen {
                        fixum info = a.discretioIndex[discretioNomen qua textus]
                        si nonnihil info {
                            varia handled = {} innatum tabula<textus, bivalens>
                            ex d.casus pro casus {
                                varia primum = nihil qua VariansExemplar?
                                ex casus.exemplaria pro exemplar {
                                    primum = exemplar
                                    rumpe
                                }
                                si nonnihil primum {
                                    fixum exemplar = primum qua VariansExemplar
                                    si non exemplar.estWildcard {
                                        handled[exemplar.variansNomen] = verum
                                    }
                                }
                            }

                            varia missingCount = 0
                            varia firstMissing = "" qua textus
                            varia quoted = [] innatum lista<textus>
                            ex (info qua DiscretioDeclInfo).variantes pro variansInfo {
                                si nihil handled[variansInfo.nomen] {
                                    missingCount = missingCount + 1
                                    si missingCount == 1 {
                                        firstMissing = variansInfo.nomen
                                    }
                                    quoted.adde(scriptum("'§'", variansInfo.nomen))
                                }
                            }

                            si missingCount > 0 {
                                si missingCount == 1 {
                                    a.error(
                                        scriptum("Non-exhaustive match in discerne omnia: missing variant '§'", firstMissing),
                                        d.locus
                                    )
                                }
                                secus {
                                    a.error(
                                        scriptum("Non-exhaustive match in discerne omnia: missing variants §", quoted.coniunge(", ")),
                                        d.locus
                                    )
                                }
                            }
                        }
                    }
                }
            }
        }
        casu _ { }
    }
}

# Analyze custodi (guard) statement
@ publica
functio analyzeCustodi(Resolvitor r, Sententia custodiStmt) -> vacuum {
    fixum a = r.analyzator()

    discerne custodiStmt {
        casu CustodiSententia ut c {
            # Analyze each guard clause
            ex c.clausulae pro clausula {
                # Analyze condition
                r.expressia(clausula.condicio)

                # Analyze body in its own block scope
                a.intraScopum(ScopusSpecies.Massa)
                r.sententia(clausula.consequens)
                a.exiScopum()
            }
        }
        casu _ { }
    }
}
