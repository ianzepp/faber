# Typi - Semantic Type System
#
# Defines the type system used during semantic analysis.

# ============================================================================
# SEMANTIC TYPE (DISCRIMINATED UNION)
# ============================================================================

# All possible types in the type system
@ publica
discretio SemanticTypus {
    # Primitive types: textus, numerus, fractus, decimus, magnus, bivalens, nihil, vacuum, octeti
    Primitivum {
        textus nomen                                    # "textus" | "numerus" | etc.
        bivalens nullabilis                             # T? types
        numerus? amplitudo                              # bit width for numerus<32>
    }

    # Generic types: lista<T>, tabula<K,V>, promissum<T>
    Genericum {
        textus nomen                                    # "lista" | "tabula" | etc.
        lista<SemanticTypus> parametri                  # type parameters
        bivalens nullabilis
    }

    # Function types
    Functio {
        lista<SemanticTypus> parametriTypi              # parameter types
        SemanticTypus reditusTypus                      # return type
        bivalens asyncronum                             # async function?
        bivalens habetCuratorem                         # has curator param?
    }

    # Union types: A | B | C
    Unio {
        lista<SemanticTypus> typi
    }

    # Unknown type for unresolved/error cases
    Ignotum {
        textus? ratio                                   # reason for being unknown
    }

    # User-defined type (class, interface, etc.)
    Usitatum {
        textus nomen
        bivalens nullabilis
    }

    # Enum type (ordo) with named members
    Ordo {
        textus nomen
        tabula<textus, SemanticTypus> membra
        bivalens nullabilis
    }

    # Genus (class/struct) with fields and methods
    Genus {
        textus nomen
        tabula<textus, SemanticTypus> agri              # fields
        tabula<textus, SemanticTypus> methodi           # methods
        tabula<textus, SemanticTypus> agriStatici       # static fields
        tabula<textus, SemanticTypus> methodiStatici    # static methods
        bivalens nullabilis
    }

    # Pactum (interface/protocol) with method signatures
    Pactum {
        textus nomen
        tabula<textus, SemanticTypus> methodi           # method signatures
        bivalens nullabilis
    }
}

# ============================================================================
# TYPE CONSTRUCTORS
# ============================================================================

# Create a primitive type
@ publica
functio primitivumTypus(ex textus nomen, bivalens nullabilis) -> SemanticTypus {
    redde finge Primitivum {
        nomen: nomen,
        nullabilis: nullabilis,
        amplitudo: nihil
    } qua SemanticTypus
}

# Create a primitive type with size
@ publica
functio primitivumTypusCumAmplitudine(ex textus nomen, numerus amplitudo, bivalens nullabilis) -> SemanticTypus {
    redde finge Primitivum {
        nomen: nomen,
        nullabilis: nullabilis,
        amplitudo: amplitudo
    } qua SemanticTypus
}

# Create a generic type
@ publica
functio genericumTypus(ex textus nomen, ex lista<SemanticTypus> parametri, bivalens nullabilis) -> SemanticTypus {
    redde finge Genericum {
        nomen: nomen,
        parametri: parametri,
        nullabilis: nullabilis
    } qua SemanticTypus
}

# Create a function type
@ publica
functio functioTypus(
    ex lista<SemanticTypus> parametriTypi,
    ex SemanticTypus reditusTypus,
    bivalens asyncronum,
    bivalens habetCuratorem
) -> SemanticTypus {
    redde finge Functio {
        parametriTypi: parametriTypi,
        reditusTypus: reditusTypus,
        asyncronum: asyncronum,
        habetCuratorem: habetCuratorem
    } qua SemanticTypus
}

# Create a union type
@ publica
functio unioTypus(ex lista<SemanticTypus> typi) -> SemanticTypus {
    redde finge Unio { typi: typi } qua SemanticTypus
}

# Create an unknown type
@ publica
functio ignotumTypus(si ex textus ratio) -> SemanticTypus {
    redde finge Ignotum { ratio: ratio } qua SemanticTypus
}

# Create a user-defined type
@ publica
functio usitatumTypus(ex textus nomen, bivalens nullabilis) -> SemanticTypus {
    redde finge Usitatum {
        nomen: nomen,
        nullabilis: nullabilis
    } qua SemanticTypus
}

# Create an enum type
@ publica
functio ordoTypus(ex textus nomen, ex tabula<textus, SemanticTypus> membra, bivalens nullabilis) -> SemanticTypus {
    redde finge Ordo {
        nomen: nomen,
        membra: membra,
        nullabilis: nullabilis
    } qua SemanticTypus
}

# Create a genus type
@ publica
functio genusTypus(
    ex textus nomen,
    ex tabula<textus, SemanticTypus> agri,
    ex tabula<textus, SemanticTypus> methodi,
    ex tabula<textus, SemanticTypus> agriStatici,
    ex tabula<textus, SemanticTypus> methodiStatici,
    bivalens nullabilis
) -> SemanticTypus {
    redde finge Genus {
        nomen: nomen,
        agri: agri,
        methodi: methodi,
        agriStatici: agriStatici,
        methodiStatici: methodiStatici,
        nullabilis: nullabilis
    } qua SemanticTypus
}

# Create a pactum type
@ publica
functio pactumTypus(ex textus nomen, ex tabula<textus, SemanticTypus> methodi, bivalens nullabilis) -> SemanticTypus {
    redde finge Pactum {
        nomen: nomen,
        methodi: methodi,
        nullabilis: nullabilis
    } qua SemanticTypus
}

# ============================================================================
# COMMON TYPE CONSTANTS
# ============================================================================

@ publica
fixum TEXTUS = primitivumTypus("textus", falsum)

@ publica
fixum NUMERUS = primitivumTypus("numerus", falsum)

@ publica
fixum FRACTUS = primitivumTypus("fractus", falsum)

@ publica
fixum DECIMUS = primitivumTypus("decimus", falsum)

@ publica
fixum MAGNUS = primitivumTypus("magnus", falsum)

@ publica
fixum BIVALENS = primitivumTypus("bivalens", falsum)

@ publica
fixum NIHIL = primitivumTypus("nihil", falsum)

@ publica
fixum VACUUM = primitivumTypus("vacuum", falsum)

@ publica
fixum OCTETI = primitivumTypus("octeti", falsum)

@ publica
fixum IGNOTUM = ignotumTypus(nihil)

# ============================================================================
# TYPE UTILITIES
# ============================================================================

# Check if two types are equal
@ publica
functio typiAequales(de SemanticTypus a, de SemanticTypus b) -> bivalens {
    # Compare by variant tag and key fields
    # Uses nested single-discriminant discerne for nanus compatibility.
    discerne a {
        casu Primitivum ut pa {
            discerne b {
                casu Primitivum ut pb {
                    redde pa.nomen == pb.nomen
                }
                ceterum {
                    redde falsum
                }
            }
        }

        casu Genericum ut ga {
            discerne b {
                casu Genericum ut gb {
                    si ga.nomen != gb.nomen {
                        redde falsum
                    }
                    si ga.parametri.longitudo() != gb.parametri.longitudo() {
                        redde falsum
                    }

                    varia i = 0
                    ex ga.parametri fixum t {
                        si non typiAequales(t, gb.parametri[i]) {
                            redde falsum
                        }
                        i += 1
                    }

                    redde verum
                }
                ceterum {
                    redde falsum
                }
            }
        }

        casu Functio ut fa {
            discerne b {
                casu Functio ut fb {
                    si fa.asyncronum != fb.asyncronum {
                        redde falsum
                    }
                    si fa.parametriTypi.longitudo() != fb.parametriTypi.longitudo() {
                        redde falsum
                    }
                    si non typiAequales(fa.reditusTypus, fb.reditusTypus) {
                        redde falsum
                    }

                    varia i = 0
                    ex fa.parametriTypi fixum t {
                        si non typiAequales(t, fb.parametriTypi[i]) {
                            redde falsum
                        }
                        i += 1
                    }

                    redde verum
                }
                ceterum {
                    redde falsum
                }
            }
        }

        casu Unio ut ua {
            discerne b {
                casu Unio ut ub {
                    si ua.typi.longitudo() != ub.typi.longitudo() {
                        redde falsum
                    }

                    varia i = 0
                    ex ua.typi fixum t {
                        si non typiAequales(t, ub.typi[i]) {
                            redde falsum
                        }
                        i += 1
                    }

                    redde verum
                }
                ceterum {
                    redde falsum
                }
            }
        }

        casu Ignotum {
            discerne b {
                casu Ignotum {
                    redde verum
                }
                ceterum {
                    redde falsum
                }
            }
        }

        casu Usitatum ut usa {
            discerne b {
                casu Usitatum ut usb {
                    redde usa.nomen == usb.nomen
                }
                ceterum {
                    redde falsum
                }
            }
        }

        casu Ordo ut oa {
            discerne b {
                casu Ordo ut ob {
                    redde oa.nomen == ob.nomen
                }
                ceterum {
                    redde falsum
                }
            }
        }

        casu Genus ut gea {
            discerne b {
                casu Genus ut geb {
                    redde gea.nomen == geb.nomen
                }
                ceterum {
                    redde falsum
                }
            }
        }

        casu Pactum ut paa {
            discerne b {
                casu Pactum ut pab {
                    redde paa.nomen == pab.nomen
                }
                ceterum {
                    redde falsum
                }
            }
        }
    }

    redde falsum
}

# Check if a type is assignable to another type
@ publica
functio assignabileAd(de SemanticTypus fons, de SemanticTypus scopus) -> bivalens {
    # EDGE: SemanticTypus should never be nil. If it happens, prefer "not assignable"
    # so we don't silently accept invalid programs.
    si nihil fons aut nihil scopus {
        redde falsum
    }
    # Unknown is assignable to anything
    discerne fons {
        casu Ignotum {
            redde verum
        }
        casu _ tacet
    }

    discerne scopus {
        casu Ignotum {
            redde verum
        }
        casu _ tacet
    }

    # nihil is assignable to nullable types
    discerne fons {
        casu Primitivum ut p {
            si p.nomen == "nihil" {
                discerne scopus {
                    casu Primitivum ut sp {
                        redde sp.nullabilis
                    }
                    casu Genericum ut sg {
                        redde sg.nullabilis
                    }
                    casu Usitatum ut su {
                        redde su.nullabilis
                    }
                    casu Ordo ut so {
                        redde so.nullabilis
                    }
                    casu Genus ut sge {
                        redde sge.nullabilis
                    }
                    casu Pactum ut spa {
                        redde spa.nullabilis
                    }
                    casu _ {
                        redde falsum
                    }
                }
            }
        }
        casu _ tacet
    }

    # Numeric type promotion: numerus -> fractus, numerus -> decimus
    discerne fons {
        casu Primitivum ut pf {
            discerne scopus {
                casu Primitivum ut ps {
                    si estNumericum(pf.nomen) et estNumericum(ps.nomen) {
                        redde verum
                    }
                }
                casu _ tacet
            }
        }
        casu _ tacet
    }

    # Check if source is in target union
    discerne scopus {
        casu Unio ut u {
            ex u.typi fixum t {
                si assignabileAd(fons, t) {
                    redde verum
                }
            }
            redde falsum
        }
        casu _ tacet
    }

    # Source union must have all types assignable to target
    discerne fons {
        casu Unio ut u {
            ex u.typi fixum t {
                si non assignabileAd(t, scopus) {
                    redde falsum
                }
            }
            redde verum
        }
        casu _ tacet
    }

    # Otherwise check equality
    redde typiAequales(fons, scopus)
}

# Helper: check if type name is numeric
@ publica
functio estNumericum(de textus nomen) -> bivalens {
    redde nomen inter ["numerus", "fractus", "decimus"]
}

# Format a type for error messages
@ publica
functio formaTypum(de SemanticTypus t) -> textus {
    discerne t {
        casu Primitivum ut p {
            varia resultatum = p.nomen
            si nonnihil p.amplitudo {
                resultatum = scriptum("§<§>", resultatum, p.amplitudo)
            }
            si p.nullabilis {
                resultatum = scriptum("§?", resultatum)
            }
            redde resultatum
        }

        casu Genericum ut g {
            # Build parameter list
            varia params = [] innatum lista<textus>
            ex g.parametri fixum typ {
                params.adde(formaTypum(typ))
            }
            varia resultatum = scriptum("§<§>", g.nomen, params.coniunge(", "))
            si g.nullabilis {
                resultatum = scriptum("§?", resultatum)
            }
            redde resultatum
        }

        casu Functio ut f {
            # Build parameter list
            varia params = [] innatum lista<textus>
            ex f.parametriTypi fixum typ {
                params.adde(formaTypum(typ))
            }
            fixum asyncPraefix = f.asyncronum sic "futura " secus ""
            redde scriptum("§(§) -> §", asyncPraefix, params.coniunge(", "), formaTypum(f.reditusTypus))
        }

        casu Unio ut u {
            varia parts = [] innatum lista<textus>
            ex u.typi fixum typ {
                parts.adde(formaTypum(typ))
            }
            redde parts.coniunge(" | ")
        }

        casu Ignotum ut ig {
            si nonnihil ig.ratio {
                redde scriptum("ignotum(§)", ig.ratio)
            }
            redde "ignotum"
        }

        casu Usitatum ut u {
            si u.nullabilis {
                redde scriptum("§?", u.nomen)
            }
            redde u.nomen
        }

        casu Ordo ut o {
            si o.nullabilis {
                redde scriptum("ordo §?", o.nomen)
            }
            redde scriptum("ordo §", o.nomen)
        }

        casu Genus ut g {
            si g.nullabilis {
                redde scriptum("genus §?", g.nomen)
            }
            redde scriptum("genus §", g.nomen)
        }

        casu Pactum ut p {
            si p.nullabilis {
                redde scriptum("pactum §?", p.nomen)
            }
            redde scriptum("pactum §", p.nomen)
        }
    }

    redde "ignotum"
}
