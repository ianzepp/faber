# Dependentia - Registry extraction for § dependentia annotations
#
# Parses file-level § dependentia annotations and builds a registry
# mapping aliases to their resolution paths.
#
# Syntax:
#   § dependentia "alias" via "path"
#   § dependentia "alias" github "owner/repo#ref" via "subpath"
#
# Also provides cache path resolution for GitHub dependencies.
# Cache structure: ~/.cache/faber/github.com/{owner}/{repo}/{sha}/

§ ex "../ast/radix" importa SectioAnnotatio
§ ex "../../norma/hal/solum" importa solum
§ ex "../../norma/hal/processus" importa processus

# ============================================================================
# TYPES
# ============================================================================

# A resolved dependency declaration
@ publicum
genus Dependentia {
    textus alias      # import alias (e.g., "norma")
    textus? github    # github reference "owner/repo#ref" (future)
    textus? via       # local path or subpath within github repo
}

# ============================================================================
# EXTRACTION
# ============================================================================

# Extract dependency registry from sectiones
# Returns a map of alias -> Dependentia
@ publica
functio extractDependentiae(lista<SectioAnnotatio>? sectiones) -> tabula<textus, Dependentia> {
    varia result = {} innatum tabula<textus, Dependentia>
    si nihil sectiones { redde result }

    ex sectiones pro s {
        si s.nomen == "dependentia" {
            fixum dep = parseDependentiaArgs(s.argumenta)
            si nonnihil dep {
                result[dep.alias] = dep
            }
        }
    }
    redde result
}

# Parse dependentia arguments into a Dependentia
# Arguments: ["alias", "via", "path"] or ["alias", "github", "ref", "via", "subpath"]
functio parseDependentiaArgs(lista<textus> args) -> Dependentia? {
    si args.longitudo() < 1 { redde nihil }

    fixum alias = args[0]
    varia github = nihil qua textus?
    varia via = nihil qua textus?

    # Parse keyword-value pairs: github "...", via "..."
    varia i = 1
    dum i < args.longitudo() {
        fixum arg = args[i]
        si arg == "github" et i + 1 < args.longitudo() {
            github = args[i + 1]
            i = i + 2
        } sin arg == "via" et i + 1 < args.longitudo() {
            via = args[i + 1]
            i = i + 2
        } secus {
            i = i + 1
        }
    }

    redde { alias: alias, github: github, via: via } qua Dependentia
}

# ============================================================================
# CACHE PATHS (read-only)
# ============================================================================

# Get the cache root directory
# Respects XDG_CACHE_HOME, FABER_CACHE, or falls back to ~/.cache/faber
@ publica
functio cacheRoot() -> textus {
    # FABER_CACHE overrides everything
    fixum faberCache = processus.env("FABER_CACHE")
    si nonnihil faberCache { redde faberCache }

    # XDG_CACHE_HOME or default
    fixum xdgCache = processus.env("XDG_CACHE_HOME")
    fixum baseCache = nonnihil xdgCache sic xdgCache secus solum.iunge([solum.domus(), ".cache"])

    redde solum.iunge([baseCache, "faber"])
}

# Get the cache path for a specific github repo + commit
@ publica
functio cachePath(textus owner, textus repo, textus sha) -> textus {
    redde solum.iunge([cacheRoot(), "github.com", owner, repo, sha])
}

# Check if a repo+commit is already cached
@ publica
functio isCached(textus owner, textus repo, textus sha) -> bivalens {
    redde solum.exstat(cachePath(owner, repo, sha))
}

# ============================================================================
# GITHUB REF PARSING
# ============================================================================

# Parsed GitHub reference
@ publicum
genus GithubRef {
    textus owner
    textus repo
    textus ref      # branch, tag, or commit SHA
}

# Parse "owner/repo#ref" into GithubRef
# Examples:
#   "ianzepp/faber#main" -> { owner: "ianzepp", repo: "faber", ref: "main" }
#   "ianzepp/faber#v1.0.0" -> { owner: "ianzepp", repo: "faber", ref: "v1.0.0" }
#   "ianzepp/faber" -> { owner: "ianzepp", repo: "faber", ref: "main" }
@ publica
functio parseGithubSource(textus source) -> GithubRef? {
    # Split on # to get ref (default to "main")
    fixum lista<textus> hashParts = source.divide("#")
    fixum repoPath = hashParts[0]
    fixum ref = hashParts.longitudo() > 1 sic hashParts[1] secus "main"

    # Split repo path on /
    fixum lista<textus> slashParts = repoPath.divide("/")
    si slashParts.longitudo() != 2 { redde nihil }

    redde novum GithubRef {
        owner: slashParts[0],
        repo: slashParts[1],
        ref: ref
    }
}
