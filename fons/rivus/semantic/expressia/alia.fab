# Alia - Other Expression Resolution
#
# Handles lambda, finge, cede, novum, and conditional expressions.

importa ex "../resolvitor" privata Resolvitor
importa ex "../typi" privata SemanticTypus
importa ex "../typi" privata IGNOTUM
importa ex "../typi" privata VACUUM
importa ex "../typi" privata functioTypus
importa ex "../typi" privata usitatumTypus
importa ex "../typi" privata genericumTypus
importa ex "../scopus" privata ScopusSpecies
importa ex "../scopus" privata SymbolumSpecies
importa ex "../errores" privata cedeOutsideAsyncError
importa ex "../sententia/declara" privata resolveTypusAnnotatio
importa ex "../../ast/expressia" privata Expressia
importa ex "../../ast/expressia" privata ClausuraCorpus
importa ex "../../ast/sententia" privata Sententia
importa ex "../../ast/typus" privata TypusAnnotatio

# ============================================================================
# CLAUSURA EXPRESSION RESOLUTION
# ============================================================================

# Resolve a clausura expression (clausura x: x + 1)
@ publica
functio resolveClausura(Resolvitor r, Expressia clausuraExpr) -> SemanticTypus {
    fixum a = r.analyzator()

    discerne clausuraExpr {
        casu ClausuraExpressia ut l {
            # Enter function scope for parameters
            a.intraScopum(ScopusSpecies.Functio)

            # Define parameters in scope with resolved types
            varia paramTypi = [] innatum lista<SemanticTypus>
            itera ex l.parametra fixum param {
                # Resolve parameter type from annotation if present
                varia paramTypus = IGNOTUM qua SemanticTypus
                si nonnihil param.typus {
                    paramTypus = resolveTypusAnnotatio(r, param.typus novum TypusAnnotatio)
                } secus {
                    a.error("Closure parameter missing type annotation", param.locus, "Use type-first syntax: (numerus x) -> { ... }")
                }
                paramTypi.appende(paramTypus)

                a.scopus.symbola[param.nomen] = {
                    nomen: param.nomen,
                    semanticTypus: paramTypus,
                    species: SymbolumSpecies.Parametrum,
                    mutabilis: falsum,
                    locus: param.locus
                }
            }

            # Resolve body (expression or block)
            varia reditusTypus = VACUUM
            discerne l.corpus {
                casu Massa ut m {
                    r.sententia(m.valor)
                    discerne m.valor {
                        casu MassaSententia ut body {
                            fixum corpusLista = body.corpus qua lista<Sententia>
                            si corpusLista.longitudo() > 0 {
                                fixum ult = corpusLista[corpusLista.longitudo() - 1]
                                discerne ult {
                                    casu ReddeSententia ut s {
                                        si nonnihil s.valor {
                                            reditusTypus = r.expressia(s.valor qua Expressia)
                                        }
                                    }
                                    casu ExpressiaSententia ut s {
                                        reditusTypus = r.expressia(s.expressia)
                                    }
                                    casu _ tacet
                                }
                            }
                        }
                        casu _ tacet
                    }
                }
                casu Expr ut e {
                    reditusTypus = r.expressia(e.valor)
                }
            }

            # Exit function scope
            a.exiScopum()

            # Build function type using resolved parameter types
            redde functioTypus(paramTypi, reditusTypus, falsum, falsum)
        }
        casu _ tacet
    }

    redde IGNOTUM
}

# ============================================================================
# FINGE EXPRESSION RESOLUTION
# ============================================================================

# Resolve a finge expression (tagged union construction)
@ publica
functio resolveFingeExpr(Resolvitor r, Expressia fingeExpr) -> SemanticTypus {
    discerne fingeExpr {
        casu FingeExpressia ut f {
            # Resolve all field values
            itera ex f.campi fixum campo {
                r.expressia(campo.valor)
            }

            # The type comes from the qua clause (scopus)
            si nonnihil f.scopus {
                redde usitatumTypus(f.scopus.nomen, falsum)
            }

            # Otherwise use the variant name as the type
            redde usitatumTypus(f.variansNomen, falsum)
        }
        casu _ tacet
    }

    redde IGNOTUM
}

# ============================================================================
# CEDE (AWAIT) EXPRESSION RESOLUTION
# ============================================================================

# Resolve a cede (await) expression
@ publica
functio resolveCedeExpr(Resolvitor r, Expressia cedeExpr) -> SemanticTypus {
    fixum a = r.analyzator()

    discerne cedeExpr {
        casu CedeExpressia ut c {
            fixum promissumTypus = r.expressia(c.argumentum)

            # Check we're in an async context
            si non a.currentFunctioAsync et non a.currentFunctioGenerator {
                fixum err = cedeOutsideAsyncError()
                a.error(err.textus, c.locus, err.auxilium)
            }

            # Unwrap promissum<T> to T
            discerne promissumTypus {
                casu Genericum ut g {
                    si g.nomen == "promissum" et g.parametri.longitudo() > 0 {
                        redde g.parametri.primus()
                    }
                }
                casu _ tacet
            }

            redde promissumTypus
        }
        casu _ tacet
    }

    redde IGNOTUM
}

# ============================================================================
# NOVUM (NEW) EXPRESSION RESOLUTION
# ============================================================================

# Resolve a novum (new) expression
@ publica
functio resolveNovumExpr(Resolvitor r, Expressia novumExpr) -> SemanticTypus {
    discerne novumExpr {
        casu NovumExpressia ut n {
            # Resolve constructor arguments
            itera ex n.argumenta fixum arg {
                r.expressia(arg)
            }

            # The type is the class being instantiated
            discerne n.vocatum {
                casu Nomen ut nom {
                    redde usitatumTypus(nom.valor, falsum)
                }
                casu _ tacet
            }

            redde IGNOTUM
        }
        casu _ tacet
    }

    redde IGNOTUM
}

# ============================================================================
# CONDITIONAL EXPRESSION RESOLUTION
# ============================================================================

# Resolve a ternary conditional expression
@ publica
functio resolveCondicio(Resolvitor r, Expressia condicioExpr) -> SemanticTypus {
    discerne condicioExpr {
        casu CondicioExpressia ut c {
            r.expressia(c.condicio)
            fixum consequensTypus = r.expressia(c.consequens)
            r.expressia(c.alternans)

            # Return the consequent type (simplification)
            redde consequensTypus
        }

        casu _ tacet
    }

    redde IGNOTUM
}
