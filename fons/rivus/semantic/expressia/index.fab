# Expressia - Expression Resolution Dispatcher
#
# Routes expression AST nodes to their appropriate resolution functions.

§ ex "../resolvitor" importa Resolvitor
§ ex "../scopus" importa quaereSymbolum
§ ex "../typi" importa SemanticTypus, TEXTUS, NUMERUS, BIVALENS, NIHIL, IGNOTUM
§ ex "../typi" importa usitatumTypus, genericumTypus
§ ex "../typi" importa formaTypum, assignabileAd, typiAequales
§ ex "../errores" importa immutableAssignmentError, typeMismatchError, undefinedVariableError
§ ex "../../ast/expressia" importa Expressia, CatenaGradus
§ ex "../../ast/typus" importa TypusAnnotatio

§ ex "./primaria" importa resolveNomen, resolveLittera, resolveSeries, resolveObiectum
§ ex "./binaria" importa resolveBinaria
§ ex "./unaria" importa resolveUnaria
§ ex "./vocatio" importa resolveVocatio, resolveMembrum
§ ex "./alia" importa resolveClausura, resolveFingeExpr, resolveCedeExpr, resolveNovumExpr, resolveCondicio
§ ex "../sententia/declara" importa resolveTypusAnnotatio

# ============================================================================
# MAIN DISPATCHER
# ============================================================================

# Resolve any expression and return its semantic type
@ publica
functio resolveExpressia(Resolvitor r, Expressia expr) -> SemanticTypus {
    discerne expr {
        # Identifiers (variable references)
        casu Nomen {
            redde resolveNomen(r, expr)
        }

        # Literals (numbers, strings, booleans)
        casu Littera {
            redde resolveLittera(r, expr)
        }

        # Template literals (interpolated strings)
        casu LitteraExemplar {
            redde TEXTUS
        }

        # Binary expressions (+, -, *, /, ==, etc.)
        casu BinariaExpressia {
            redde resolveBinaria(r, expr)
        }

        # Unary expressions (!, -, non, etc.)
        casu UnariaExpressia {
            redde resolveUnaria(r, expr)
        }

        # Function calls
        casu VocatioExpressia {
            redde resolveVocatio(r, expr)
        }

        # Member access (obj.prop)
        casu MembrumExpressia {
            redde resolveMembrum(r, expr)
        }

        # Assignment (x = value)
        casu AssignatioExpressia ut as {
            redde resolveAssignatio(r, as)
        }

        # Await expression (cede)
        casu CedeExpressia {
            redde resolveCedeExpr(r, expr)
        }

        # New expression (novum)
        casu NovumExpressia {
            redde resolveNovumExpr(r, expr)
        }

        # Tagged union construction (finge)
        casu FingeExpressia {
            redde resolveFingeExpr(r, expr)
        }

        # Ternary conditional
        casu CondicioExpressia {
            redde resolveCondicio(r, expr)
        }

        # Range expression (1..10)
        casu AmbitusExpressia {
            redde genericumTypus("lista", [NUMERUS], falsum)
        }

        # Bit shift expression (x dextratum 3 -> x >> 3)
        casu TranslatioExpressia ut t {
            r.expressia(t.expressia)
            r.expressia(t.quantitas)
            redde NUMERUS
        }

        # Compile-time expression (praefixum { ... })
        casu PraefixumExpressia {
            # Compile-time expressions are evaluated at compile time
            # Type depends on context - return IGNOTUM for now
            redde IGNOTUM
        }

        # Spread element (...items)
        casu DispersioElementum ut d {
            # Spread expands an iterable - resolve the argument type
            redde r.expressia(d.argumentum)
        }

        # Object literal { key: value }
        casu ObiectumExpressia {
            redde resolveObiectum(r, expr)
        }

        # Array literal [1, 2, 3]
        casu SeriesExpressia {
            redde resolveSeries(r, expr)
        }

        # Clausura expression (clausura x: x + 1)
        casu ClausuraExpressia {
            redde resolveClausura(r, expr)
        }

        # Self reference (ego/hoc)
        casu EgoExpressia ut e {
            fixum a = r.analyzator()
            # ego type depends on enclosing class context
            si nonnihil a.currentGenusNomen {
                fixum genusNomen = a.currentGenusNomen qua textus
                # WHY: ego refers to an instance of the class, not the class definition itself.
                # Return Usitatum (instance type) not Genus (metatype).
                redde usitatumTypus(genusNomen, falsum)
            }
            # User error: ego used outside genus context
            a.error("'ego' can only be used inside a genus (class)", e.locus)
            redde IGNOTUM
        }

        # Type cast (expr qua Type)
        casu QuaExpressia ut q {
            r.expressia(q.expressia)
            # Resolve target type annotation and return it
            fixum targetTypus = resolveTypusAnnotatio(r, q.scopus)
            redde targetTypus
        }

        # Native type construction ([] innatum lista<T>, {} innatum tabula<K,V>)
        casu InnatumExpressia ut i {
            r.expressia(i.expressia)
            fixum targetTypus = resolveTypusAnnotatio(r, i.scopus)
            redde targetTypus
        }

        # Type check (expr est Type)
        casu EstExpressia {
            redde BIVALENS
        }

        # Format string (scriptum)
        casu ScriptumExpressia ut s {
            ex s.argumenta fixum arg {
                r.expressia(arg)
            }
            redde TEXTUS
        }

        # Read stdin (lege)
        casu LegeExpressia {
            redde TEXTUS
        }

        # Regex literal
        casu LitteraRegex {
            redde usitatumTypus("Regex", falsum)
        }

        # Collection DSL (ab items activus, ab items prima 5)
        casu AbExpressia ut abExpr {
            # WHY: Filtering doesn't change element type, only reduces collection.
            fixum fonsTypus = r.expressia(abExpr.fons)

            # Resolve filter condition if present (ubi form)
            si nonnihil abExpr.filtrum {
                fixum filtrum = abExpr.filtrum
                si filtrum.habetUbi {
                    r.expressia(filtrum.condicio)
                }
            }

            redde fonsTypus
        }

        # Type conversion (numeratum, fractatum, textatum, bivalentum)
        casu ConversioExpressia ut c {
            r.expressia(c.expressia)

            # Resolve fallback if present
            si nonnihil c.fallback {
                r.expressia(c.fallback qua Expressia)
            }

            # Resolve target type if present
            si nonnihil c.scopusTypus {
                resolveTypusAnnotatio(r, c.scopusTypus novum TypusAnnotatio)
            }

            # Return type depends on conversion operator
            elige c.signum qua textus {
                casu "numeratum" reddit NUMERUS
                casu "fractatum" reddit usitatumTypus("fractus", falsum)
                casu "textatum" reddit TEXTUS
                casu "bivalentum" reddit BIVALENS
            }

            # Unknown conversion operator - internal error
            mori scriptum("Internal error: unknown conversion operator '§'", c.signum)
        }
    }

    # Unhandled expression type - internal error
    mori "Internal error: unhandled expression type in resolveExpressia"
}

# Check an expression against an expected type.
#
# Foundation for bidirectional inference: uses `expected` to guide inference for
# otherwise-ambiguous expressions (notably empty arrays).
@ publica
functio checkExpressia(Resolvitor r, Expressia expr, de SemanticTypus expected) -> SemanticTypus {
    # If there is no meaningful expectation, fall back to synthesis.
    si typiAequales(expected, IGNOTUM) {
        redde resolveExpressia(r, expr)
    }

    # Empty array literal: use expected element type when available.
    discerne expr {
        casu SeriesExpressia ut s {
            discerne expected {
                casu Genericum ut g {
                    si g.nomen == "lista" et g.parametri.longitudo() == 1 {
                        si (s.elementa qua lista<Expressia>).longitudo() == 0 {
                            redde expected
                        }

                        # Check each element against the expected element type.
                        fixum elemExpected = g.parametri.primus()
                        ex (s.elementa qua lista<Expressia>) fixum elem {
                            r.check(elem, elemExpected)
                        }

                        redde expected
                    }
                }
                casu _ { }
            }
        }
        casu _ { }
    }

    # Default: synthesize without additional context.
    redde resolveExpressia(r, expr)
}

# ============================================================================
# HELPER RESOLVERS
# ============================================================================

# Resolve assignment expression
@ publica
functio resolveAssignatio(Resolvitor r, Expressia assignatioExpr) -> SemanticTypus {
    fixum a = r.analyzator()

    discerne assignatioExpr {
        casu AssignatioExpressia ut as {
            discerne as.sinister {
                casu Nomen ut n {
                    fixum symbolum = a.quaere(n.valor)
                    si nihil symbolum {
                        fixum err = undefinedVariableError(n.valor)
                        a.error(err.textus, n.locus, err.auxilium)
                        redde IGNOTUM
                    }

                    fixum dexterTypus = r.check(as.dexter, symbolum.semanticTypus)

                    si non symbolum.mutabilis {
                        fixum err = immutableAssignmentError(symbolum.nomen)
                        a.error(err.textus, as.locus, err.auxilium)
                    }

                    si non assignabileAd(dexterTypus, symbolum.semanticTypus) {
                        fixum err = typeMismatchError(formaTypum(dexterTypus), formaTypum(symbolum.semanticTypus))
                        a.error(err.textus, as.locus, err.auxilium)
                    }

                    redde symbolum.semanticTypus
                }

                casu MembrumExpressia ut m {
                    fixum dexterTypus = r.expressia(as.dexter)
                    # TODO: Resolve member types once genus metadata exists.
                    r.expressia(m.obiectum)
                    # WHY: Only resolve property for computed (indexed) access.
                    # For dot access (obj.field), property is a field name, not a variable.
                    si m.computatum {
                        r.expressia(m.proprietas)
                    }
                    redde dexterTypus
                }
                casu _ { }
            }

            redde r.expressia(as.dexter)
        }
        casu _ { }
    }

    redde IGNOTUM
}
