# Binaria - Binary Expression Resolution
#
# Handles arithmetic, comparison, and logical operators.

importa ex "../resolvitor" privata Resolvitor
importa ex "../typi" privata SemanticTypus
importa ex "../typi" privata TEXTUS
importa ex "../typi" privata NUMERUS
importa ex "../typi" privata BIVALENS
importa ex "../typi" privata IGNOTUM
importa ex "../typi" privata formaTypum
importa ex "../typi" privata sineNullabilitate
importa ex "../errores" privata incompatibleComparisonError
importa ex "../errores" privata nihilEqualityWarning
importa ex "../../ast/expressia" privata Expressia
importa ex "../../ast/expressia" privata LitteraGenus

# ============================================================================
# BINARY EXPRESSION RESOLUTION
# ============================================================================

# Resolve a binary expression
@ publica
functio resolveBinaria(Resolvitor r, Expressia binariaExpr) -> SemanticTypus {
    fixum a = r.analyzator()

    discerne binariaExpr {
        casu BinariaExpressia ut b {
            fixum sinisterTypus = r.expressia(b.sinister)
            fixum dexterTypus = r.expressia(b.dexter)

            # Arithmetic operators: +, -, *, /, %
            si estArithmeticum(b.signum) {
                # String concatenation with +
                si b.signum == "+" {
                    discerne sinisterTypus {
                        casu Primitivum ut p {
                            si p.nomen == "textus" {
                                redde TEXTUS
                            }
                        }
                        ceterum tacet
                    }
                }

                # Numeric arithmetic - preserve type when both operands match
                discerne sinisterTypus {
                    casu Primitivum ut ps {
                        discerne dexterTypus {
                            casu Primitivum ut pd {
                                si estNumericum(ps.nomen) et estNumericum(pd.nomen) {
                                    # Same type: preserve it
                                    si ps.nomen == pd.nomen {
                                        redde sinisterTypus
                                    }
                                    # Mixed numeric: use left type
                                    redde sinisterTypus
                                }
                            }
                            ceterum tacet
                        }
                    }
                    casu _ tacet
                }

                # Default to numerus
                redde NUMERUS
            }

            # Comparison operators: <, >, <=, >=
            si estComparatio(b.signum) {
                # Check for incompatible comparison
                discerne sinisterTypus {
                    casu Primitivum ut ps {
                        discerne dexterTypus {
                            casu Primitivum ut pd {
                                si ps.nomen != pd.nomen {
                                    fixum err = incompatibleComparisonError(
                                        formaTypum(sinisterTypus),
                                        formaTypum(dexterTypus),
                                        b.signum
                                    )
                                    a.error(err.textus, b.locus, err.auxilium)
                                }
                            }
                            ceterum tacet
                        }
                    }
                    casu _ tacet
                }

                redde BIVALENS
            }

            # Equality operators: ==, !=
            si b.signum inter ["==", "!="] {
                # Warn about == nihil / != nihil patterns
                fixum sinisterNihil = estNihilLittera(b.sinister)
                fixum dexterNihil = estNihilLittera(b.dexter)

                si sinisterNihil aut dexterNihil {
                    fixum warn = nihilEqualityWarning(b.signum)
                    a.error(warn.textus, b.locus, warn.auxilium)
                }

                redde BIVALENS
            }

            # Logical operators: &&, ||, et, aut
            si estLogicum(b.signum) {
                redde BIVALENS
            }

            # Bitwise operators: &, |, ^
            si estBitwise(b.signum) {
                # Both operands must be numerus (integer)
                varia sinisterOk = falsum
                varia dexterOk = falsum

                discerne sinisterTypus {
                    casu Primitivum ut p {
                        sinisterOk = p.nomen == "numerus"
                    }
                    casu _ tacet
                }

                discerne dexterTypus {
                    casu Primitivum ut p {
                        dexterOk = p.nomen == "numerus"
                    }
                    casu _ tacet
                }

                si non sinisterOk aut non dexterOk {
                    a.error(
                        scriptum("Bitwise operator 'ยง' requires numerus operands, got ยง and ยง", b.signum, formaTypum(sinisterTypus), formaTypum(dexterTypus)),
                        b.locus,
                        "Bitwise operators only work on integers"
                    )
                }

                redde NUMERUS
            }

            # Nullish coalescing: vel
            si b.signum == "vel" {
                redde sineNullabilitate(sinisterTypus)
            }

            # EDGE: Unknown operator - return ignotum to avoid nil leakage.
            redde IGNOTUM
        }
        ceterum {
            # EDGE: Non-binary expression - should not occur with correct AST structure
            redde IGNOTUM
        }
    }
}

# ============================================================================
# HELPERS
# ============================================================================

@ publica
functio estArithmeticum(textus signum) -> bivalens {
    redde signum inter ["+", "-", "*", "/", "%"]
}

@ publica
functio estComparatio(textus signum) -> bivalens {
    redde signum inter ["<", ">", "<=", ">="]
}

@ publica
functio estLogicum(textus signum) -> bivalens {
    redde signum inter ["&&", "||", "et", "aut"]
}

@ publica
functio estBitwise(textus signum) -> bivalens {
    redde signum inter ["&", "|", "^"]
}

@ publica
functio estNumericum(textus nomen) -> bivalens {
    redde nomen inter ["numerus", "fractus", "decimus", "magnus"]
}

# Check if an expression is a nihil literal
functio estNihilLittera(Expressia expr) -> bivalens {
    discerne expr {
        casu Littera ut lit {
            redde lit.species == LitteraGenus.Nihil
        }
        ceterum {
            redde falsum
        }
    }
}
