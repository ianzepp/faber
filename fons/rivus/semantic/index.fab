# Semantic - Entry Point
#
# Performs semantic analysis on the AST. Resolves types, builds symbol tables.

§ ex "./resolvitor" importa Resolvitor
§ ex "./nucleus" importa Analyzator, SemanticResultatum, novumAnalyzator, DiscretioDeclInfo
§ ex "./typi" importa SemanticTypus, IGNOTUM, VACUUM, functioTypus, usitatumTypus
§ ex "./scopus" importa Symbolum, SymbolumSpecies
§ ex "./modulus" importa estLocaleImportum, estNormaImportum, resolveModulum, ModulusExportum
§ ex "./modulus" importa estDependentiaImportum, resolveDependentiaPath
§ ex "./dependentia" importa extractDependentiae
§ ex "./expressia/index" importa resolveExpressia
§ ex "./expressia/index" importa checkExpressia
§ ex "./sententia/index" importa analyzeSententia
§ ex "./sententia/declara" importa resolveTypusAnnotatio
§ ex "../ast/radix" importa Programma, SectioAnnotatio
§ ex "../ast/expressia" importa Expressia
§ ex "../ast/sententia" importa Sententia, MorphologiaDeclaratio
§ ex "../ast/typus" importa TypusAnnotatio
§ ex "../parser/morphologia" importa parseMethodum

# ============================================================================
# RESOLVITOR IMPLEMENTATION
# ============================================================================

# Concrete implementation of the Resolvitor pactum
@ publica
genus ResolvitorImpl implet Resolvitor {
    Analyzator a

    @ publica
    functio analyzator() -> Analyzator {
        redde ego.a
    }

    @ publica
    functio synthesize(de Expressia expr) -> SemanticTypus {
        redde resolveExpressia(ego qua Resolvitor, expr)
    }

    @ publica
    functio check(de Expressia expr, de SemanticTypus expected) -> SemanticTypus {
        redde checkExpressia(ego qua Resolvitor, expr, expected)
    }

    @ publica
    functio expressia(de Expressia expr) -> SemanticTypus {
        redde ego.synthesize(expr)
    }

    @ publica
    functio sententia(de Sententia stmt) -> vacuum {
        analyzeSententia(ego qua Resolvitor, stmt)
    }
}

# Create a new Resolvitor
@ publica
functio novumResolvitor(in Analyzator a) -> Resolvitor {
    redde (novum ResolvitorImpl { a: a }) qua Resolvitor
}

# ============================================================================
# MAIN ENTRY POINT
# ============================================================================

# Merge manifest sectiones with source file sectiones
# Manifest sectiones come first, source file can override/extend
functio mergeSectiones(
    de lista<SectioAnnotatio>? manifest,
    de lista<SectioAnnotatio>? source
) -> lista<SectioAnnotatio> {
    varia result = [] innatum lista<SectioAnnotatio>

    si nonnihil manifest {
        ex manifest fixum s { result.adde(s) }
    }

    si nonnihil source {
        ex source fixum s { result.adde(s) }
    }

    redde result
}

# Perform semantic analysis on a program
# viaIngressus: optional path to the entry file (needed for local import resolution)
# manifestSectiones: optional sectiones from project manifest (faber.fab)
@ publica
functio analyze(
    de Programma programma,
    de lista<SectioAnnotatio>? manifestSectiones,
    si de textus viaIngressus
) -> SemanticResultatum {
    # Merge manifest and source sectiones
    fixum mergedSectiones = mergeSectiones(manifestSectiones, programma.sectiones)

    # Extract dependency registry from merged sectiones
    fixum dependentiae = extractDependentiae(mergedSectiones)

    # Create analyzer state with registry
    fixum a = novumAnalyzator(dependentiae, viaIngressus)
    fixum r = novumResolvitor(a)

    # Phase 1: Predeclare all top-level names
    # (allows forward references)
    ex programma.corpus fixum stmt {
        predeclare(r, stmt)
    }

    # Phase 2: Analyze all statements
    ex programma.corpus fixum stmt {
        r.sententia(stmt)
    }

    # Return result
    redde {
        programma: programma,
        errores: a.errores
    } novum SemanticResultatum
}

# ============================================================================
# PREDECLARATION
# ============================================================================

# Predeclare a top-level statement (registers placeholder types)
@ publica
functio predeclare(in Resolvitor r, de Sententia stmt) -> vacuum {
    fixum a = r.analyzator()

    discerne stmt {
        # Function declaration - register name with function type
        casu FunctioDeclaratio ut f {
            # Build placeholder function type
            varia paramTypi = [] innatum lista<SemanticTypus>
            ex f.parametra fixum param {
                si nonnihil param.typus {
                    paramTypi.adde(resolveTypusAnnotatio(r, param.typus novum TypusAnnotatio))
                } secus {
                    a.moneIgnotum("predeclare: missing function parameter type annotation", param.locus)
                    paramTypi.adde(IGNOTUM)
                }
            }
            # WHY: Preserve declared return types so callers can infer receiver types
            # from forward function calls (critical for norma method translation).
            varia reditusTypus = VACUUM
            si nonnihil f.typusReditus {
                reditusTypus = resolveTypusAnnotatio(r, f.typusReditus novum TypusAnnotatio)
            }
            fixum fnTypus = functioTypus(paramTypi, reditusTypus, f.asynca, falsum)

            a.definie({
                nomen: f.nomen,
                semanticTypus: fnTypus,
                species: SymbolumSpecies.Functio,
                mutabilis: falsum,
                locus: f.locus
            } novum Symbolum)
        }

        # Genus declaration - register name with user type
        casu GenusDeclaratio ut g {
            a.definie({
                nomen: g.nomen,
                semanticTypus: usitatumTypus(g.nomen, falsum),
                species: SymbolumSpecies.Genus,
                mutabilis: falsum,
                locus: g.locus
            } novum Symbolum)

            ex g.methodi fixum f {
                si nonnihil f.morphologia {
                    fixum parsed = parseMethodum(f.nomen)
                    si nonnihil parsed {
                        fixum nota = f.morphologia novum MorphologiaDeclaratio
                        a.addeMorphologiam(g.nomen, parsed.radix, nota.formae)
                    }
                }
            }
        }

        # Pactum declaration - register name with user type
        casu PactumDeclaratio ut p {
            a.definie({
                nomen: p.nomen,
                semanticTypus: usitatumTypus(p.nomen, falsum),
                species: SymbolumSpecies.Pactum,
                mutabilis: falsum,
                locus: p.locus
            } novum Symbolum)

            ex p.methodi fixum methodus {
                si nonnihil methodus.morphologia {
                    fixum parsed = parseMethodum(methodus.nomen)
                    si nonnihil parsed {
                        fixum nota = methodus.morphologia novum MorphologiaDeclaratio
                        a.addeMorphologiam(p.nomen, parsed.radix, nota.formae)
                    }
                }
            }
        }

        # Ordo declaration - register name with user type
        casu OrdoDeclaratio ut o {
            a.definie({
                nomen: o.nomen,
                semanticTypus: usitatumTypus(o.nomen, falsum),
                species: SymbolumSpecies.Ordo,
                mutabilis: falsum,
                locus: o.locus
            } novum Symbolum)
        }

        # Discretio declaration - register name with user type
        casu DiscretioDeclaratio ut d {
            a.definie({
                nomen: d.nomen,
                semanticTypus: usitatumTypus(d.nomen, falsum),
                species: SymbolumSpecies.TypusAlias,
                mutabilis: falsum,
                locus: d.locus
            } novum Symbolum)
        }

        # Typus alias - register name with user type
        casu TypusAliasDeclaratio ut t {
            a.definie({
                nomen: t.nomen,
                semanticTypus: usitatumTypus(t.nomen, falsum),
                species: SymbolumSpecies.TypusAlias,
                mutabilis: falsum,
                locus: t.locus
            } novum Symbolum)
        }

        # Import declaration - resolve module and register symbols
        casu ImportaSententia ut imp {
            # Skip norma imports (handled by intrinsics)
            si estNormaImportum(imp.fons) {
                # Norma symbols are defined via definieIntrinsica()
                # No additional work needed
            }
            # Handle dependentia alias imports (alias:subpath)
            sin estDependentiaImportum(imp.fons) {
                si nihil a.viaIngressus {
                    a.error(scriptum("Cannot resolve dependentia import without file context: §", imp.fons), imp.locus)
                } secus {
                    fixum resolvedPath = resolveDependentiaPath(imp.fons, a.dependentiae)
                    si nihil resolvedPath {
                        # Extract alias for error message
                        fixum partes = imp.fons.divide(":")
                        a.error(scriptum("Unknown dependency alias: §", partes[0]), imp.locus)
                    } secus {
                        # Use resolved path with resolveModulum (same as local import)
                        fixum modulus = resolveModulum(
                            resolvedPath qua textus,
                            a.viaIngressus qua textus,
                            a.modulusCache,
                            a.modulusInProgressu
                        )

                        si nihil modulus {
                            a.error(scriptum("Module not found: § (resolved from §)", resolvedPath, imp.fons), imp.locus)
                        } secus {
                            # Named imports: ex "alias:path" importa foo, bar
                            ex imp.specificatores fixum spec {
                                si nonnihil modulus.exporta[spec.importatum] {
                                    fixum exportum = modulus.exporta[spec.importatum] novum ModulusExportum
                                    a.definie({
                                        nomen: spec.locale,
                                        semanticTypus: exportum.typus,
                                        species: exportum.species,
                                        mutabilis: falsum,
                                        locus: spec.locus
                                    } novum Symbolum)

                                    si nonnihil modulus.discretiones[spec.importatum] {
                                        a.discretioIndex[spec.locale] = modulus.discretiones[spec.importatum] novum DiscretioDeclInfo
                                    }

                                    # Import variant types for discretio
                                    fixum prefix = spec.importatum + "."
                                    ex modulus.exporta.claves() fixum nomen {
                                        si nomen.startsWith(prefix) {
                                            fixum exportum = modulus.exporta[nomen] novum ModulusExportum
                                            fixum suffix = nomen.slice(prefix.length)
                                            fixum qualNomen = scriptum("§.§", spec.locale, suffix)

                                            si nihil a.scopus.symbola[qualNomen] {
                                                a.definie({
                                                    nomen: qualNomen,
                                                    semanticTypus: exportum.typus,
                                                    species: exportum.species,
                                                    mutabilis: falsum,
                                                    locus: exportum.locus
                                                } novum Symbolum)
                                            }
                                        }
                                    }
                                } secus {
                                    a.error(scriptum("'§' is not exported from '§'", spec.importatum, imp.fons), spec.locus)
                                }
                            }
                        }
                    }
                }
            }
            # Handle local file imports
            sin estLocaleImportum(imp.fons) {
                # Need file path context for resolution
                si nihil a.viaIngressus {
                    a.error(scriptum("Cannot resolve local import without file context: §", imp.fons), imp.locus)
                } secus {
                    fixum modulus = resolveModulum(
                        imp.fons,
                        a.viaIngressus qua textus,
                        a.modulusCache,
                        a.modulusInProgressu
                    )

                    si nihil modulus {
                        a.error(scriptum("Module not found: §", imp.fons), imp.locus)
                    } secus {
                        # Wildcard import: ex "./x" importa * ut alias
                        si imp.totum {
                            si nonnihil imp.totumAlias {
                                # Define namespace alias
                                a.definie({
                                    nomen: imp.totumAlias qua textus,
                                    semanticTypus: IGNOTUM,
                                    species: SymbolumSpecies.Variabilis,
                                    mutabilis: falsum,
                                    locus: imp.locus
                                } novum Symbolum)
                            }
                            # Also add all individual exports to scope
                            ex modulus.exporta.claves() fixum nomen {
                                fixum exportum = modulus.exporta[nomen] novum ModulusExportum
                                a.definie({
                                    nomen: exportum.nomen,
                                    semanticTypus: exportum.typus,
                                    species: exportum.species,
                                    mutabilis: falsum,
                                    locus: exportum.locus
                                } novum Symbolum)
                            }
                        } secus {
                            # Named imports: ex "./x" importa foo, bar ut b
                            ex imp.specificatores fixum spec {
                                si nonnihil modulus.exporta[spec.importatum] {
                                    fixum exportum = modulus.exporta[spec.importatum] novum ModulusExportum
                                    a.definie({
                                        nomen: spec.locale,  # Use local alias if provided
                                        semanticTypus: exportum.typus,
                                        species: exportum.species,
                                        mutabilis: falsum,
                                        locus: spec.locus
                                    } novum Symbolum)

                                    # Record discretio metadata under the local alias, if present.
                                    si nonnihil modulus.discretiones[spec.importatum] {
                                        a.discretioIndex[spec.locale] = modulus.discretiones[spec.importatum] novum DiscretioDeclInfo
                                    }

                                    # WHY: If a discretio type is imported by name, also import its
                                    # variant types as `LocalName.VariansNomen` so `discerne` can
                                    # resolve bindings and enable norma translations.
                                    fixum prefix = spec.importatum + "."
                                    ex modulus.exporta.claves() fixum nomen {
                                        si nomen.startsWith(prefix) {
                                            fixum exportum = modulus.exporta[nomen] novum ModulusExportum
                                            fixum suffix = nomen.slice(prefix.length)
                                            fixum qualNomen = scriptum("§.§", spec.locale, suffix)

                                            # Avoid duplicate definitions if multiple imports overlap.
                                            si nihil a.scopus.symbola[qualNomen] {
                                                a.definie({
                                                    nomen: qualNomen,
                                                    semanticTypus: exportum.typus,
                                                    species: exportum.species,
                                                    mutabilis: falsum,
                                                    locus: exportum.locus
                                                } novum Symbolum)
                                            }
                                        }
                                    }
                                } secus {
                                    a.error(scriptum("'§' is not exported from '§'", spec.importatum, imp.fons), spec.locus)
                                }
                            }
                        }
                    }
                }
            }
            # External package imports pass through to codegen unchanged
        }

        # Other statements don't need predeclaration
        casu _ { }
    }
}
