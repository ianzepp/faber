# Semantic - Entry Point
#
# Performs semantic analysis on the AST. Resolves types, builds symbol tables.

importa ex "./resolvitor" privata Resolvitor
importa ex "./nucleus" privata Analyzator
importa ex "./nucleus" privata SemanticResultatum
importa ex "./nucleus" privata novumAnalyzator
importa ex "./nucleus" privata DiscretioDeclInfo
importa ex "./typi" privata SemanticTypus
importa ex "./typi" privata IGNOTUM
importa ex "./typi" privata VACUUM
importa ex "./typi" privata functioTypus
importa ex "./typi" privata usitatumTypus
importa ex "./scopus" privata Symbolum
importa ex "./scopus" privata SymbolumSpecies
importa ex "./modulus" privata estLocaleImportum
importa ex "./modulus" privata estNormaImportum
importa ex "./modulus" privata resolveModulum
importa ex "./modulus" privata ModulusExportum
importa ex "./modulus" privata estDependentiaImportum
importa ex "./modulus" privata resolveDependentiaPath
importa ex "./dependentia" privata extractDependentiae
importa ex "./expressia/index" privata resolveExpressia
importa ex "./expressia/index" privata checkExpressia
importa ex "./sententia/index" privata analyzeSententia
importa ex "./sententia/declara" privata resolveTypusAnnotatio
importa ex "../ast/radix" privata Programma
importa ex "../ast/radix" privata SectioAnnotatio
importa ex "../ast/expressia" privata Expressia
importa ex "../ast/sententia" privata Sententia
importa ex "../ast/sententia" privata MorphologiaDeclaratio
importa ex "../ast/typus" privata TypusAnnotatio
importa ex "../parser/morphologia" privata parseMethodum

# ============================================================================
# RESOLVITOR IMPLEMENTATION
# ============================================================================

# Concrete implementation of the Resolvitor pactum
@ publica
genus ResolvitorImpl implet Resolvitor {
    Analyzator a

    @ publica
    functio analyzator() -> Analyzator {
        redde ego.a
    }

    @ publica
    functio synthesize(de Expressia expr) -> SemanticTypus {
        redde resolveExpressia(ego qua Resolvitor, expr)
    }

    @ publica
    functio check(de Expressia expr, de SemanticTypus expected) -> SemanticTypus {
        redde checkExpressia(ego qua Resolvitor, expr, expected)
    }

    @ publica
    functio expressia(de Expressia expr) -> SemanticTypus {
        redde ego.synthesize(expr)
    }

    @ publica
    functio sententia(de Sententia stmt) -> vacuum {
        analyzeSententia(ego qua Resolvitor, stmt)
    }
}

# Create a new Resolvitor
@ publica
functio novumResolvitor(in Analyzator a) -> Resolvitor {
    redde (novum ResolvitorImpl { a: a }) qua Resolvitor
}

# ============================================================================
# MAIN ENTRY POINT
# ============================================================================

# Merge manifest sectiones with source file sectiones
# Manifest sectiones come first, source file can override/extend
functio mergeSectiones(
    si de lista<SectioAnnotatio> manifest,
    si de lista<SectioAnnotatio> source
) -> lista<SectioAnnotatio> {
    varia result = [] innatum lista<SectioAnnotatio>

    si nonnihil manifest {
        itera ex manifest fixum s { result.appende(s) }
    }

    si nonnihil source {
        itera ex source fixum s { result.appende(s) }
    }

    redde result
}

# Perform semantic analysis on a program
# viaIngressus: optional path to the entry file (needed for local import resolution)
# manifestSectiones: optional sectiones from project manifest (faber.fab)
@ publica
functio analyze(
    de Programma programma,
    si de lista<SectioAnnotatio> manifestSectiones,
    si de textus viaIngressus
) -> SemanticResultatum {
    # Merge manifest and source sectiones
    fixum mergedSectiones = mergeSectiones(manifestSectiones, programma.sectiones)

    # Extract dependency registry from merged sectiones
    fixum dependentiae = extractDependentiae(mergedSectiones)

    # Create analyzer state with registry
    fixum a = novumAnalyzator(dependentiae, viaIngressus)
    fixum r = novumResolvitor(a)

    # Phase 1: Predeclare all top-level names
    # (allows forward references)
    itera ex programma.corpus fixum stmt {
        predeclare(r, stmt)
    }

    # Phase 2: Analyze all statements
    itera ex programma.corpus fixum stmt {
        r.sententia(stmt)
    }

    # Return result
    redde {
        programma: programma,
        errores: a.errores
    } novum SemanticResultatum
}

# ============================================================================
# PREDECLARATION
# ============================================================================

# Predeclare a top-level statement (registers placeholder types)
@ publica
functio predeclare(in Resolvitor r, de Sententia stmt) -> vacuum {
    fixum a = r.analyzator()

    discerne stmt {
        # Function declaration - register name with function type
        casu FunctioDeclaratio ut f {
            # Build placeholder function type
            varia paramTypi = [] innatum lista<SemanticTypus>
            itera ex f.parametra fixum param {
                si nonnihil param.typus {
                    paramTypi.appende(resolveTypusAnnotatio(r, param.typus novum TypusAnnotatio))
                } secus {
                    a.error("Function parameter missing type annotation", param.locus, "Use type-first syntax: functio f(numerus x) { ... }")
                    paramTypi.appende(IGNOTUM)
                }
            }
            # WHY: Preserve declared return types so callers can infer receiver types
            # from forward function calls (critical for norma method translation).
            varia reditusTypus = VACUUM
            si nonnihil f.typusReditus {
                reditusTypus = resolveTypusAnnotatio(r, f.typusReditus novum TypusAnnotatio)
            }
            fixum fnTypus = functioTypus(paramTypi, reditusTypus, f.asynca, falsum)

            a.definie({
                nomen: f.nomen,
                semanticTypus: fnTypus,
                species: SymbolumSpecies.Functio,
                mutabilis: falsum,
                locus: f.locus
            } novum Symbolum)
        }

        # Genus declaration - register name with user type
        casu GenusDeclaratio ut g {
            a.definie({
                nomen: g.nomen,
                semanticTypus: usitatumTypus(g.nomen, falsum),
                species: SymbolumSpecies.Genus,
                mutabilis: falsum,
                locus: g.locus
            } novum Symbolum)

            itera ex g.methodi fixum f {
                si nonnihil f.morphologia {
                    fixum parsed = parseMethodum(f.nomen)
                    si nonnihil parsed {
                        fixum nota = f.morphologia novum MorphologiaDeclaratio
                        a.addeMorphologiam(g.nomen, parsed.radix, nota.formae)
                    }
                }
            }
        }

        # Pactum declaration - register name with user type
        casu PactumDeclaratio ut p {
            a.definie({
                nomen: p.nomen,
                semanticTypus: usitatumTypus(p.nomen, falsum),
                species: SymbolumSpecies.Pactum,
                mutabilis: falsum,
                locus: p.locus
            } novum Symbolum)

            itera ex p.methodi fixum methodus {
                si nonnihil methodus.morphologia {
                    fixum parsed = parseMethodum(methodus.nomen)
                    si nonnihil parsed {
                        fixum nota = methodus.morphologia novum MorphologiaDeclaratio
                        a.addeMorphologiam(p.nomen, parsed.radix, nota.formae)
                    }
                }
            }
        }

        # Ordo declaration - register name with user type
        casu OrdoDeclaratio ut o {
            a.definie({
                nomen: o.nomen,
                semanticTypus: usitatumTypus(o.nomen, falsum),
                species: SymbolumSpecies.Ordo,
                mutabilis: falsum,
                locus: o.locus
            } novum Symbolum)
        }

        # Discretio declaration - register name with user type
        casu DiscretioDeclaratio ut d {
            a.definie({
                nomen: d.nomen,
                semanticTypus: usitatumTypus(d.nomen, falsum),
                species: SymbolumSpecies.TypusAlias,
                mutabilis: falsum,
                locus: d.locus
            } novum Symbolum)
        }

        # Typus alias - register name with user type
        casu TypusAliasDeclaratio ut t {
            a.definie({
                nomen: t.nomen,
                semanticTypus: usitatumTypus(t.nomen, falsum),
                species: SymbolumSpecies.TypusAlias,
                mutabilis: falsum,
                locus: t.locus
            } novum Symbolum)
        }

        # Import declaration - resolve module and register symbols
        # New single-import syntax: importa ex "path" privata|publica T [ut alias]
        casu ImportaSententia ut imp {
            # Skip norma imports (handled by intrinsics)
            si estNormaImportum(imp.fons) {
                # Norma symbols are defined via definieIntrinsica()
                # No additional work needed
            }
            # Handle dependentia alias imports (alias:subpath)
            sin estDependentiaImportum(imp.fons) {
                si nihil a.viaIngressus {
                    a.error(scriptum("Cannot resolve dependentia import without file context: §", imp.fons), imp.locus)
                } secus {
                    fixum resolvedPath = resolveDependentiaPath(imp.fons, a.dependentiae)
                    si nihil resolvedPath {
                        # Extract alias for error message
                        fixum partes = imp.fons.divide(":")
                        a.error(scriptum("Unknown dependency alias: §", partes[0]), imp.locus)
                    } secus {
                        # Use resolved path with resolveModulum (same as local import)
                        fixum modulus = resolveModulum(
                            resolvedPath qua textus,
                            a.viaIngressus qua textus,
                            a.modulusCache,
                            a.modulusInProgressu
                        )

                        si nihil modulus {
                            a.error(scriptum("Module not found: § (resolved from §)", resolvedPath, imp.fons), imp.locus)
                        } secus {
                            # Single named import
                            si nonnihil imp.importatum {
                                fixum importatum = imp.importatum qua textus
                                si nonnihil modulus.exporta[importatum] {
                                    fixum exportum = modulus.exporta[importatum] qua ModulusExportum
                                    a.definie({
                                        nomen: imp.locale,
                                        semanticTypus: exportum.typus,
                                        species: exportum.species,
                                        mutabilis: falsum,
                                        locus: imp.locus
                                    } novum Symbolum)

                                    si nonnihil modulus.discretiones[importatum] {
                                        a.discretioIndex[imp.locale] = modulus.discretiones[importatum] qua DiscretioDeclInfo
                                    }

                                    # Import variant types for discretio
                                    fixum prefix = importatum + "."
                                    itera ex modulus.exporta.claves() fixum nomen {
                                        si nomen.startsWith(prefix) {
                                            fixum exportum = modulus.exporta[nomen] qua ModulusExportum
                                            fixum suffix = nomen.slice(prefix.length)
                                            fixum qualNomen = scriptum("§.§", imp.locale, suffix)

                                            si nihil a.scopus.symbola[qualNomen] {
                                                a.definie({
                                                    nomen: qualNomen,
                                                    semanticTypus: exportum.typus,
                                                    species: exportum.species,
                                                    mutabilis: falsum,
                                                    locus: exportum.locus
                                                } novum Symbolum)
                                            }
                                        }
                                    }
                                } secus {
                                    a.error(scriptum("'§' is not exported from '§'", importatum, imp.fons), imp.locus)
                                }
                            }
                        }
                    }
                }
            }
            # Handle local file imports
            sin estLocaleImportum(imp.fons) {
                # Need file path context for resolution
                si nihil a.viaIngressus {
                    a.error(scriptum("Cannot resolve local import without file context: §", imp.fons), imp.locus)
                } secus {
                    fixum modulus = resolveModulum(
                        imp.fons,
                        a.viaIngressus qua textus,
                        a.modulusCache,
                        a.modulusInProgressu
                    )

                    si nihil modulus {
                        a.error(scriptum("Module not found: §", imp.fons), imp.locus)
                    } secus {
                        # Wildcard import: importa ex "path" privata * ut alias
                        si imp.totum {
                            # Define namespace alias
                            a.definie({
                                nomen: imp.locale,
                                semanticTypus: IGNOTUM,
                                species: SymbolumSpecies.Variabilis,
                                mutabilis: falsum,
                                locus: imp.locus
                            } novum Symbolum)
                            # Also add all individual exports to scope
                            itera ex modulus.exporta.claves() fixum nomen {
                                fixum exportum = modulus.exporta[nomen] qua ModulusExportum
                                a.definie({
                                    nomen: exportum.nomen,
                                    semanticTypus: exportum.typus,
                                    species: exportum.species,
                                    mutabilis: falsum,
                                    locus: exportum.locus
                                } novum Symbolum)
                            }
                        } secus {
                            # Single named import: importa ex "path" privata T [ut alias]
                            si nonnihil imp.importatum {
                                fixum importatum = imp.importatum qua textus
                                si nonnihil modulus.exporta[importatum] {
                                    fixum exportum = modulus.exporta[importatum] qua ModulusExportum
                                    a.definie({
                                        nomen: imp.locale,
                                        semanticTypus: exportum.typus,
                                        species: exportum.species,
                                        mutabilis: falsum,
                                        locus: imp.locus
                                    } novum Symbolum)

                                    # Record discretio metadata under the local alias
                                    si nonnihil modulus.discretiones[importatum] {
                                        a.discretioIndex[imp.locale] = modulus.discretiones[importatum] qua DiscretioDeclInfo
                                    }

                                    # Import variant types for discretio
                                    fixum prefix = importatum + "."
                                    itera ex modulus.exporta.claves() fixum nomen {
                                        si nomen.startsWith(prefix) {
                                            fixum exportum = modulus.exporta[nomen] qua ModulusExportum
                                            fixum suffix = nomen.slice(prefix.length)
                                            fixum qualNomen = scriptum("§.§", imp.locale, suffix)

                                            si nihil a.scopus.symbola[qualNomen] {
                                                a.definie({
                                                    nomen: qualNomen,
                                                    semanticTypus: exportum.typus,
                                                    species: exportum.species,
                                                    mutabilis: falsum,
                                                    locus: exportum.locus
                                                } novum Symbolum)
                                            }
                                        }
                                    }
                                } secus {
                                    a.error(scriptum("'§' is not exported from '§'", importatum, imp.fons), imp.locus)
                                }
                            }
                        }
                    }
                }
            }
            # External package imports pass through to codegen unchanged
        }

        # Other statements don't need predeclaration
        casu _ tacet
    }
}
