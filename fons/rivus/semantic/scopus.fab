# Scopus - Symbol Tables and Lexical Scoping
#
# Implements lexical scoping with a chain of symbol tables for name resolution.

ยง ex "./typi" importa SemanticTypus
ยง ex "../ast/positio" importa Locus

# =============================================================================
# SYMBOL DEFINITIONS
# =============================================================================

# Kind of binding this symbol represents
@ publica
ordo SymbolumSpecies {
    Variabilis                  # varia/fixum
    Functio                     # function
    Parametrum                  # function parameter
    TypusAlias                  # type alias
    Ordo                        # enum
    Genus                       # class/struct
    Pactum                      # interface
}

# Kind of scope this is
@ publica
ordo ScopusSpecies {
    Globalis                    # global/module scope
    Functio                     # function scope
    Massa                       # block scope
}

# A symbol binding in the symbol table
@ publica
genus Symbolum {
    textus nomen                    # binding name
    SemanticTypus semanticTypus     # resolved type
    SymbolumSpecies species         # kind of symbol
    bivalens mutabilis              # true if varia (mutable)
    Locus locus                     # declaration location
}

# A lexical scope containing symbol bindings
@ publica
genus Scopus {
    tabula<textus, Symbolum> symbola  # name -> symbol bindings
    Scopus? parens                    # parent scope (nil for global)
    ScopusSpecies species             # kind of scope
}

# =============================================================================
# SCOPE MANAGEMENT
# =============================================================================

# Create the global scope
@ publica
functio creaScopumGlobalem() -> Scopus {
    redde {
        symbola: {} innatum tabula<textus, Symbolum>,
        parens: nihil,
        species: ScopusSpecies.Globalis
    } novum Scopus
}

# Create a child scope
@ publica
functio creaScopum(de Scopus parentScopus, ScopusSpecies scopusSpecies) -> Scopus {
    redde {
        symbola: {} innatum tabula<textus, Symbolum>,
        parens: parentScopus,
        species: scopusSpecies
    } novum Scopus
}

# Define a symbol in current scope (returns error if duplicate)
@ publica
functio definieSymbolum(in Scopus scopus, ex Symbolum symbolum) -> textus? {
    fixum existens = scopus.symbola[symbolum.nomen]
    si nonnihil existens {
        redde scriptum("'ยง' is already defined at line ยง", symbolum.nomen, existens.locus.linea)
    }

    scopus.symbola[symbolum.nomen] = symbolum
    redde nihil
}

# Look up a symbol by name, walking up the scope chain
@ publica
functio quaereSymbolum(de Scopus scopus, de textus nomen) -> Symbolum? {
    si nonnihil scopus.symbola[nomen] {
        redde scopus.symbola[nomen]
    }

    # Walk up the scope chain
    si nonnihil scopus.parens {
        redde quaereSymbolum(scopus.parens novum Scopus, nomen)
    }

    redde nihil
}

# Look up a symbol only in the current scope (no parent traversal)
@ publica
functio quaereSymbolumLocale(de Scopus scopus, de textus nomen) -> Symbolum? {
    si nonnihil scopus.symbola[nomen] {
        redde scopus.symbola[nomen]
    }

    redde nihil
}

# Update an existing symbol's type (for two-pass analysis)
@ publica
functio renovaSymbolumTypum(in Scopus scopus, de textus nomen, ex SemanticTypus novusTypus) -> bivalens {
    si nihil scopus.symbola[nomen] {
        redde falsum
    }

    fixum symbolum = scopus.symbola[nomen]
    symbolum.semanticTypus = novusTypus
    scopus.symbola[nomen] = symbolum
    redde verum
}

# Find the enclosing function scope (for return type checking)
@ publica
functio inveniScopumFunctionis(de Scopus scopus) -> Scopus? {
    si scopus.species == ScopusSpecies.Functio {
        redde scopus
    }

    # parens is guaranteed non-nil here due to the check
    si nonnihil scopus.parens {
        redde inveniScopumFunctionis(scopus.parens novum Scopus)
    }

    redde nihil
}
