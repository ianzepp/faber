# Nucleus - Core Analyzer State and Infrastructure
#
# Provides the Analyzator genus that manages semantic analysis state.

importa ex "./typi" privata SemanticTypus
importa ex "./typi" privata TEXTUS
importa ex "./typi" privata NUMERUS
importa ex "./typi" privata FRACTUS
importa ex "./typi" privata BIVALENS
importa ex "./typi" privata NIHIL
importa ex "./typi" privata VACUUM
importa ex "./typi" privata IGNOTUM
importa ex "./typi" privata primitivumTypus
importa ex "./typi" privata genericumTypus
importa ex "./typi" privata functioTypus
importa ex "./typi" privata usitatumTypus
importa ex "./typi" privata formaTypum
importa ex "./typi" privata assignabileAd
importa ex "./typi" privata typiAequales
importa ex "./scopus" privata Scopus
importa ex "./scopus" privata Symbolum
importa ex "./scopus" privata SymbolumSpecies
importa ex "./scopus" privata ScopusSpecies
importa ex "./scopus" privata creaScopumGlobalem
importa ex "./scopus" privata creaScopum
importa ex "./scopus" privata definieSymbolum
importa ex "./scopus" privata quaereSymbolum
importa ex "./errores" privata SemanticErrorCodice
importa ex "./errores" privata SemanticErrorNuntius
importa ex "./modulus" privata ModulusResolutum
importa ex "./dependentia" privata Dependentia
importa ex "../ast/positio" privata Locus
importa ex "../ast/radix" privata Programma
importa ex "../ast/sententia" privata Sententia
importa ex "../ast/expressia" privata Expressia

# ============================================================================
# SEMANTIC ERROR
# ============================================================================

# A semantic error with source location
@ publica
genus SemanticError {
    textus nuntius
    textus auxilium
    Locus locus
}

# ============================================================================
# ANALYSIS RESULT
# ============================================================================

# Result of semantic analysis
@ publica
genus SemanticResultatum {
    @ publica
    Programma programma
    @ publica
    lista<SemanticError> errores
    @ publica
    si tabula<textus, Programma> resolvedModules
}

# ============================================================================
# DISCRETIO REGISTRY
# ============================================================================

@ publica
genus DiscretioVariansInfo {
    textus nomen
    Locus locus
}

@ publica
genus DiscretioDeclInfo {
    textus nomen
    Locus locus
    lista<DiscretioVariansInfo> variantes
}

# ============================================================================
# LATIN TYPE MAPPING
# ============================================================================

# Map Latin type name to semantic type
@ publica
functio latinTypusAd(de textus nomen) -> SemanticTypus {
    elige nomen {
        casu "textus" reddit TEXTUS
        casu "numerus" reddit NUMERUS
        casu "fractus" reddit FRACTUS
        casu "bivalens" reddit BIVALENS
        casu "nihil" reddit NIHIL
        casu "vacuum" reddit VACUUM
    }
    redde IGNOTUM
}

# Check if a type name is a generic type
@ publica
functio estGenericusTypus(de textus nomen) -> bivalens {
    redde nomen inter ["lista", "tabula", "copia", "promissum", "cursor", "fluxus"]
}

# ============================================================================
# ANALYZER STATE
# ============================================================================

# The semantic analyzer state
@ publica
genus Analyzator {
    lista<SemanticError> errores                                          # collected errors
    Scopus scopus                                                         # current scope chain
    si SemanticTypus currentFunctioReditus                                  # for return type checking
    bivalens currentFunctioAsync                                          # in async function?
    bivalens currentFunctioGenerator                                      # in generator function?
    si textus currentGenusNomen                                             # name of enclosing class for ego resolution
    lista<textus> resolvendoTypusAliases                                  # cycle detection
    tabula<textus, tabula<textus, lista<textus>>> morphologiaRegistra   # receiver -> stem -> forms
    si textus viaIngressus                                                  # entry file path for module resolution
    tabula<textus, ModulusResolutum> modulusCache                         # module cache (path -> resolved)
    copia<textus> modulusInProgressu                                      # cycle detection for imports
    tabula<textus, DiscretioDeclInfo> discretioIndex                      # declaration metadata for discretio
    tabula<textus, Dependentia> dependentiae                              # alias -> path registry from § dependentia

    # WHY: We want early visibility into where type information is missing.
    # Track per-location IGNOTUM warnings so we can emit them once.
    copia<textus> ignotumMonita

    # ========================================================================
    # ERROR REPORTING
    # ========================================================================

    # Report a semantic error
    @ publica
    functio error(ex textus nuntius, ex Locus locus, si ex textus auxilium) {
        ego.errores.appende({
            nuntius: nuntius,
            auxilium: auxilium vel "",
            locus: locus
        } novum SemanticError)
    }

    # Report a semantic warning for IGNOTUM usage.
    # These are intentionally noisy initially; later we can add CLI flags to
    # quiet/fail on them.
    @ publica
    functio moneIgnotum(ex textus ratio, ex Locus locus) -> vacuum {
        fixum key = scriptum("§:§:§:§", locus.linea, locus.columna, locus.index, ratio)
        si ego.ignotumMonita.habet(key) {
            redde
        }
        ego.ignotumMonita.adde(key)
        ego.error(scriptum("Warning: ignotum: §", ratio), locus, "Add explicit types or refine the analysis so this type is known.")
    }

    # ========================================================================
    # SCOPE MANAGEMENT
    # ========================================================================

    # Enter a new scope
    @ publica
    functio intraScopum(ScopusSpecies species) {
        ego.scopus = creaScopum(ego.scopus, species)
    }

    # Exit the current scope
    @ publica
    functio exiScopum() {
        si nonnihil ego.scopus.parens {
            ego.scopus = ego.scopus.parens novum Scopus
        }
    }

    # Define a symbol in current scope (reports error if duplicate)
    @ publica
    functio definie(ex Symbolum symbolum) {
        fixum err = definieSymbolum(ego.scopus, symbolum)
        si nonnihil err {
            ego.error(err qua textus, symbolum.locus)
        }
    }

    # Look up a symbol in scope chain
    @ publica
    functio quaere(de textus nomen) -> si Symbolum {
        redde quaereSymbolum(ego.scopus, nomen)
    }

    # ========================================================================
    # BUILTINS
    # ========================================================================

    # Define built-in functions (intrinsics) in global scope
    @ publica
    functio definieIntrinsica() {
        fixum builtinLocus = { linea: 0, columna: 0, index: 0 } novum Locus

        # I/O Intrinsics (always available - prefixed with _ for internal use)
        ego.definieIntrinsicaFunctio("_scribe", [], VACUUM, builtinLocus)
        ego.definieIntrinsicaFunctio("_vide", [], VACUUM, builtinLocus)
        ego.definieIntrinsicaFunctio("_mone", [], VACUUM, builtinLocus)
        ego.definieIntrinsicaFunctio("_lege", [], TEXTUS, builtinLocus)

        # Register morphology for built-in collection types
        fixum formae = ["imperativus", "perfectum", "futurum_indicativum", "futurum_activum"] innatum lista<textus>

        # lista verb stems
        ego.addeMorphologiam("lista", "add", formae)
        ego.addeMorphologiam("lista", "praepon", formae)
        ego.addeMorphologiam("lista", "remov", formae)
        ego.addeMorphologiam("lista", "decapit", formae)
        ego.addeMorphologiam("lista", "filtr", formae)
        ego.addeMorphologiam("lista", "mapp", formae)
        ego.addeMorphologiam("lista", "ordin", formae)
        ego.addeMorphologiam("lista", "invert", formae)
    }

    # Helper to define a single intrinsic function
    @ publica
    functio definieIntrinsicaFunctio(ex textus nomen, ex lista<SemanticTypus> parametri, ex SemanticTypus reditus, ex Locus locus) {
        fixum typusFunctionis = functioTypus(parametri, reditus, falsum, falsum)
        ego.scopus.symbola[nomen] = {
            nomen: nomen,
            semanticTypus: typusFunctionis,
            species: SymbolumSpecies.Functio,
            mutabilis: falsum,
            locus: locus
        } novum Symbolum
    }

    # ========================================================================
    # MORPHOLOGIA REGISTRY
    # ========================================================================

    @ publica
    functio definieMorphologiaBuiltin() -> vacuum {
        # WHY: lista is morphology-enabled by default for stdlib lowering.
        fixum formaeMutantes = ["imperativus", "futurum_indicativum"] qua lista<textus>
        fixum formaeNovae = ["perfectum", "futurum_activum"] qua lista<textus>
        fixum formaeOmnes = ["imperativus", "perfectum", "futurum_indicativum", "futurum_activum"] qua lista<textus>

        ego.addeMorphologiam("lista", "add", formaeOmnes)
        ego.addeMorphologiam("lista", "praepon", formaeMutantes)
        ego.addeMorphologiam("lista", "praepos", formaeNovae)
        ego.addeMorphologiam("lista", "remov", formaeOmnes)
        ego.addeMorphologiam("lista", "decapit", formaeOmnes)
        ego.addeMorphologiam("lista", "filtr", formaeOmnes)
        ego.addeMorphologiam("lista", "mapp", formaeNovae)
        ego.addeMorphologiam("lista", "ordin", formaeOmnes)
        ego.addeMorphologiam("lista", "invert", formaeMutantes)
        ego.addeMorphologiam("lista", "invers", formaeNovae)
        ego.addeMorphologiam("lista", "inver", formaeNovae)
    }

    @ publica
    functio habetMorphologiam(de textus recipiens) -> bivalens {
        si nihil ego.morphologiaRegistra[recipiens] {
            redde falsum
        }
        redde verum
    }

    @ publica
    functio formaeMorphologiae(de textus recipiens, de textus radix) -> si lista<textus> {
        fixum perRecipiens = ego.morphologiaRegistra[recipiens]
        si nihil perRecipiens {
            redde nihil
        }
        redde perRecipiens[radix]
    }

    @ publica
    functio addeMorphologiam(ex textus recipiens, ex textus radix, de lista<textus> formae) -> vacuum {
        si nihil ego.morphologiaRegistra[recipiens] {
            ego.morphologiaRegistra[recipiens] = {} innatum tabula<textus, lista<textus>>
        }

        fixum perRecipiens = ego.morphologiaRegistra[recipiens]
        si nihil perRecipiens[radix] {
            perRecipiens[radix] = [] innatum lista<textus>
        }

        fixum existentes = perRecipiens[radix]
        ex formae fixum forma {
            varia iam = falsum
            ex existentes fixum existens {
                si existens == forma {
                    iam = verum
                }
            }
            si non iam {
                existentes.appende(forma)
            }
        }
    }
}

# ============================================================================
# FACTORY
# ============================================================================

# Create a new analyzer
@ publica
functio novumAnalyzator(ex tabula<textus, Dependentia> dependentiae, si de textus viaIngressus) -> Analyzator {
    fixum analyzator = novum Analyzator {
        errores: [] innatum lista<SemanticError>,
        scopus: creaScopumGlobalem(),
        currentFunctioReditus: nihil,
        currentFunctioAsync: falsum,
        currentFunctioGenerator: falsum,
        currentGenusNomen: nihil,
        resolvendoTypusAliases: [] innatum lista<textus>,
        morphologiaRegistra: {} innatum tabula<textus, tabula<textus, lista<textus>>>,
        viaIngressus: viaIngressus,
        modulusCache: {} innatum tabula<textus, ModulusResolutum>,
        modulusInProgressu: {} innatum copia<textus>,
        discretioIndex: {} innatum tabula<textus, DiscretioDeclInfo>,
        dependentiae: dependentiae,
        ignotumMonita: {} innatum copia<textus>
    }

    # Define built-in intrinsics
    analyzator.definieIntrinsica()
    analyzator.definieMorphologiaBuiltin()

    redde analyzator
}
