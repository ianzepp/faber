# Nucleus - Core Analyzer State and Infrastructure
#
# Provides the Analyzator genus that manages semantic analysis state.

§ ex "./typi" importa SemanticTypus, TEXTUS, NUMERUS, FRACTUS, BIVALENS, NIHIL, VACUUM, IGNOTUM
§ ex "./typi" importa primitivumTypus, genericumTypus, functioTypus, usitatumTypus
§ ex "./typi" importa formaTypum, assignabileAd, typiAequales
§ ex "./scopus" importa Scopus, Symbolum, SymbolumSpecies, ScopusSpecies
§ ex "./scopus" importa creaScopumGlobalem, creaScopum, definieSymbolum, quaereSymbolum
§ ex "./errores" importa SemanticErrorCodice, SemanticErrorNuntius
§ ex "./modulus" importa ModulusResolutum
§ ex "./dependentia" importa Dependentia
§ ex "../ast/positio" importa Locus
§ ex "../ast/radix" importa Programma
§ ex "../ast/sententia" importa Sententia
§ ex "../ast/expressia" importa Expressia

# ============================================================================
# SEMANTIC ERROR
# ============================================================================

# A semantic error with source location
@ publica
genus SemanticError {
    textus nuntius
    textus auxilium
    Locus locus
}

# ============================================================================
# ANALYSIS RESULT
# ============================================================================

# Result of semantic analysis
@ publica
genus SemanticResultatum {
    @ publica
    Programma programma
    @ publica
    lista<SemanticError> errores
    @ publica
    tabula<textus, Programma>? resolvedModules
}

# ============================================================================
# DISCRETIO REGISTRY
# ============================================================================

@ publica
genus DiscretioVariansInfo {
    textus nomen
    Locus locus
}

@ publica
genus DiscretioDeclInfo {
    textus nomen
    Locus locus
    lista<DiscretioVariansInfo> variantes
}

# ============================================================================
# LATIN TYPE MAPPING
# ============================================================================

# Map Latin type name to semantic type
@ publica
functio latinTypusAd(textus nomen) -> SemanticTypus {
    elige nomen {
        casu "textus" reddit TEXTUS
        casu "numerus" reddit NUMERUS
        casu "fractus" reddit FRACTUS
        casu "bivalens" reddit BIVALENS
        casu "nihil" reddit NIHIL
        casu "vacuum" reddit VACUUM
    }
    redde IGNOTUM
}

# Check if a type name is a generic type
@ publica
functio estGenericusTypus(textus nomen) -> bivalens {
    redde nomen inter ["lista", "tabula", "copia", "promissum", "cursor", "fluxus"]
}

# ============================================================================
# ANALYZER STATE
# ============================================================================

# The semantic analyzer state
@ publica
genus Analyzator {
    lista<SemanticError> errores                                          # collected errors
    Scopus scopus                                                         # current scope chain
    SemanticTypus? currentFunctioReditus                                  # for return type checking
    bivalens currentFunctioAsync                                          # in async function?
    bivalens currentFunctioGenerator                                      # in generator function?
    textus? currentGenusNomen                                             # name of enclosing class for ego resolution
    lista<textus> resolvendoTypusAliases                                  # cycle detection
    tabula<textus, tabula<textus, lista<textus>>> morphologiaRegistra   # receiver -> stem -> forms
    textus? viaIngressus                                                  # entry file path for module resolution
    tabula<textus, ModulusResolutum> modulusCache                         # module cache (path -> resolved)
    copia<textus> modulusInProgressu                                      # cycle detection for imports
    tabula<textus, DiscretioDeclInfo> discretioIndex                      # declaration metadata for discretio
    tabula<textus, Dependentia> dependentiae                              # alias -> path registry from § dependentia

    # ========================================================================
    # ERROR REPORTING
    # ========================================================================

    # Report a semantic error
    @ publica
    functio error(textus nuntius, Locus locus, si textus auxilium) {
        ego.errores.adde({
            nuntius: nuntius,
            auxilium: auxilium vel "",
            locus: locus
        } novum SemanticError)
    }

    # ========================================================================
    # SCOPE MANAGEMENT
    # ========================================================================

    # Enter a new scope
    @ publica
    functio intraScopum(ScopusSpecies species) {
        ego.scopus = creaScopum(ego.scopus, species)
    }

    # Exit the current scope
    @ publica
    functio exiScopum() {
        si nonnihil ego.scopus.parens {
            ego.scopus = ego.scopus.parens novum Scopus
        }
    }

    # Define a symbol in current scope (reports error if duplicate)
    @ publica
    functio definie(Symbolum symbolum) {
        fixum err = definieSymbolum(ego.scopus, symbolum)
        si nonnihil err {
            ego.error(err qua textus, symbolum.locus)
        }
    }

    # Look up a symbol in scope chain
    @ publica
    functio quaere(textus nomen) -> Symbolum? {
        redde quaereSymbolum(ego.scopus, nomen)
    }

    # ========================================================================
    # BUILTINS
    # ========================================================================

    # Define built-in functions (intrinsics) in global scope
    @ publica
    functio definieIntrinsica() {
        fixum builtinLocus = { linea: 0, columna: 0, index: 0 } novum Locus

        # I/O Intrinsics (always available - prefixed with _ for internal use)
        ego.definieIntrinsicaFunctio("_scribe", [], VACUUM, builtinLocus)
        ego.definieIntrinsicaFunctio("_vide", [], VACUUM, builtinLocus)
        ego.definieIntrinsicaFunctio("_mone", [], VACUUM, builtinLocus)
        ego.definieIntrinsicaFunctio("_lege", [], TEXTUS, builtinLocus)

        # Register morphology for built-in collection types
        fixum formae = ["imperativus", "perfectum", "futurum_indicativum", "futurum_activum"] innatum lista<textus>

        # lista verb stems
        ego.addeMorphologiam("lista", "add", formae)
        ego.addeMorphologiam("lista", "praepon", formae)
        ego.addeMorphologiam("lista", "remov", formae)
        ego.addeMorphologiam("lista", "decapit", formae)
        ego.addeMorphologiam("lista", "filtr", formae)
        ego.addeMorphologiam("lista", "mapp", formae)
        ego.addeMorphologiam("lista", "ordin", formae)
        ego.addeMorphologiam("lista", "invert", formae)
    }

    # Helper to define a single intrinsic function
    @ publica
    functio definieIntrinsicaFunctio(textus nomen, lista<SemanticTypus> parametri, SemanticTypus reditus, Locus locus) {
        fixum typusFunctionis = functioTypus(parametri, reditus, falsum, falsum)
        ego.scopus.symbola[nomen] = {
            nomen: nomen,
            semanticTypus: typusFunctionis,
            species: SymbolumSpecies.Functio,
            mutabilis: falsum,
            locus: locus
        } novum Symbolum
    }

    # ========================================================================
    # MORPHOLOGIA REGISTRY
    # ========================================================================

    @ publica
    functio definieMorphologiaBuiltin() -> vacuum {
        # WHY: lista is morphology-enabled by default for stdlib lowering.
        fixum formaeMutantes = ["imperativus", "futurum_indicativum"] qua lista<textus>
        fixum formaeNovae = ["perfectum", "futurum_activum"] qua lista<textus>
        fixum formaeOmnes = ["imperativus", "perfectum", "futurum_indicativum", "futurum_activum"] qua lista<textus>

        ego.addeMorphologiam("lista", "add", formaeOmnes)
        ego.addeMorphologiam("lista", "praepon", formaeMutantes)
        ego.addeMorphologiam("lista", "praepos", formaeNovae)
        ego.addeMorphologiam("lista", "remov", formaeOmnes)
        ego.addeMorphologiam("lista", "decapit", formaeOmnes)
        ego.addeMorphologiam("lista", "filtr", formaeOmnes)
        ego.addeMorphologiam("lista", "mapp", formaeNovae)
        ego.addeMorphologiam("lista", "ordin", formaeOmnes)
        ego.addeMorphologiam("lista", "invert", formaeMutantes)
        ego.addeMorphologiam("lista", "invers", formaeNovae)
        ego.addeMorphologiam("lista", "inver", formaeNovae)
    }

    @ publica
    functio habetMorphologiam(textus recipiens) -> bivalens {
        si nihil ego.morphologiaRegistra[recipiens] {
            redde falsum
        }
        redde verum
    }

    @ publica
    functio formaeMorphologiae(textus recipiens, textus radix) -> lista<textus>? {
        fixum perRecipiens = ego.morphologiaRegistra[recipiens]
        si nihil perRecipiens {
            redde nihil
        }
        redde perRecipiens[radix]
    }

    @ publica
    functio addeMorphologiam(textus recipiens, textus radix, lista<textus> formae) -> vacuum {
        si nihil ego.morphologiaRegistra[recipiens] {
            ego.morphologiaRegistra[recipiens] = {} innatum tabula<textus, lista<textus>>
        }

        fixum perRecipiens = ego.morphologiaRegistra[recipiens]
        si nihil perRecipiens[radix] {
            perRecipiens[radix] = [] innatum lista<textus>
        }

        fixum existentes = perRecipiens[radix]
        ex formae fixum forma {
            varia iam = falsum
            ex existentes fixum existens {
                si existens == forma {
                    iam = verum
                }
            }
            si non iam {
                existentes.adde(forma)
            }
        }
    }
}

# ============================================================================
# FACTORY
# ============================================================================

# Create a new analyzer
@ publica
functio novumAnalyzator(textus? viaIngressus, tabula<textus, Dependentia> dependentiae) -> Analyzator {
    fixum analyzator = novum Analyzator {
        errores: [] innatum lista<SemanticError>,
        scopus: creaScopumGlobalem(),
        currentFunctioReditus: nihil,
        currentFunctioAsync: falsum,
        currentFunctioGenerator: falsum,
        currentGenusNomen: nihil,
        resolvendoTypusAliases: [] innatum lista<textus>,
        morphologiaRegistra: {} innatum tabula<textus, tabula<textus, lista<textus>>>,
        viaIngressus: viaIngressus,
        modulusCache: {} innatum tabula<textus, ModulusResolutum>,
        modulusInProgressu: {} innatum copia<textus>,
        discretioIndex: {} innatum tabula<textus, DiscretioDeclInfo>,
        dependentiae: dependentiae
    }

    # Define built-in intrinsics
    analyzator.definieIntrinsica()
    analyzator.definieMorphologiaBuiltin()

    redde analyzator
}
