# Resolvitor - Semantic Resolver Interface
#
# Breaks circular imports between expression and statement analyzers via a pactum.
#
# WHY: Expression analyzers may need to analyze nested statements (lambdas),
# and statement analyzers need to analyze expressions. This interface lets
# both call each other without circular imports.

ยง ex "./nucleus" importa Analyzator
ยง ex "./typi" importa SemanticTypus
ยง ex "../ast/expressia" importa Expressia
ยง ex "../ast/sententia" importa Sententia

# Semantic resolver interface for cross-module analysis
#
# Example:
#   functio analyzeXxx(Resolvitor r, Xxx node) -> SemanticTypus {
#       fixum a = r.analyzator()
#       fixum t = r.expressia(subExpr)
#       r.sententia(subStmt)
#   }
@ publica
pactum Resolvitor {
    functio analyzator() -> Analyzator

    # Bottom-up inference: "what type is this expression?"
    functio synthesize(de Expressia expr) -> SemanticTypus

    # Top-down checking: "treat this expression as expected type"
    # May use the expected type to refine inference (e.g. [] as lista<T>).
    functio check(de Expressia expr, de SemanticTypus expected) -> SemanticTypus

    # Legacy name; keep until call sites migrate.
    functio expressia(de Expressia expr) -> SemanticTypus
    functio sententia(de Sententia stmt) -> vacuum
}
