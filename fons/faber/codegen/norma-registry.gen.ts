/**
 * AUTO-GENERATED FILE - DO NOT EDIT
 * Generated by: bun run build:norma
 * Source: fons/norma/*.fab
 * Generated: 2026-01-06T16:09:18.642Z
 */

import type { NormaCollection } from './norma-registry';

export const registry: Map<string, NormaCollection> = new Map([
    ['lista', {
        name: 'lista',
        innatum: new Map([
            ['ts', 'Array'],
            ['py', 'list'],
            ['rs', 'Vec'],
            ['cpp', 'std::vector'],
            ['zig', 'Lista'],
        ]),
        methods: new Map([
            ['adde', {
                name: 'adde',
                translations: new Map([
                    ['ts', { method: 'push' }],
                    ['py', { method: 'append' }],
                    ['rs', { method: 'push' }],
                    ['cpp', { method: 'push_back' }],
                    ['zig', { template: '§.adde(§, §)', params: ['ego', 'elem', 'alloc'] }],
                ]),
                radixForms: ['add', 'imperativus', 'perfectum'],
            }],
            ['addita', {
                name: 'addita',
                translations: new Map([
                    ['ts', { template: '[...§, §]', params: ['ego', 'elem'] }],
                    ['py', { template: '[*§, §]', params: ['ego', 'elem'] }],
                    ['rs', { template: '{ let mut v = §.clone(); v.push(§); v }', params: ['ego', 'elem'] }],
                    ['cpp', { template: '[&]{ auto v = §; v.push_back(§); return v; }()', params: ['ego', 'elem'] }],
                    ['zig', { template: '§.addita(§, §)', params: ['ego', 'elem', 'alloc'] }],
                ]),
            }],
            ['praepone', {
                name: 'praepone',
                translations: new Map([
                    ['ts', { method: 'unshift' }],
                    ['py', { template: '§.insert(0, §)', params: ['ego', 'elem'] }],
                    ['rs', { template: '§.insert(0, §)', params: ['ego', 'elem'] }],
                    ['cpp', { template: '§.insert(§.begin(), §)', params: ['ego', 'elem'] }],
                    ['zig', { template: '§.praepone(§, §)', params: ['ego', 'elem', 'alloc'] }],
                ]),
                radixForms: ['praepon', 'imperativus', 'perfectum'],
            }],
            ['praeposita', {
                name: 'praeposita',
                translations: new Map([
                    ['ts', { template: '[§1, ...§0]', params: ['ego', 'elem'] }],
                    ['py', { template: '[§1, *§0]', params: ['ego', 'elem'] }],
                    ['rs', { template: '{ let mut v = vec![§1]; v.extend(§0.iter().cloned()); v }', params: ['ego', 'elem'] }],
                    ['cpp', { template: '[&]{ auto v = §0; v.insert(v.begin(), §1); return v; }()', params: ['ego', 'elem'] }],
                    ['zig', { template: '§.praeposita(§, §)', params: ['ego', 'elem', 'alloc'] }],
                ]),
            }],
            ['remove', {
                name: 'remove',
                translations: new Map([
                    ['ts', { method: 'pop' }],
                    ['py', { method: 'pop' }],
                    ['rs', { template: '§.pop()', params: ['ego'] }],
                    ['cpp', { template: '[&]{ auto v = §.back(); §.pop_back(); return v; }()', params: ['ego'] }],
                    ['zig', { template: '§.remove()', params: ['ego'] }],
                ]),
                radixForms: ['remov', 'imperativus', 'perfectum'],
            }],
            ['remota', {
                name: 'remota',
                translations: new Map([
                    ['ts', { template: '§.slice(0, -1)', params: ['ego'] }],
                    ['py', { template: '§[:-1]', params: ['ego'] }],
                    ['rs', { template: '§[..§.len().saturating_sub(1)].to_vec()', params: ['ego'] }],
                    ['cpp', { template: 'std::vector(§.begin(), §.end() - 1)', params: ['ego'] }],
                    ['zig', { template: '§.remota(§)', params: ['ego', 'alloc'] }],
                ]),
            }],
            ['decapita', {
                name: 'decapita',
                translations: new Map([
                    ['ts', { method: 'shift' }],
                    ['py', { template: '§.pop(0)', params: ['ego'] }],
                    ['rs', { template: '§.remove(0)', params: ['ego'] }],
                    ['cpp', { template: '[&]{ auto v = §.front(); §.erase(§.begin()); return v; }()', params: ['ego'] }],
                    ['zig', { template: '§.decapita()', params: ['ego'] }],
                ]),
                radixForms: ['decapit', 'imperativus', 'perfectum'],
            }],
            ['decapitata', {
                name: 'decapitata',
                translations: new Map([
                    ['ts', { template: '§.slice(1)', params: ['ego'] }],
                    ['py', { template: '§[1:]', params: ['ego'] }],
                    ['rs', { template: '§[1..].to_vec()', params: ['ego'] }],
                    ['cpp', { template: 'std::vector(§.begin() + 1, §.end())', params: ['ego'] }],
                    ['zig', { template: '§.decapitata(§)', params: ['ego', 'alloc'] }],
                ]),
            }],
            ['purga', {
                name: 'purga',
                translations: new Map([
                    ['ts', { template: '§.length = 0', params: ['ego'] }],
                    ['py', { method: 'clear' }],
                    ['rs', { method: 'clear' }],
                    ['cpp', { method: 'clear' }],
                    ['zig', { template: '§.purga()', params: ['ego'] }],
                ]),
            }],
            ['primus', {
                name: 'primus',
                translations: new Map([
                    ['ts', { template: '§[0]', params: ['ego'] }],
                    ['py', { template: '§[0]', params: ['ego'] }],
                    ['rs', { template: '§.first()', params: ['ego'] }],
                    ['cpp', { template: '§.front()', params: ['ego'] }],
                    ['zig', { template: '§.primus()', params: ['ego'] }],
                ]),
            }],
            ['ultimus', {
                name: 'ultimus',
                translations: new Map([
                    ['ts', { template: '§.at(-1)', params: ['ego'] }],
                    ['py', { template: '§[-1]', params: ['ego'] }],
                    ['rs', { template: '§.last()', params: ['ego'] }],
                    ['cpp', { template: '§.back()', params: ['ego'] }],
                    ['zig', { template: '§.ultimus()', params: ['ego'] }],
                ]),
            }],
            ['accipe', {
                name: 'accipe',
                translations: new Map([
                    ['ts', { template: '§[§]', params: ['ego', 'idx'] }],
                    ['py', { template: '§[§]', params: ['ego', 'idx'] }],
                    ['rs', { template: '§.get(§)', params: ['ego', 'idx'] }],
                    ['cpp', { template: '§.at(§)', params: ['ego', 'idx'] }],
                    ['zig', { template: '§.accipe(§)', params: ['ego', 'idx'] }],
                ]),
            }],
            ['longitudo', {
                name: 'longitudo',
                translations: new Map([
                    ['ts', { template: '§.length', params: ['ego'] }],
                    ['py', { template: 'len(§)', params: ['ego'] }],
                    ['rs', { template: '§.len()', params: ['ego'] }],
                    ['cpp', { template: '§.size()', params: ['ego'] }],
                    ['zig', { template: '§.longitudo()', params: ['ego'] }],
                ]),
            }],
            ['vacua', {
                name: 'vacua',
                translations: new Map([
                    ['ts', { template: '§.length === 0', params: ['ego'] }],
                    ['py', { template: 'len(§) == 0', params: ['ego'] }],
                    ['rs', { template: '§.is_empty()', params: ['ego'] }],
                    ['cpp', { template: '§.empty()', params: ['ego'] }],
                    ['zig', { template: '§.vacua()', params: ['ego'] }],
                ]),
            }],
            ['continet', {
                name: 'continet',
                translations: new Map([
                    ['ts', { method: 'includes' }],
                    ['py', { template: '(§ in §)', params: ['ego', 'elem'] }],
                    ['rs', { template: '§.contains(&§)', params: ['ego', 'elem'] }],
                    ['cpp', { template: '(std::find(§.begin(), §.end(), §) != §.end())', params: ['ego', 'elem'] }],
                    ['zig', { template: '§.continet(§)', params: ['ego', 'elem'] }],
                ]),
            }],
            ['indiceDe', {
                name: 'indiceDe',
                translations: new Map([
                    ['ts', { method: 'indexOf' }],
                    ['py', { template: '§.index(§)', params: ['ego', 'elem'] }],
                    ['rs', { template: '§.iter().position(|e| e == &§)', params: ['ego', 'elem'] }],
                    ['cpp', { template: '[&]{ auto it = std::find(§.begin(), §.end(), §); return it != §.end() ? std::distance(§.begin(), it) : -1; }()', params: ['ego', 'elem'] }],
                    ['zig', { template: '§.indiceDe(§)', params: ['ego', 'elem'] }],
                ]),
            }],
            ['inveni', {
                name: 'inveni',
                translations: new Map([
                    ['ts', { method: 'find' }],
                    ['py', { template: 'next(filter(§, §), None)', params: ['ego', 'pred'] }],
                    ['rs', { template: '§.iter().find(§)', params: ['ego', 'pred'] }],
                    ['cpp', { template: '*std::find_if(§.begin(), §.end(), §)', params: ['ego', 'pred'] }],
                    ['zig', { template: '§.inveni(§)', params: ['ego', 'pred'] }],
                ]),
            }],
            ['inveniIndicem', {
                name: 'inveniIndicem',
                translations: new Map([
                    ['ts', { method: 'findIndex' }],
                    ['py', { template: 'next((i for i, x in enumerate(§) if (§)(x)), -1)', params: ['ego', 'pred'] }],
                    ['rs', { template: '§.iter().position(§)', params: ['ego', 'pred'] }],
                    ['cpp', { template: '[&]{ auto it = std::find_if(§.begin(), §.end(), §); return it != §.end() ? std::distance(§.begin(), it) : -1; }()', params: ['ego', 'pred'] }],
                    ['zig', { template: '§.inveniIndicem(§)', params: ['ego', 'pred'] }],
                ]),
            }],
            ['omnes', {
                name: 'omnes',
                translations: new Map([
                    ['ts', { method: 'every' }],
                    ['py', { template: 'all(map(§, §))', params: ['ego', 'pred'] }],
                    ['rs', { template: '§.iter().all(§)', params: ['ego', 'pred'] }],
                    ['cpp', { template: 'std::ranges::all_of(§, §)', params: ['ego', 'pred'] }],
                    ['zig', { template: '§.omnes(§)', params: ['ego', 'pred'] }],
                ]),
            }],
            ['aliquis', {
                name: 'aliquis',
                translations: new Map([
                    ['ts', { method: 'some' }],
                    ['py', { template: 'any(map(§, §))', params: ['ego', 'pred'] }],
                    ['rs', { template: '§.iter().any(§)', params: ['ego', 'pred'] }],
                    ['cpp', { template: 'std::ranges::any_of(§, §)', params: ['ego', 'pred'] }],
                    ['zig', { template: '§.aliquis(§)', params: ['ego', 'pred'] }],
                ]),
            }],
            ['filtrata', {
                name: 'filtrata',
                translations: new Map([
                    ['ts', { method: 'filter' }],
                    ['py', { template: 'list(filter(§, §))', params: ['ego', 'pred'] }],
                    ['rs', { template: '§.iter().filter(§).cloned().collect::<Vec<_>>()', params: ['ego', 'pred'] }],
                    ['cpp', { template: '(§ | std::views::filter(§) | std::ranges::to<std::vector>())', params: ['ego', 'pred'] }],
                    ['zig', { template: '§.filtrata(§, §)', params: ['ego', 'pred', 'alloc'] }],
                ]),
                radixForms: ['filtr', 'imperativus', 'perfectum'],
            }],
            ['mappata', {
                name: 'mappata',
                translations: new Map([
                    ['ts', { method: 'map' }],
                    ['py', { template: 'list(map(§, §))', params: ['ego', 'fn'] }],
                    ['rs', { template: '§.iter().map(§).collect::<Vec<_>>()', params: ['ego', 'fn'] }],
                    ['cpp', { template: '(§ | std::views::transform(§) | std::ranges::to<std::vector>())', params: ['ego', 'fn'] }],
                    ['zig', { template: '§.mappata(§, §)', params: ['ego', 'fn', 'alloc'] }],
                ]),
            }],
            ['explanata', {
                name: 'explanata',
                translations: new Map([
                    ['ts', { method: 'flatMap' }],
                    ['py', { template: '[y for x in § for y in (§)(x)]', params: ['ego', 'fn'] }],
                    ['rs', { template: '§.iter().flat_map(§).collect::<Vec<_>>()', params: ['ego', 'fn'] }],
                    ['cpp', { template: '(§ | std::views::transform(§) | std::views::join | std::ranges::to<std::vector>())', params: ['ego', 'fn'] }],
                ]),
            }],
            ['plana', {
                name: 'plana',
                translations: new Map([
                    ['ts', { method: 'flat' }],
                    ['py', { template: '[y for x in § for y in x]', params: ['ego'] }],
                    ['rs', { template: '§.iter().flatten().cloned().collect::<Vec<_>>()', params: ['ego'] }],
                    ['cpp', { template: '(§ | std::views::join | std::ranges::to<std::vector>())', params: ['ego'] }],
                ]),
            }],
            ['inversa', {
                name: 'inversa',
                translations: new Map([
                    ['ts', { template: '[...§].reverse()', params: ['ego'] }],
                    ['py', { template: '§[::-1]', params: ['ego'] }],
                    ['rs', { template: '§.iter().rev().cloned().collect::<Vec<_>>()', params: ['ego'] }],
                    ['cpp', { template: '(§ | std::views::reverse | std::ranges::to<std::vector>())', params: ['ego'] }],
                    ['zig', { template: '§.inversa(§)', params: ['ego', 'alloc'] }],
                ]),
                radixForms: ['invert', 'imperativus', 'perfectum'],
            }],
            ['ordinata', {
                name: 'ordinata',
                translations: new Map([
                    ['ts', { template: '[...§].sort()', params: ['ego'] }],
                    ['py', { template: 'sorted(§)', params: ['ego'] }],
                    ['rs', { template: '{ let mut v = §.clone(); v.sort(); v }', params: ['ego'] }],
                    ['cpp', { template: '[&]{ auto v = §; std::ranges::sort(v); return v; }()', params: ['ego'] }],
                    ['zig', { template: '§.ordinata(§)', params: ['ego', 'alloc'] }],
                ]),
                radixForms: ['ordin', 'imperativus', 'perfectum'],
            }],
            ['sectio', {
                name: 'sectio',
                translations: new Map([
                    ['ts', { method: 'slice' }],
                    ['py', { template: '§[§:§]', params: ['ego', 'start', 'end'] }],
                    ['rs', { template: '§[§..§].to_vec()', params: ['ego', 'start', 'end'] }],
                    ['cpp', { template: 'std::vector(§.begin() + §, §.begin() + §)', params: ['ego', 'start', 'end'] }],
                    ['zig', { template: '§.sectio(§, §, §)', params: ['ego', 'start', 'end', 'alloc'] }],
                ]),
            }],
            ['reducta', {
                name: 'reducta',
                translations: new Map([
                    ['ts', { method: 'reduce' }],
                    ['py', { template: 'functools.reduce(§, §, §)', params: ['ego', 'fn', 'init'] }],
                    ['rs', { template: '§.iter().fold(§, §)', params: ['ego', 'fn', 'init'] }],
                    ['cpp', { template: 'std::ranges::fold_left(§, §, §)', params: ['ego', 'fn', 'init'] }],
                    ['zig', { template: '§.reducta(§, §)', params: ['ego', 'fn', 'init'] }],
                ]),
            }],
            ['filtra', {
                name: 'filtra',
                translations: new Map([
                    ['ts', { template: '(() => { for (let i = §.length - 1; i >= 0; i--) { if (!(§)(§[i])) §.splice(i, 1); } })()', params: ['ego', 'pred'] }],
                    ['py', { template: '§[:] = [x for x in § if (§)(x)]', params: ['ego', 'pred'] }],
                    ['cpp', { template: '§.erase(std::remove_if(§.begin(), §.end(), [&](auto& x) { return !(§)(x); }), §.end())', params: ['ego', 'pred'] }],
                ]),
            }],
            ['inverte', {
                name: 'inverte',
                translations: new Map([
                    ['ts', { method: 'reverse' }],
                    ['py', { template: '§.reverse()', params: ['ego'] }],
                    ['rs', { template: '§.reverse()', params: ['ego'] }],
                    ['cpp', { template: 'std::ranges::reverse(§)', params: ['ego'] }],
                    ['zig', { template: '§.inverte()', params: ['ego'] }],
                ]),
            }],
            ['perambula', {
                name: 'perambula',
                translations: new Map([
                    ['ts', { method: 'forEach' }],
                    ['py', { template: '[(§)(x) for x in §]', params: ['ego', 'fn'] }],
                    ['rs', { template: '§.iter().for_each(§)', params: ['ego', 'fn'] }],
                    ['cpp', { template: 'std::ranges::for_each(§, §)', params: ['ego', 'fn'] }],
                    ['zig', { template: '§.perambula(§)', params: ['ego', 'fn'] }],
                ]),
            }],
            ['coniunge', {
                name: 'coniunge',
                translations: new Map([
                    ['ts', { method: 'join' }],
                    ['py', { template: '§.join(§)', params: ['ego', 'sep'] }],
                    ['rs', { template: '§.join(§)', params: ['ego', 'sep'] }],
                    ['cpp', { template: '[&]{ std::string r; for (size_t i = 0; i < §.size(); ++i) { if (i > 0) r += §; r += §[i]; } return r; }()', params: ['ego', 'sep'] }],
                ]),
            }],
            ['medium', {
                name: 'medium',
                translations: new Map([
                    ['ts', { template: '(§.reduce((a, b) => a + b, 0) / §.length)', params: ['ego'] }],
                    ['py', { template: '(sum(§) / len(§))', params: ['ego'] }],
                    ['rs', { template: '(§.iter().sum::<i64>() as f64 / §.len() as f64)', params: ['ego'] }],
                    ['cpp', { template: '(std::accumulate(§.begin(), §.end(), 0.0) / §.size())', params: ['ego'] }],
                    ['zig', { template: '§.medium()', params: ['ego'] }],
                ]),
            }],
            ['minimus', {
                name: 'minimus',
                translations: new Map([
                    ['ts', { template: 'Math.min(...§)', params: ['ego'] }],
                    ['py', { template: 'min(§)', params: ['ego'] }],
                    ['rs', { template: '§.iter().min()', params: ['ego'] }],
                    ['cpp', { template: '*std::ranges::min_element(§)', params: ['ego'] }],
                    ['zig', { template: '§.minimus()', params: ['ego'] }],
                ]),
            }],
            ['maximus', {
                name: 'maximus',
                translations: new Map([
                    ['ts', { template: 'Math.max(...§)', params: ['ego'] }],
                    ['py', { template: 'max(§)', params: ['ego'] }],
                    ['rs', { template: '§.iter().max()', params: ['ego'] }],
                    ['cpp', { template: '*std::ranges::max_element(§)', params: ['ego'] }],
                    ['zig', { template: '§.maximus()', params: ['ego'] }],
                ]),
            }],
            ['minimusPer', {
                name: 'minimusPer',
                translations: new Map([
                    ['ts', { template: '§.reduce((min, x) => (§)(x) < (§)(min) ? x : min)', params: ['ego', 'fn'] }],
                    ['rs', { template: '§.iter().min_by_key(§)', params: ['ego', 'fn'] }],
                    ['cpp', { template: '*std::ranges::min_element(§, [&](auto& a, auto& b) { return (§)(a) < (§)(b); })', params: ['ego', 'fn'] }],
                ]),
            }],
            ['maximusPer', {
                name: 'maximusPer',
                translations: new Map([
                    ['ts', { template: '§.reduce((max, x) => (§)(x) > (§)(max) ? x : max)', params: ['ego', 'fn'] }],
                    ['rs', { template: '§.iter().max_by_key(§)', params: ['ego', 'fn'] }],
                    ['cpp', { template: '*std::ranges::max_element(§, [&](auto& a, auto& b) { return (§)(a) < (§)(b); })', params: ['ego', 'fn'] }],
                ]),
            }],
            ['numera', {
                name: 'numera',
                translations: new Map([
                    ['ts', { template: '§.filter(§).length', params: ['ego', 'pred'] }],
                    ['py', { template: 'sum(1 for x in § if (§)(x))', params: ['ego', 'pred'] }],
                    ['rs', { template: '§.iter().filter(§).count()', params: ['ego', 'pred'] }],
                    ['cpp', { template: 'std::ranges::count_if(§, §)', params: ['ego', 'pred'] }],
                    ['zig', { template: '§.numera(§)', params: ['ego', 'pred'] }],
                ]),
            }],
            ['congrega', {
                name: 'congrega',
                translations: new Map([
                    ['ts', { template: 'Object.groupBy(§, §)', params: ['ego', 'fn'] }],
                    ['py', { template: '{k: list(g) for k, g in itertools.groupby(sorted(§, key=§), key=§)}', params: ['ego', 'fn'] }],
                    ['cpp', { template: '[&]{ std::unordered_map<decltype((§)(§[0])), std::vector<decltype(§[0])>> m; for (auto& x : §) m[(§)(x)].push_back(x); return m; }()', params: ['ego', 'fn'] }],
                ]),
            }],
            ['unica', {
                name: 'unica',
                translations: new Map([
                    ['ts', { template: '[...new Set(§)]', params: ['ego'] }],
                    ['py', { template: 'list(dict.fromkeys(§))', params: ['ego'] }],
                    ['rs', { template: '{ let mut seen = std::collections::HashSet::new(); §.iter().filter(|x| seen.insert((*x).clone())).cloned().collect::<Vec<_>>() }', params: ['ego'] }],
                    ['cpp', { template: '[&]{ std::unordered_set<decltype(§[0])> s(§.begin(), §.end()); return std::vector(s.begin(), s.end()); }()', params: ['ego'] }],
                ]),
            }],
            ['planaOmnia', {
                name: 'planaOmnia',
                translations: new Map([
                    ['ts', { template: '§.flat(Infinity)', params: ['ego'] }],
                    ['cpp', { template: '(§ | std::views::join | std::ranges::to<std::vector>())', params: ['ego'] }],
                ]),
            }],
            ['fragmenta', {
                name: 'fragmenta',
                translations: new Map([
                    ['ts', { template: 'Array.from({ length: Math.ceil(§.length / §) }, (_, i) => §.slice(i * §, i * § + §))', params: ['ego', 'n'] }],
                    ['py', { template: '[§[i:i+§] for i in range(0, len(§), §)]', params: ['ego', 'n'] }],
                    ['rs', { template: '§.chunks(§).map(|c| c.to_vec()).collect::<Vec<_>>()', params: ['ego', 'n'] }],
                    ['cpp', { template: '(§ | std::views::chunk(§) | std::ranges::to<std::vector<std::vector<decltype(§[0])>>>())', params: ['ego', 'n'] }],
                ]),
            }],
            ['densa', {
                name: 'densa',
                translations: new Map([
                    ['ts', { template: '§.filter(Boolean)', params: ['ego'] }],
                    ['py', { template: '[x for x in § if x]', params: ['ego'] }],
                    ['cpp', { template: '(§ | std::views::filter([](auto& x) { return static_cast<bool>(x); }) | std::ranges::to<std::vector>())', params: ['ego'] }],
                ]),
            }],
            ['partire', {
                name: 'partire',
                translations: new Map([
                    ['ts', { template: '§.reduce(([t, f], x) => (§)(x) ? [[...t, x], f] : [t, [...f, x]], [[], []])', params: ['ego', 'pred'] }],
                    ['py', { template: '[[x for x in § if (§)(x)], [x for x in § if not (§)(x)]]', params: ['ego', 'pred'] }],
                    ['rs', { template: '§.iter().cloned().partition::<Vec<_>, _>(§)', params: ['ego', 'pred'] }],
                    ['cpp', { template: '[&]{ std::vector<decltype(§[0])> t, f; for (auto& x : §) ((§)(x) ? t : f).push_back(x); return std::make_pair(t, f); }()', params: ['ego', 'pred'] }],
                ]),
            }],
            ['misce', {
                name: 'misce',
                translations: new Map([
                    ['ts', { template: '(() => { const a = [...§]; for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; } return a; })()', params: ['ego'] }],
                    ['py', { template: 'random.shuffle(§)', params: ['ego'] }],
                    ['cpp', { template: '[&]{ auto v = §; std::random_device rd; std::mt19937 g(rd()); std::ranges::shuffle(v, g); return v; }()', params: ['ego'] }],
                ]),
            }],
            ['specimen', {
                name: 'specimen',
                translations: new Map([
                    ['ts', { template: '§[Math.floor(Math.random() * §.length)]', params: ['ego'] }],
                    ['py', { template: 'random.choice(§)', params: ['ego'] }],
                    ['cpp', { template: '§[std::random_device{}() % §.size()]', params: ['ego'] }],
                ]),
            }],
            ['specimina', {
                name: 'specimina',
                translations: new Map([
                    ['ts', { template: '(() => { const a = [...§]; for (let i = a.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [a[i], a[j]] = [a[j], a[i]]; } return a.slice(0, §); })()', params: ['ego', 'n'] }],
                    ['py', { template: 'random.sample(§, §)', params: ['ego', 'n'] }],
                    ['cpp', { template: '[&]{ auto v = §; std::random_device rd; std::mt19937 g(rd()); std::ranges::shuffle(v, g); v.resize(std::min(§, v.size())); return v; }()', params: ['ego', 'n'] }],
                ]),
            }],
        ]),
    }],
]);
