# Scriptum expressions - format string functionality
# Maps Faber scriptum() to target-language format string equivalents
#
# Faber uses § (section sign) as its placeholder syntax.

- name: scriptum with single argument
  source: 'scriptum("Hello, §", name)'
  wrap: 'cura arena fit alloc { $ }'
  expect:
      ts:
          - '`Hello, ${name}`'
      py:
          - '"Hello, {}".format(name)'
      rs:
          - 'format!("Hello, {}", name)'
      cpp:
          - 'std::format("Hello, {}", name)'
      zig:
          - 'std.fmt.allocPrint(alloc, "Hello, {any}", .{ name }) catch @panic("OOM")'
      fab:
          - 'scriptum("Hello, §", name)'

- name: scriptum with multiple arguments
  source: 'scriptum("§ + § = §", a, b, c)'
  wrap: 'cura arena fit alloc { $ }'
  expect:
      ts:
          - '`${a} + ${b} = ${c}`'
      py:
          - '"{} + {} = {}".format(a, b, c)'
      rs:
          - 'format!("{} + {} = {}", a, b, c)'
      cpp:
          - 'std::format("{} + {} = {}", a, b, c)'
      zig:
          - 'std.fmt.allocPrint(alloc, "{any} + {any} = {any}", .{ a, b, c }) catch @panic("OOM")'
      fab:
          - 'scriptum("§ + § = §", a, b, c)'

- name: scriptum with no arguments (constant string)
  source: 'scriptum("Hello, World!")'
  wrap: 'cura arena fit alloc { $ }'
  expect:
      ts:
          - '"Hello, World!"'
      py:
          - '"Hello, World!"'
      rs:
          - '"Hello, World!".to_string()'
      cpp:
          - '"Hello, World!"'
      zig:
          - '"Hello, World!"'
      fab:
          - 'scriptum("Hello, World!")'

- name: scriptum in variable assignment
  source: 'fixum greeting = scriptum("Hello, §", name)'
  wrap: 'cura arena fit alloc { $ }'
  expect:
      ts:
          - 'const greeting = `Hello, ${name}`'
      py:
          - 'greeting = "Hello, {}".format(name)'
      rs:
          - 'let greeting = format!("Hello, {}", name)'
      cpp:
          - 'const auto greeting = std::format("Hello, {}", name)'
      zig:
          - 'const greeting = std.fmt.allocPrint(alloc, "Hello, {any}", .{ name }) catch @panic("OOM")'
      fab:
          - 'fixum greeting = scriptum("Hello, §", name)'

- name: scriptum with expression argument
  source: 'scriptum("Result: §", a + b)'
  wrap: 'cura arena fit alloc { $ }'
  expect:
      ts:
          - '`Result: ${(a + b)}`'
      py:
          - '"Result: {}".format((a + b))'
      rs:
          - 'format!("Result: {}", (a + b))'
      cpp:
          - 'std::format("Result: {}", (a + b))'
      zig:
          - 'std.fmt.allocPrint(alloc, "Result: {any}", .{ (a + b) }) catch @panic("OOM")'
      fab:
          - 'scriptum("Result: §", a + b)'

- name: scriptum with punctuation after placeholder
  source: 'scriptum("Hello, §!", name)'
  wrap: 'cura arena fit alloc { $ }'
  expect:
      ts:
          - '`Hello, ${name}!`'
      py:
          - '"Hello, {}!".format(name)'
      rs:
          - 'format!("Hello, {}!", name)'
      cpp:
          - 'std::format("Hello, {}!", name)'
      zig:
          - 'std.fmt.allocPrint(alloc, "Hello, {any}!", .{ name }) catch @panic("OOM")'
      fab:
          - 'scriptum("Hello, §!", name)'

# Indexed placeholder tests (§0, §1, etc.)

- name: scriptum with indexed placeholders in order
  source: 'scriptum("§0 and §1", a, b)'
  wrap: 'cura arena fit alloc { $ }'
  expect:
      ts:
          - '`${a} and ${b}`'
      py:
          - '"{0} and {1}".format(a, b)'
      rs:
          - 'format!("{0} and {1}", a, b)'
      cpp:
          - 'std::format("{0} and {1}", a, b)'
      zig:
          - 'std.fmt.allocPrint(alloc, "{any} and {any}", .{ a, b }) catch @panic("OOM")'
      fab:
          - 'scriptum("§0 and §1", a, b)'

- name: scriptum with indexed placeholders reversed
  source: 'scriptum("§1 before §0", a, b)'
  wrap: 'cura arena fit alloc { $ }'
  expect:
      ts:
          - '`${b} before ${a}`'
      py:
          - '"{1} before {0}".format(a, b)'
      rs:
          - 'format!("{1} before {0}", a, b)'
      cpp:
          - 'std::format("{1} before {0}", a, b)'
      zig:
          - 'std.fmt.allocPrint(alloc, "{any} before {any}", .{ b, a }) catch @panic("OOM")'
      fab:
          - 'scriptum("§1 before §0", a, b)'

- name: scriptum with mixed implicit and indexed placeholders
  source: 'scriptum("§ then §1 then §0", a, b)'
  wrap: 'cura arena fit alloc { $ }'
  expect:
      ts:
          - '`${a} then ${b} then ${a}`'
      py:
          - '"{} then {1} then {0}".format(a, b)'
      rs:
          - 'format!("{} then {1} then {0}", a, b)'
      cpp:
          - 'std::format("{} then {1} then {0}", a, b)'
      zig:
          - 'std.fmt.allocPrint(alloc, "{any} then {any} then {any}", .{ a, b, a }) catch @panic("OOM")'
      fab:
          - 'scriptum("§ then §1 then §0", a, b)'

- name: scriptum with repeated indexed placeholder
  source: 'scriptum("§0 + §0 = §1", x, y)'
  wrap: 'cura arena fit alloc { $ }'
  expect:
      ts:
          - '`${x} + ${x} = ${y}`'
      py:
          - '"{0} + {0} = {1}".format(x, y)'
      rs:
          - 'format!("{0} + {0} = {1}", x, y)'
      cpp:
          - 'std::format("{0} + {0} = {1}", x, y)'
      zig:
          - 'std.fmt.allocPrint(alloc, "{any} + {any} = {any}", .{ x, x, y }) catch @panic("OOM")'
      fab:
          - 'scriptum("§0 + §0 = §1", x, y)'
