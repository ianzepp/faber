//! Rust code generation

mod decl;
mod stmt;
mod expr;
mod types;

use super::{Codegen, CodegenError, CodeWriter};
use crate::hir::{HirProgram, HirItem, HirItemKind};
use crate::semantic::TypeTable;
use crate::{RustOutput, CrateDep};

/// Rust code generator
pub struct RustCodegen {
    crate_name: String,
}

impl RustCodegen {
    pub fn new(crate_name: String) -> Self {
        Self { crate_name }
    }

    fn generate_prelude(&self, w: &mut CodeWriter) {
        w.writeln("// Generated by radix - do not edit");
        w.newline();
        w.writeln("#![allow(unused_imports)]");
        w.writeln("#![allow(unused_variables)]");
        w.writeln("#![allow(dead_code)]");
        w.newline();
        w.writeln("use std::collections::{HashMap, HashSet};");
        w.newline();
    }

    fn generate_item(
        &self,
        item: &HirItem,
        types: &TypeTable,
        w: &mut CodeWriter,
    ) -> Result<(), CodegenError> {
        match &item.kind {
            HirItemKind::Function(func) => {
                decl::generate_function(func, types, w)?;
            }
            HirItemKind::Struct(s) => {
                decl::generate_struct(s, types, w)?;
            }
            HirItemKind::Enum(e) => {
                decl::generate_enum(e, types, w)?;
            }
            HirItemKind::Interface(i) => {
                decl::generate_trait(i, types, w)?;
            }
            HirItemKind::TypeAlias(a) => {
                decl::generate_type_alias(a, types, w)?;
            }
            HirItemKind::Const(c) => {
                decl::generate_const(c, types, w)?;
            }
            HirItemKind::Import(_) => {
                // Handled in prelude or use statements
            }
        }
        Ok(())
    }
}

impl Codegen for RustCodegen {
    type Output = RustOutput;

    fn generate(
        &self,
        hir: &HirProgram,
        types: &TypeTable,
    ) -> Result<RustOutput, CodegenError> {
        let mut w = CodeWriter::new();

        self.generate_prelude(&mut w);

        for item in &hir.items {
            self.generate_item(item, types, &mut w)?;
            w.newline();
        }

        // Generate main if there's an entry point
        if let Some(_entry) = hir.entry {
            w.writeln("fn main() {");
            w.indented(|w| {
                w.writeln("// Entry point");
            });
            w.writeln("}");
        }

        Ok(RustOutput {
            code: w.finish(),
            crate_name: self.crate_name.clone(),
            dependencies: vec![
                // Add standard dependencies
            ],
        })
    }
}
