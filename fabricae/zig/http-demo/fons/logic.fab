// =============================================================================
// BUSINESS LOGIC FOR ZIG HTTP DEMO
// =============================================================================
//
// This file contains business logic that compiles cleanly to Zig.
// The HTTP server wrapper (in native Zig) imports and uses these functions.
//
// WHAT WORKS:
//   - Struct definitions (genus)
//   - Function declarations with type annotations
//   - Control flow (si/aliter, dum)
//   - Numeric operations
//   - Boolean logic
//
// WHAT DOESN'T WORK YET:
//   - String concatenation (requires allocator)
//   - Collection operations (lista.adde, etc.)
//   - Async/await patterns
//
// =============================================================================

// =============================================================================
// DATA STRUCTURES
// =============================================================================

// User record - compiles to Zig struct with init() method
genus User {
    numerus id: 0
    textus nomen: ""
    textus email: ""
    bivalens active: verum
}

// API response wrapper
genus ApiResponse {
    bivalens success: verum
    numerus status: 200
}

// =============================================================================
// VALIDATION FUNCTIONS
// =============================================================================

// Validate user ID is positive
functio isValidId(numerus id) -> bivalens {
    redde id > 0
}

// Validate email has @ symbol (simplified)
// WHY: Full email validation is complex; this is a placeholder
functio isValidEmail(textus email) -> bivalens {
    // Zig codegen limitation: can't iterate strings easily
    // This returns true as a placeholder
    redde verum
}

// Validate user record
functio validateUser(User user) -> bivalens {
    si non isValidId(user.id) {
        redde falsum
    }

    si user.nomen === "" {
        redde falsum
    }

    redde verum
}

// =============================================================================
// NUMERIC UTILITIES
// =============================================================================

// Clamp a value to a range
functio clamp(numerus value, numerus min, numerus max) -> numerus {
    si value < min {
        redde min
    }
    si value > max {
        redde max
    }
    redde value
}

// =============================================================================
// STATUS CODE HELPERS
// =============================================================================

// Check if status indicates success (2xx)
functio isSuccess(numerus status) -> bivalens {
    redde status >= 200 et status < 300
}

// Check if status indicates client error (4xx)
functio isClientError(numerus status) -> bivalens {
    redde status >= 400 et status < 500
}

// Check if status indicates server error (5xx)
functio isServerError(numerus status) -> bivalens {
    redde status >= 500 et status < 600
}

// =============================================================================
// EXAMPLE USAGE (runs in main)
// =============================================================================

scribe "Logic module loaded"

fixum testUser = novum User {
    id: 1,
    nomen: "Marcus",
    email: "marcus@roma.it"
}

si validateUser(testUser) {
    scribe "User is valid"
} aliter {
    scribe "User is invalid"
}

scribe "Status 200 is success:", isSuccess(200)
scribe "Clamped:", clamp(150, 0, 100)
