// =============================================================================
// HTTP SERVER - C++ via Crow
// =============================================================================
//
// REST API written in Faber, compiled to C++23.
// Uses Crow framework (header-only, similar to Flask/Express).
//
// BUILD:
//   bun run compile fons/main.fab -t cpp -o src/main.cpp
//   mkdir build && cd build && cmake .. && make
//   ./http-demo
//
// =============================================================================

ex "crow" importa SimpleApp, request, response, json

// =============================================================================
// DATA STRUCTURES
// =============================================================================

genus User {
    numerus id: 0
    textus nomen: ""
    textus email: ""
    bivalens active: verum
}

genus App {
    numerus nextId: 1
}

// =============================================================================
// VALIDATION
// =============================================================================

functio isValidId(numerus id) -> bivalens {
    redde id > 0
}

functio validateUser(de User user) -> bivalens {
    si non isValidId(user.id) {
        redde falsum
    }
    si user.nomen === "" {
        redde falsum
    }
    redde verum
}

// =============================================================================
// JSON HELPERS  
// =============================================================================

// WHY: Convert User to JSON object
functio userToJson(de User user) -> objectum {
    redde {
        id: user.id,
        nomen: user.nomen,
        email: user.email,
        active: user.active
    }
}

// =============================================================================
// ROUTE HANDLERS
// =============================================================================

// WHY de: Crow passes request by const reference
// WHY in: Response needs to be modified

functio handleIndex(de request req, in response res) {
    res.body = "Salve! C++ HTTP Demo"
}

functio handleHealth(de request req, in response res) {
    res.json({ status: "ok" })
}

functio handleGetUsers(de request req, in response res) {
    res.json({ message: "User list", count: 0 })
}

functio handleGetUser(de request req, in response res, numerus id) {
    si non isValidId(id) {
        res.code = 400
        res.json({ error: "Invalid ID" })
        redde
    }
    
    res.json({ id: id, nomen: "Marcus", email: "marcus@roma.it" })
}

functio handleCreateUser(de request req, in response res, in App app) {
    fixum id = app.nextId
    app.nextId += 1
    
    res.code = 201
    res.json({ id: id, message: "Created" })
}

functio handleDeleteUser(de request req, in response res, numerus id) {
    res.code = 204
}

// =============================================================================
// SERVER SETUP
// =============================================================================

scribe "Initializing HTTP server..."

// Create app state
varia app = novum App()

// Create Crow application
varia server = novum SimpleApp()

// Register routes using Crow's lambda syntax
// WHY: Crow uses CROW_ROUTE macro, but we can use method chaining

server.route("/").get(pro req, res { handleIndex(req, res) })
server.route("/health").get(pro req, res { handleHealth(req, res) })
server.route("/users").get(pro req, res { handleGetUsers(req, res) })
server.route("/users/<int>").get(pro req, res, id { handleGetUser(req, res, id) })
server.route("/users").post(pro req, res { handleCreateUser(req, res, app) })
server.route("/users/<int>").delete(pro req, res, id { handleDeleteUser(req, res, id) })

scribe "Server running on http://localhost:3000"

// Start server
server.port(3000).run()
